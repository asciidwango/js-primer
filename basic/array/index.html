
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>配列 · JavaScript Primer #jsprimer</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="配列は値を順番に格納できるオブジェクトです。この配列の作成、更新、削除などの基本的な操作や実際に使い方についてを紹介します。また配列における破壊的なメソッドと非破壊的メソッドの違いについても紹介します。">
        <meta name="generator" content="HonKit 5.1.4">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-page-toc-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-anchors/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

         
    
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="../string/" />
    
    
    <link rel="prev" href="../prototype-object/" />
    

    <link rel="canonical" href="https://jsprimer.net/basic/array/">

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-DWY0DLHWB6"></script>
<script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }

    gtag("js", new Date());

    gtag("config", "G-DWY0DLHWB6");
</script>
<script type="module">
    // コンソールUIでコード実行したらイベントとして送信する
    const onExecuteCode = (scriptType) => {
        gtag("event", "execute_code", {
            "event_category": "console",
            "event_label": "execute_code",
            "script_type": scriptType || "unknown"
        });
    };
    let observer;
    const observeEvalEvent = () => {
        if (observer) {
            observer.disconnect();
        }
        const callback = function(mutationsList) {
            for (const mutation of mutationsList) {
                const mirrorConsole = Array.from(mutation.addedNodes).find(node => Boolean(node.dataset.mirrorConsole));
                if (mirrorConsole) {
                    return onExecuteCode(mirrorConsole.dataset.mirrorConsole);
                }
            }
        };
        observer = new MutationObserver(callback);
        observer.observe(document.body, { childList: true });
    };
    const eventMap = new WeakMap();
    // 問題を報告ボタンを押したらイベントとして送信する
    const onClickIssueReport = () => {
        console.log("click_issue_report");
        gtag("event", "click_issue_report", {
            "event_category": "contribution",
            "event_label": "click_issue_report"
        });
    };
    const observeIssueReport = () => {
        const targetButton = document.querySelector(".gitbook-plugin-github-issue-feedback");
        // すでにイベントが登録されていたら何もしない
        if (eventMap.has(targetButton)) {
            return;
        }
        if (targetButton) {
            targetButton.addEventListener("click", onClickIssueReport);
            eventMap.set(targetButton, onClickIssueReport);
        }
    };
    window.addEventListener("DOMContentLoaded", function() {
        gitbook.events.on("page.change", function() {
            observeEvalEvent();
            observeIssueReport();
        });
    });

</script>
<meta name="google-site-verification" content="bMotEbgYwkzA3k4PkuyK_NUdz0bKh-Phz0oUwNmRSVo"/>
<style>
    /*
     * Disable antialias
     */
    * {
        -webkit-font-smoothing: initial !important
    }

    body {
        text-rendering: initial !important;
        font-smoothing: initial !important;
    }

    /* deny access chapter */
    .summary li.chapter > span {
        cursor: not-allowed;
        opacity: .3;
    }

    /* console ui */

    .mirror-console-attach-button-wrapper {
        margin-top: -1.275em;
        margin-bottom: 1.275em
    }

    .mirror-console-wrapper {
        margin-top: 1.275em;
        margin-bottom: 1.275em
    }

    /* file name for codeblock */
    .code-filename {
        background-color: #eee;
        display: inline-block;
        padding: 2px 8px;
        line-height: inherit;
        margin-bottom: 0px !important;
    }

    /* Markdown */
    /* Support horizon scroll */
    /* https://stackoverflow.com/questions/17770257/scrolling-tables-horizontally-without-wrapping-them-in-div */
    .markdown-section table {
        max-width: 100%;
        overflow-x: auto;
        display: block;
    }
    .markdown-section sup,
    .markdown-section sub {
        font-size: 75%;
    }

    .book_footer {
        text-align: center;
        color: #000000;
        background: #ddd;
        font-size: 16px;
        margin-top: 16px;
        padding: 16px;
    }

    /* github-issue-feedback */
    .gitbook-plugin-github-issue-feedback {
        background-color: #333;
        color: #fff;
        opacity: 0.8;
        padding: 4px;
        margin-right: 24px;
        margin-bottom: 4px;
        border-radius: 6px;
    }

    .gitbook-plugin-github-issue-feedback:hover {
        opacity: 1;
    }

    /* Hide footer on mobile */
    /* Use navigation width */
    @media (max-width: 1240px) {
        .book_footer {
            display: none;
        }
    }

    .navigation {
        min-width: 50px;
    }

    @media (min-width: 1240px) {
        .honkit-plugin-sandpack {
            width: calc(100% + 180px);
            margin: 0 0 1em -90px;
        }
    }

    .honkit-plugin-sandpack, .honkit-plugin-sandpack--buttonContainer {
        margin-bottom: 1em;
    }

</style>
<meta name="theme-color" content="#ffffff">
<link rel="manifest" href="../../manifest.json">
<script defer async>
    // unregister old service worker(remove workbox)
    // https://github.com/asciidwango/js-primer/pull/1701
    navigator.serviceWorker.getRegistrations().then(function(registrations) {
        for (const registration of registrations) {
            registration.unregister();
        }
    }).catch(function(err) {
        console.error(new Error("Can not getRegistrations", {
            cause: err
        }));
    });
</script>

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                    この書籍について
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../../intro/">
            
                <a href="../../intro/">
            
                    
                    はじめに
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../../intro/authors/">
            
                <a href="../../intro/authors/">
            
                    
                    著者紹介
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../../intro/sponsors/">
            
                <a href="../../intro/sponsors/">
            
                    
                    JavaScript Primerスポンサー
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../../intro/preparation/">
            
                <a href="../../intro/preparation/">
            
                    
                    読み始める前の事前準備
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="../../intro/feedback/">
            
                <a href="../../intro/feedback/">
            
                    
                    文章の間違いに気づいたら
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../">
            
                <a href="../">
            
                    
                    第一部: 基本文法
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../introduction/">
            
                <a href="../introduction/">
            
                    
                    JavaScriptとは
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../comments/">
            
                <a href="../comments/">
            
                    
                    コメント
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../variables/">
            
                <a href="../variables/">
            
                    
                    変数と宣言
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../read-eval-print/">
            
                <a href="../read-eval-print/">
            
                    
                    値の評価と表示
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="../data-type/">
            
                <a href="../data-type/">
            
                    
                    データ型とリテラル
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="../operator/">
            
                <a href="../operator/">
            
                    
                    演算子
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="../implicit-coercion/">
            
                <a href="../implicit-coercion/">
            
                    
                    暗黙的な型変換
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="../function-declaration/">
            
                <a href="../function-declaration/">
            
                    
                    関数と宣言
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.9" data-path="../statement-expression/">
            
                <a href="../statement-expression/">
            
                    
                    文と式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.10" data-path="../condition/">
            
                <a href="../condition/">
            
                    
                    条件分岐
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.11" data-path="../loop/">
            
                <a href="../loop/">
            
                    
                    ループと反復処理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.12" data-path="../object/">
            
                <a href="../object/">
            
                    
                    オブジェクト
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.13" data-path="../prototype-object/">
            
                <a href="../prototype-object/">
            
                    
                    プロトタイプオブジェクト
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.3.14" data-path="./">
            
                <a href="./">
            
                    
                    配列
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.15" data-path="../string/">
            
                <a href="../string/">
            
                    
                    文字列
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.16" data-path="../string-unicode/">
            
                <a href="../string-unicode/">
            
                    
                    文字列とUnicode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.17" data-path="../wrapper-object/">
            
                <a href="../wrapper-object/">
            
                    
                    ラッパーオブジェクト
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.18" data-path="../function-scope/">
            
                <a href="../function-scope/">
            
                    
                    関数とスコープ
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.19" data-path="../function-this/">
            
                <a href="../function-this/">
            
                    
                    関数とthis
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.20" data-path="../class/">
            
                <a href="../class/">
            
                    
                    クラス
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.21" data-path="../error-try-catch/">
            
                <a href="../error-try-catch/">
            
                    
                    例外処理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.22" data-path="../async/">
            
                <a href="../async/">
            
                    
                    非同期処理:Promise/Async Function
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.23" data-path="../map-and-set/">
            
                <a href="../map-and-set/">
            
                    
                    Map/Set
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.24" data-path="../json/">
            
                <a href="../json/">
            
                    
                    JSON
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.25" data-path="../date/">
            
                <a href="../date/">
            
                    
                    Date
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.26" data-path="../math/">
            
                <a href="../math/">
            
                    
                    Math
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.27" data-path="../module/">
            
                <a href="../module/">
            
                    
                    ECMAScriptモジュール
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.28" data-path="../ecmascript/">
            
                <a href="../ecmascript/">
            
                    
                    ECMAScript
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.29" data-path="../other-parts/">
            
                <a href="../other-parts/">
            
                    
                    第一部: おわりに
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../../use-case/">
            
                <a href="../../use-case/">
            
                    
                    第二部: 応用編（ユースケース）
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../../use-case/setup-local-env/">
            
                <a href="../../use-case/setup-local-env/">
            
                    
                    アプリケーション開発の準備
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../../use-case/ajaxapp/">
            
                <a href="../../use-case/ajaxapp/">
            
                    
                    Ajax通信
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.2.1" data-path="../../use-case/ajaxapp/entrypoint/">
            
                <a href="../../use-case/ajaxapp/entrypoint/">
            
                    
                    エントリーポイント
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.2" data-path="../../use-case/ajaxapp/http/">
            
                <a href="../../use-case/ajaxapp/http/">
            
                    
                    HTTP通信
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.3" data-path="../../use-case/ajaxapp/display/">
            
                <a href="../../use-case/ajaxapp/display/">
            
                    
                    データを表示する
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.4" data-path="../../use-case/ajaxapp/promise/">
            
                <a href="../../use-case/ajaxapp/promise/">
            
                    
                    Promiseを活用する
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../../use-case/nodecli/">
            
                <a href="../../use-case/nodecli/">
            
                    
                    Node.jsでCLIアプリ
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.3.1" data-path="../../use-case/nodecli/helloworld/">
            
                <a href="../../use-case/nodecli/helloworld/">
            
                    
                    Node.jsでHello World
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3.2" data-path="../../use-case/nodecli/argument-parse/">
            
                <a href="../../use-case/nodecli/argument-parse/">
            
                    
                    コマンドライン引数を処理する
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3.3" data-path="../../use-case/nodecli/read-file/">
            
                <a href="../../use-case/nodecli/read-file/">
            
                    
                    ファイルを読み込む
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3.4" data-path="../../use-case/nodecli/md-to-html/">
            
                <a href="../../use-case/nodecli/md-to-html/">
            
                    
                    MarkdownをHTMLに変換する
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3.5" data-path="../../use-case/nodecli/refactor-and-unittest/">
            
                <a href="../../use-case/nodecli/refactor-and-unittest/">
            
                    
                    ユニットテストを記述する
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="../../use-case/todoapp/">
            
                <a href="../../use-case/todoapp/">
            
                    
                    Todoアプリ
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.4.1" data-path="../../use-case/todoapp/entrypoint/">
            
                <a href="../../use-case/todoapp/entrypoint/">
            
                    
                    エントリーポイント
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.2" data-path="../../use-case/todoapp/app-structure/">
            
                <a href="../../use-case/todoapp/app-structure/">
            
                    
                    アプリの構成要素
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.3" data-path="../../use-case/todoapp/form-event/">
            
                <a href="../../use-case/todoapp/form-event/">
            
                    
                    Todoアイテムの追加を実装する
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.4" data-path="../../use-case/todoapp/event-model/">
            
                <a href="../../use-case/todoapp/event-model/">
            
                    
                    イベントとモデル
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.5" data-path="../../use-case/todoapp/update-delete/">
            
                <a href="../../use-case/todoapp/update-delete/">
            
                    
                    Todoアイテムの更新と削除を実装する
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.6" data-path="../../use-case/todoapp/final/">
            
                <a href="../../use-case/todoapp/final/">
            
                    
                    Todoアプリのリファクタリング
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../../appendix/links/">
            
                <a href="../../appendix/links/">
            
                    
                    付録: 参考リンク集
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../../cheatsheet/">
            
                <a href="../../cheatsheet/">
            
                    
                    付録: JavaScriptチートシート
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../../outro/">
            
                <a href="../../outro/">
            
                    
                    おわりに
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<!-- Header -->
<meta name="keywords" content="JavaScript,ECMAScript,JS,入門,チュートリアル,書籍,本,無料,Node.js,ブラウザ"/>
<link rel="author" href="https://www.hatena.ne.jp/efcl/"/>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css"/>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<!-- OGP -->
<meta property="og:title" content="JavaScript Primer - 迷わないための入門書"/>
<meta property="og:type" content="website"/>
<meta property="og:url" content="https://jsprimer.net/"/>
<meta property="og:image" content="https://jsprimer.net/landing/img/cover-optimized.jpg"/>
<meta property="og:site_name" content="JavaScript Primer"/>
<meta property="og:description" content="JavaScript Primerは、JavaScriptの基礎から応用までを一貫して学べる入門書です。"/>
<style>
    .book-header {
        display: flex;
        flex-direction: row;
        background-color: #333;
    }

    /* link color */
    .book-header a {
        color: #fff;
    }

    /* hover color */
    .book-header .btn:hover, .book-header .btn:focus, .book-header a:focus, .book-header a:hover {
        color: hsla(0, 0%, 100%, 0.75) !important;
    }

    /* Mobile header fixed */
    @media (max-width: 768px) {
        /* Headerを固定する */
        .book-header {
            position: fixed;
            width: 100%;
        }

        /* Icon only */
        .book-header-title-img {
            margin: auto 18px auto 0 !important;
        }

        .book-header-title-h {
            display: none;
        }

        /* Header分のズレを入れる */
        .page-wrapper {
            padding-top: 60px;
        }

        /* github-issue-feedbackを非表示にする */
        .gitbook-plugin-github-issue-feedback {
            display: none;
        }
    }

    /* Dynamic created by GitBook*/
    .btn.pull-left.js-toolbar-action {
        order: 1;
    }

    .book-header-title {
        order: 2;
        display: inline-flex;
        flex-direction: row;
        color: #fff;
    }

    .book-header-title:hover {
        color: hsla(0, 0%, 100%, 0.75);
    }

    .book-header-title-img {
        width: 32px;
        height: 32px;
        padding: 0;
        margin: auto 10px auto 0;
    }

    .book-header-title-h {
        font-size: 20px;
        margin: auto;
        padding: 0;
    }

    .header-center {
        order: 3;
        display: inline-flex;
        flex-direction: column;
        justify-content: center;
        /* self */
        flex-grow: 1;
        flex-shrink: 0;
        flex-basis: auto;
    }

    .header-right {
        order: 4;
        display: inline-flex;
        flex-direction: row;
        justify-content: center;
        align-items: center;
        /* icon size */
        font-size: 24px;
    }

    .amazon-link, .github-link {
        color: #fff;
        /* Padding and make Vertical */
        display: inline-flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding-left: 4px;
        padding-right: 4px;
    }

    /* Desktop */
    @media (min-width: 768px) {
        .header-center {
            align-items: center;
        }

        .header-right {
            margin-right: 24px;
        }
    }

    /* DocSearch */
    @media (max-width: 768px) {
        .algolia-autocomplete .ds-dropdown-menu {
            max-width: calc(100vw - 32px) !important;
            min-width: calc(100vw - 32px) !important;
            width: calc(100vw - 32px) !important;
            /* negative margin
              This is absolute element
              */
            margin-left: -32px !important;
        }

        .algolia-autocomplete .algolia-docsearch-suggestion--content {
            width: 100% !important;
            padding-left: 0 !important;
        }

        .algolia-autocomplete .algolia-docsearch-suggestion--content:before {
            display: none !important;
        }

        .algolia-autocomplete .algolia-docsearch-suggestion--subcategory-column {
            display: none !important;
        }

        .algolia-autocomplete.algolia-autocomplete-right .ds-dropdown-menu {
            right: inherit !important
        }

        .algolia-autocomplete.algolia-autocomplete-right .ds-dropdown-menu::before {
            right: 50%;
        }

        .sbx-custom {
            width: 92px !important;
            padding: initial !important;
        }

        .amazon-link {
            display: none;
        }
    }

    /* SearchBox */
    .searchbarWrapper {
        height: 50px;
    }


    .sbx-custom {
        display: inline-block;
        position: relative;
        min-width: 150px;
        width: 300px;
        max-width: 300px;
        height: 33px;
        white-space: nowrap;
        box-sizing: border-box;
        font-size: 14px;
    }

    .sbx-custom__wrapper {
        width: 100%;
        height: 100%;
    }

    .sbx-custom__input {
        display: inline-block;
        -webkit-transition: box-shadow .4s ease, background .4s ease;
        transition: box-shadow .4s ease, background .4s ease;
        border: 0;
        border-radius: 5px;
        box-shadow: inset 0 0 0 2px #CCCCCC;
        background: #FFFFFF;
        padding: 0 27px 0 33px;
        width: 100%;
        height: 100%;
        vertical-align: middle;
        white-space: normal;
        font-size: inherit;
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
    }

    .sbx-custom__input::-webkit-search-decoration, .sbx-custom__input::-webkit-search-cancel-button, .sbx-custom__input::-webkit-search-results-button, .sbx-custom__input::-webkit-search-results-decoration {
        display: none;
    }

    .sbx-custom__input:hover {
        box-shadow: inset 0 0 0 2px #b3b3b3;
    }

    .sbx-custom__input:focus, .sbx-custom__input:active {
        outline: 0;
        box-shadow: inset 0 0 0 2px #4B54DE;
        background: #FFFFFF;
    }

    .sbx-custom__input::-webkit-input-placeholder {
        color: #BBBBBB;
    }

    .sbx-custom__input::-moz-placeholder {
        color: #BBBBBB;
    }

    .sbx-custom__input:-ms-input-placeholder {
        color: #BBBBBB;
    }

    .sbx-custom__input::placeholder {
        color: #BBBBBB;
    }

    .sbx-custom__submit {
        position: absolute;
        top: 0;
        right: inherit;
        left: 0;
        margin: 0;
        border: 0;
        border-radius: 4px 0 0 4px;
        background-color: rgba(255, 255, 255, 0);
        padding: 0;
        width: 33px;
        height: 100%;
        vertical-align: middle;
        text-align: center;
        font-size: inherit;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }

    .sbx-custom__submit::before {
        display: inline-block;
        margin-right: -4px;
        height: 100%;
        vertical-align: middle;
        content: '';
    }

    .sbx-custom__submit:hover, .sbx-custom__submit:active {
        cursor: pointer;
    }

    .sbx-custom__submit:focus {
        outline: 0;
    }

    .sbx-custom__submit svg {
        width: 17px;
        height: 17px;
        vertical-align: middle;
        fill: #3A33D1;
    }

    .sbx-custom__reset {
        display: none;
        position: absolute;
        top: 4px;
        right: 4px;
        margin: 0;
        border: 0;
        background: none;
        cursor: pointer;
        padding: 0;
        font-size: inherit;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        fill: rgba(0, 0, 0, 0.5);
    }

    .sbx-custom__reset:focus {
        outline: 0;
    }

    .sbx-custom__reset svg {
        display: block;
        margin: 4px;
        width: 17px;
        height: 17px;
    }

    .sbx-custom__input:valid ~ .sbx-custom__reset {
        display: block;
        -webkit-animation-name: sbx-reset-in;
        animation-name: sbx-reset-in;
        -webkit-animation-duration: .15s;
        animation-duration: .15s;
    }

    @-webkit-keyframes sbx-reset-in {
        0% {
            -webkit-transform: translate3d(-20%, 0, 0);
            transform: translate3d(-20%, 0, 0);
            opacity: 0;
        }
        100% {
            -webkit-transform: none;
            transform: none;
            opacity: 1;
        }
    }

    @keyframes sbx-reset-in {
        0% {
            -webkit-transform: translate3d(-20%, 0, 0);
            transform: translate3d(-20%, 0, 0);
            opacity: 0;
        }
        100% {
            -webkit-transform: none;
            transform: none;
            opacity: 1;
        }
    }
</style>
<div class="book-header" role="navigation">
    
    <a class="book-header-title" href="../..">
        <img class="book-header-title-img" alt="JavaScript Primer"
             src="../../gitbook/icons/icon-128x128.png"/>
        <h2 class="book-header-title-h" title="JavaScript Primer - 迷わないための入門書">JavaScript Primer</h2>
    </a>
    <div class="searchbarWrapper header-center">
        <svg xmlns="http://www.w3.org/2000/svg" style="display:none">
            <symbol xmlns="http://www.w3.org/2000/svg" id="sbx-icon-search-8" viewBox="0 0 40 40">
                <path d="M16 32c8.835 0 16-7.165 16-16 0-8.837-7.165-16-16-16C7.162 0 0 7.163 0 16c0 8.835 7.163 16 16 16zm0-5.76c5.654 0 10.24-4.586 10.24-10.24 0-5.656-4.586-10.24-10.24-10.24-5.656 0-10.24 4.584-10.24 10.24 0 5.654 4.584 10.24 10.24 10.24zM28.156 32.8c-1.282-1.282-1.278-3.363.002-4.643 1.282-1.284 3.365-1.28 4.642-.003l6.238 6.238c1.282 1.282 1.278 3.363-.002 4.643-1.283 1.283-3.366 1.28-4.643.002l-6.238-6.238z"
                      fill-rule="evenodd"></path>
            </symbol>
            <symbol xmlns="http://www.w3.org/2000/svg" id="sbx-icon-clear-5" viewBox="0 0 20 20">
                <path d="M10 20c5.523 0 10-4.477 10-10S15.523 0 10 0 0 4.477 0 10s4.477 10 10 10zm1.35-10.123l3.567 3.568-1.225 1.226-3.57-3.568-3.567 3.57-1.226-1.227 3.568-3.568-3.57-3.57 1.227-1.224 3.568 3.568 3.57-3.567 1.224 1.225-3.568 3.57zM10 18.272c4.568 0 8.272-3.704 8.272-8.272S14.568 1.728 10 1.728 1.728 5.432 1.728 10 5.432 18.272 10 18.272z"
                      fill-rule="evenodd"></path>
            </symbol>
        </svg>

        <form novalidate="novalidate" onsubmit="return false;" class="searchbox sbx-custom">
            <div role="search" class="sbx-custom__wrapper">
                <input name="search" placeholder="Search words" autocomplete="off" required="required"
                       class="sbx-custom__input" type="search">
                <button type="submit" title="Submit your search query." class="sbx-custom__submit">
                    <svg role="img" aria-label="Search">
                        <use xlink:href="#sbx-icon-search-8"></use>
                    </svg>
                </button>
                <button type="reset" title="Clear the search query." class="sbx-custom__reset">
                    <svg role="img" aria-label="Reset">
                        <use xlink:href="#sbx-icon-clear-5"></use>
                    </svg>
                </button>
            </div>
        </form>
    </div>
    <div class="header-right">
        <!-- Icon: https://www.iconfinder.com/iconsets/circle-payment -->
        <a class="amazon-link" title="Amazon: JavaScript Primer 改訂2版 迷わないための入門書"
           href="https://www.amazon.co.jp/dp/4048931105/" target="_blank"><img
                width="22"
                height="22"
                style="margin: 1px;"
                src="../../gitbook/icons/amazon-icon.png" alt=""></a>
        <a class="github-link" title="GitHub: asciidwango/js-primer" href="https://github.com/asciidwango/js-primer"
           target="_blank"><i
                class="fa fa-github fa-fw"></i></a>
    </div>
</div>

<script defer>
    // focus on search box
    document.querySelector(".searchbox [type=\"reset\"]").addEventListener("click", function() {
        this.parentNode.querySelector("input").focus();
    });
    // init DocSearch
    var search = docsearch({
        apiKey: "fd28ebaba94be0c39fb9fa1b2fed4f23", // use a SEARCH-ONLY api key here
        indexName: "asciidwango",
        inputSelector: ".sbx-custom__input",
        debug: false // set to `true` if you want to inspect the dropdown menu's CSS
    });
</script>
<script>
    window.addEventListener("DOMContentLoaded", function() {
        gitbook.events.on("page.change", function() {
            setTimeout(() => console.clear(), 1000);
        });
    });
</script>





                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
<style>
    .page-sponsors {
        background: #fafafa;
    }
    .page-sponsors .page-sponsors-list {
        display: flex;
        justify-content: center;
        align-items: center;
        margin: 0;
        padding: 1em 0;
        list-style: none;
        gap: 8px;
    }
    .page-sponsors-footer {
        text-align: center;
        padding: 0;
        margin: 0;
    }
</style>
<div class="page-sponsors">

    <div class="page-sponsors-footer">
        JavaScript Primerの<a href="https://jsprimer.net/intro/sponsors/">スポンサーを募集中</a>
    </div>

</div>

                                <html><head></head><body><h1 id="array"><a name="array" class="plugin-anchor" href="#array"><i class="fa fa-link" aria-hidden="true"></i></a>配列 </h1>
<p>配列はJavaScriptの中でもよく使われるオブジェクトです。</p>
<p>配列とは値に順序をつけて格納できるオブジェクトです。
配列に格納したそれぞれの値のことを<strong>要素</strong>、それぞれの要素の位置のことを<strong>インデックス</strong>（<code>index</code>）と呼びます。
インデックスは先頭の要素から<code>0</code>、<code>1</code>、<code>2</code>のように<code>0</code>からはじまる連番となります。</p>
<p>またJavaScriptにおける配列は可変長です。
そのため配列を作成後に配列へ要素を追加したり、配列から要素を削除できます。</p>
<p>この章では、配列の基本的な操作と配列を扱う場合においてのパターンについて学びます。</p>
<h2 id="create-and-access"><a name="create-and-access" class="plugin-anchor" href="#create-and-access"><i class="fa fa-link" aria-hidden="true"></i></a>配列の作成とアクセス </h2>
<p>配列の作成と要素へのアクセス方法は「<a href="../data-type#array">データ型とリテラル</a>」の章ですでに紹介していますが、
もう一度振り返ってみましょう。</p>
<p>配列の作成には配列リテラルを使います。
配列リテラル（<code>[</code>と<code>]</code>）の中に要素をカンマ（<code>,</code>）区切りで記述するだけです。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> emptyArray = [];
<span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-comment">// 2次元配列（配列の配列）</span>
<span class="hljs-keyword">const</span> matrix = [
    [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>],
    [<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>]
];
</code></pre>
<p>作成した配列の要素のインデックスとなる数値を、<code>配列[インデックス]</code>と記述することで、
そのインデックスの要素を配列から読み取れます。
配列の先頭要素のインデックスは<code>0</code>となります。配列のインデックスは、<code>0</code>以上<code>2^32 - 1</code>未満の整数となります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array[<span class="hljs-number">0</span>]); <span class="hljs-comment">// =&gt; &quot;one&quot;</span>
</code></pre>
<p>2次元配列（配列の配列）からの値の読み取りも同様に<code>配列[インデックス]</code>でアクセスできます。
<code>配列[0][0]</code>は、配列の<code>0</code>番目の要素である配列（<code>[&quot;a&quot;, &quot;b&quot;]</code>）の<code>0</code>番目の要素を読み取ります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// 2次元配列（配列の配列）</span>
<span class="hljs-keyword">const</span> matrix = [
    [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>],
    [<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>]
];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]); <span class="hljs-comment">// =&gt; &quot;a&quot;</span>
</code></pre>
<p>配列の<code>length</code>プロパティは配列の要素の数を返します。
そのため、配列の最後の要素へアクセスするには <code>array.length - 1</code> をインデックスとして利用できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-property">length</span>); <span class="hljs-comment">// =&gt; 3</span>
<span class="hljs-comment">// 配列の要素数 - 1 が 最後の要素のインデックスとなる</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array[array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]); <span class="hljs-comment">// =&gt; &quot;three&quot;</span>
</code></pre>
<p>一方、存在しないインデックスにアクセスした場合はどうなるでしょうか？ JavaScriptでは、存在しないインデックスに対してアクセスした場合に、例外ではなく<code>undefined</code>を返します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>];
<span class="hljs-comment">// `array`にはインデックスが100の要素は定義されていない</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array[<span class="hljs-number">100</span>]); <span class="hljs-comment">// =&gt; undefined</span>
</code></pre>
<p>これは、配列がオブジェクトであることを考えると、次のように存在しないプロパティへアクセスしているのと原理は同じです。
オブジェクトでも、存在しないプロパティへアクセスした場合には<code>undefined</code>が返ってきます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> obj = {
    <span class="hljs-string">&quot;0&quot;</span>: <span class="hljs-string">&quot;one&quot;</span>,
    <span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-string">&quot;two&quot;</span>,
    <span class="hljs-string">&quot;2&quot;</span>: <span class="hljs-string">&quot;three&quot;</span>,
    <span class="hljs-string">&quot;length&quot;</span>: <span class="hljs-number">3</span>
};
<span class="hljs-comment">// obj[&quot;100&quot;]は定義されていないため、undefinedが返る</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[<span class="hljs-number">100</span>]); <span class="hljs-comment">// =&gt; undefined</span>
</code></pre>
<p>また、配列は常に<code>length</code>の数だけ要素を持っているとは限りません。
次のように、配列リテラルでは値を省略することで、未定義の要素を含めることができます。
このような、配列の中に隙間があるものを<strong>疎な配列</strong>と呼びます。
一方、隙間がなくすべてのインデックスに要素がある配列を<strong>密な配列</strong>と呼びます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// 未定義の箇所が1つ含まれる疎な配列</span>
<span class="hljs-comment">// インデックスが1の値を省略しているので、カンマが2つ続いていることに注意</span>
<span class="hljs-keyword">const</span> sparseArray = [<span class="hljs-number">1</span>, , <span class="hljs-number">3</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sparseArray.<span class="hljs-property">length</span>); <span class="hljs-comment">// =&gt; 3</span>
<span class="hljs-comment">// 1番目の要素は存在しないため undefined が返る</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sparseArray[<span class="hljs-number">1</span>]); <span class="hljs-comment">// =&gt; undefined</span>
</code></pre>
<h3 id="array-at"><a name="array-at" class="plugin-anchor" href="#array-at"><i class="fa fa-link" aria-hidden="true"></i></a>[ES2022] <code>Array.prototype.at</code> </h3>
<p>配列の要素にアクセスするには<code>配列[インデックス]</code>という構文を使うことを紹介しました。
その際に、配列の末尾の要素へアクセスするには、<code>array[array.length - 1]</code>という<code>length</code>プロパティを使う必要があります。
<code>array</code>を2回書く必要があるなど、末尾の要素へのアクセスは少し手間が必要になっていました。</p>
<p>この問題を解決するためES2022では、相対的なインデックスの値を指定して配列の要素へアクセスできる<code>Array.prototype.at</code>メソッドが追加されました。
Arrayの<code>at</code>メソッドは、<code>配列[インデックス]</code>とよく似ていますが、引数には相対的なインデックスの値を引数として渡せます。
<code>.at(0)</code>や<code>.at(1)</code>などのように0以上のインデックスを渡した場合は、<code>配列[インデックス]</code>と同じく指定した位置の要素へアクセスできます。
一方で、<code>.at(-1)</code>のようにマイナスのインデックスを渡した場合は、末尾から数えた位置の要素へアクセスできます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2022" } --></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>];
<span class="hljs-comment">//</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">at</span>(<span class="hljs-number">0</span>)); <span class="hljs-comment">// =&gt; &quot;a&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">at</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// =&gt; &quot;b&quot;</span>
<span class="hljs-comment">// 後ろから1つ目の要素にアクセス</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">at</span>(-<span class="hljs-number">1</span>)); <span class="hljs-comment">// =&gt; &quot;c&quot;</span>
<span class="hljs-comment">// -1は、次のように書いた場合と同じ結果</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array[array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]); <span class="hljs-comment">// =&gt; &quot;c&quot;</span>
</code></pre>
<p><code>配列[インデックス]</code>のインデックスに<code>-1</code>を指定すると、配列オブジェクトの<code>&quot;-1&quot;</code>というプロパティ名へのアクセスとなります。
そのため<code>配列[-1]</code>と書くと、大抵の場合は<code>undefined</code>が返されます。</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array[-<span class="hljs-number">1</span>]); <span class="hljs-comment">// =&gt; undefined</span>
</code></pre>
<h2 id="detect-array"><a name="detect-array" class="plugin-anchor" href="#detect-array"><i class="fa fa-link" aria-hidden="true"></i></a>オブジェクトが配列かどうかを判定する </h2>
<p>あるオブジェクトが配列かどうかを判定するには<code>Array.isArray</code>メソッドを利用します。
<code>Array.isArray</code>メソッドは引数が配列ならば<code>true</code>を返します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> obj = {};
<span class="hljs-keyword">const</span> array = [];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj)); <span class="hljs-comment">// =&gt; false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(array)); <span class="hljs-comment">// =&gt; true</span>
</code></pre>
<p>また、<code>typeof</code>演算子では配列かどうかを判定することはできません。
配列もオブジェクトの一種であるため、<code>typeof</code>演算子の結果が<code>&quot;object&quot;</code>となるためです。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> array); <span class="hljs-comment">// =&gt; &quot;object&quot;</span>
</code></pre>
<h3 id="typed-array"><a name="typed-array" class="plugin-anchor" href="#typed-array"><i class="fa fa-link" aria-hidden="true"></i></a>[コラム] [ES2015] TypedArray </h3>
<p>JavaScriptの配列は可変長のみですが、<code>TypedArray</code>という固定長でかつ型つきの配列を扱う別のオブジェクトが存在します。
<code>TypedArray</code>はバイナリデータのバッファを示すために使われるデータ型で、WebGLやバイナリを扱う場面で利用されます。
文字列や数値などのプリミティブ型の値を直接は利用できないため、通常の配列とは用途や使い勝手が異なります。</p>
<p>また、TypedArrayは<code>Array.isArray</code>のメソッドの結果が<code>false</code>となることからも別物と考えてよいでしょう。</p>
<pre><code class="lang-js"><span class="hljs-comment">// TypedArrayを作成</span>
<span class="hljs-keyword">const</span> typedArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Int8Array</span>(<span class="hljs-number">8</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(typedArray)); <span class="hljs-comment">// =&gt; false</span>
</code></pre>
<p>そのため、JavaScriptで配列といった場合には<code>Array</code>を示します。</p>
<h2 id="array-destructuring"><a name="array-destructuring" class="plugin-anchor" href="#array-destructuring"><i class="fa fa-link" aria-hidden="true"></i></a>[ES2015] 配列と分割代入 </h2>
<p>配列の指定したインデックスの値を変数として定義し直す場合には、分割代入（Destructuring assignment）が利用できます。</p>
<p>配列の分割代入では、左辺に配列リテラルのような構文で定義したい変数名を書きます。
右辺の配列から対応するインデックスの要素が、左辺で定義した変数に代入されます。</p>
<p>次のコードでは、左辺に定義した変数に対して、右辺の配列から対応するインデックスの要素が代入されます。
<code>first</code>にはインデックスが<code>0</code>の要素、<code>second</code>にはインデックスが<code>1</code>の要素、<code>third</code>にはインデックスが<code>2</code>の要素が代入されます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>];
<span class="hljs-keyword">const</span> [first, second, third] = array;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(first);  <span class="hljs-comment">// =&gt; &quot;one&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(second); <span class="hljs-comment">// =&gt; &quot;two&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(third);  <span class="hljs-comment">// =&gt; &quot;three&quot;</span>
</code></pre>
<h2 id="diff-undefined-and-no-element"><a name="diff-undefined-and-no-element" class="plugin-anchor" href="#diff-undefined-and-no-element"><i class="fa fa-link" aria-hidden="true"></i></a>[コラム] undefinedの要素と未定義の要素の違い </h2>
<p>疎な配列で該当するインデックスに要素がない場合は<code>undefined</code>を返します。
しかし、<code>undefined</code>という値も存在するため、配列に<code>undefined</code>という値がある場合に区別できません。</p>
<p>次のコードでは、<code>undefined</code>という値を要素として定義した密な配列と、要素そのものがない疎な配列を定義しています。
どちらも要素にアクセスした結果は<code>undefined</code>となり、区別できていないことがわかります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// 要素として`undefined`を持つ密な配列</span>
<span class="hljs-keyword">const</span> denseArray = [<span class="hljs-number">1</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-number">3</span>];
<span class="hljs-comment">// 要素そのものがない疎な配列</span>
<span class="hljs-keyword">const</span> sparseArray = [<span class="hljs-number">1</span>, , <span class="hljs-number">3</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(denseArray[<span class="hljs-number">1</span>]); <span class="hljs-comment">// =&gt; undefined</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sparseArray[<span class="hljs-number">1</span>]); <span class="hljs-comment">// =&gt; undefined</span>
</code></pre>
<p>この違いを見つける方法として利用できるのが、<code>Object.hasOwn</code>静的メソッドです。
<code>Object.hasOwn</code>静的メソッドを使うことで、配列オブジェクトに対して指定したインデックスに要素自体が存在するかを判定できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2022" } --></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> denseArray = [<span class="hljs-number">1</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">const</span> sparseArray = [<span class="hljs-number">1</span>, , <span class="hljs-number">3</span>];
<span class="hljs-comment">// 要素自体は存在し、その値が`undefined`</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(denseArray, <span class="hljs-number">1</span>)); <span class="hljs-comment">// =&gt; true</span>
<span class="hljs-comment">// 要素自体が存在しない</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(sparseArray, <span class="hljs-number">1</span>)); <span class="hljs-comment">// =&gt; false</span>
</code></pre>
<h2 id="search-element"><a name="search-element" class="plugin-anchor" href="#search-element"><i class="fa fa-link" aria-hidden="true"></i></a>配列から要素を検索 </h2>
<p>配列から指定した要素を検索する目的には、
主に次の3つがあります。</p>
<ul>
<li>その要素のインデックスが欲しい場合</li>
<li>その要素自体が欲しい場合</li>
<li>その要素が含まれているかという真偽値が欲しい場合</li>
</ul>
<p>配列にはそれぞれに対応したメソッドが用意されているため、目的別に見ていきます。</p>
<h3 id="indexof"><a name="indexof" class="plugin-anchor" href="#indexof"><i class="fa fa-link" aria-hidden="true"></i></a>インデックスを取得 </h3>
<p>指定した要素が配列のどの位置にあるかを知りたい場合、Arrayの<code>indexOf</code>メソッドや<code>findIndex</code>メソッド<sup>[ES2015]</sup>を利用します。
要素の位置のことを<strong>インデックス</strong>（<code>index</code>）と呼ぶため、メソッド名にも<code>index</code>という名前が入っています。</p>
<p>次のコードでは、Arrayの<code>indexOf</code>メソッドを利用して、配列の中から<code>&quot;JavaScript&quot;</code>という文字列のインデックスを取得しています。
<code>indexOf</code>メソッドは引数と厳密等価演算子（<code>===</code>）で一致する要素を先頭から検索して該当する要素のインデックスを返し、該当する要素がない場合は<code>-1</code>を返します。
<code>indexOf</code>メソッドには対となる<code>lastIndexOf</code>メソッドがあり、<code>lastIndexOf</code>メソッドでは末尾から検索した結果が得られます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;JavaScript&quot;</span>, <span class="hljs-string">&quot;Ruby&quot;</span>, <span class="hljs-string">&quot;JavaScript&quot;</span>];
<span class="hljs-comment">// 先頭から探索して最初に見つかった&quot;JavaScript&quot;のインデックスを取得</span>
<span class="hljs-keyword">const</span> indexOfJS = array.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;JavaScript&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(indexOfJS); <span class="hljs-comment">// =&gt; 1</span>
<span class="hljs-comment">// 末尾から探索して最初に見つかった&quot;JavaScript&quot;のインデックスを取得</span>
<span class="hljs-keyword">const</span> lastIndexOfJS = array.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&quot;JavaScript&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(lastIndexOfJS); <span class="hljs-comment">// =&gt; 3</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array[indexOfJS]); <span class="hljs-comment">// =&gt; &quot;JavaScript&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array[lastIndexOfJS]); <span class="hljs-comment">// =&gt; &quot;JavaScript&quot;</span>
<span class="hljs-comment">// &quot;JS&quot; という要素はないため `-1` が返される</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;JS&quot;</span>)); <span class="hljs-comment">// =&gt; -1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&quot;JS&quot;</span>)); <span class="hljs-comment">// =&gt; -1</span>
</code></pre>
<p><code>indexOf</code>メソッドは配列からプリミティブな要素を発見できますが、オブジェクトは持っているプロパティが同じでも別オブジェクトだと異なるものとして扱われます。
次のコードを見ると、同じプロパティを持つ異なるオブジェクトは、<code>indexOf</code>メソッドでは見つけることができません。
これは、異なる参照を持つオブジェクト同士は<code>===</code>で比較しても一致しないためです。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;value&quot;</span> };
<span class="hljs-keyword">const</span> array = [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, obj];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">indexOf</span>({ <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;value&quot;</span> })); <span class="hljs-comment">// =&gt; -1</span>
<span class="hljs-comment">// リテラルは新しいオブジェクトを作るため、異なるオブジェクトだと判定される</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj === { <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;value&quot;</span> }); <span class="hljs-comment">// =&gt; false</span>
<span class="hljs-comment">// 等価のオブジェクトを検索してインデックスを返す</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">indexOf</span>(obj)); <span class="hljs-comment">// =&gt; 2</span>
</code></pre>
<p>このように、異なるオブジェクトだが値は同じものを見つけたい場合には、Arrayの<code>findIndex</code>メソッドが利用できます。
<code>findIndex</code>メソッドの引数には配列の各要素をテストする関数をコールバック関数として渡します。
<code>indexOf</code>メソッドとは異なり、テストする処理を自由に書けます。
これにより、プロパティの値が同じ要素を配列から見つけて、その要素のインデックスを得ることができます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// colorプロパティを持つオブジェクトの配列</span>
<span class="hljs-keyword">const</span> colors = [
    { <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;red&quot;</span> },
    { <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;green&quot;</span> },
    { <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;blue&quot;</span> }
];
<span class="hljs-comment">// `color`プロパティが&quot;blue&quot;のオブジェクトのインデックスを取得</span>
<span class="hljs-keyword">const</span> indexOfBlue = colors.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> obj.<span class="hljs-property">color</span> === <span class="hljs-string">&quot;blue&quot;</span>;
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(indexOfBlue); <span class="hljs-comment">// =&gt; 2</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(colors[indexOfBlue]); <span class="hljs-comment">// =&gt; { &quot;color&quot;: &quot;blue&quot; }</span>
</code></pre>
<p>Arrayの<code>findIndex</code>メソッドにも対となる<code>findLastIndex</code>メソッド<sup>[ES2023]</sup>があり、<code>findLastIndex</code>メソッドは末尾から検索した結果が得られます。
次のように、<code>findIndex</code>は条件に一致する最初の要素のインデックスを返しますが、<code>findLastIndex</code>は最後の要素のインデックスを返します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2023" } --></p>
<pre><code class="lang-js"><span class="hljs-comment">// dateとcountプロパティを持つオブジェクトの配列</span>
<span class="hljs-keyword">const</span> records = [
    { <span class="hljs-attr">date</span>: <span class="hljs-string">&quot;2020/12/1&quot;</span>, <span class="hljs-attr">count</span>: <span class="hljs-number">5</span> },
    { <span class="hljs-attr">date</span>: <span class="hljs-string">&quot;2020/12/2&quot;</span>, <span class="hljs-attr">count</span>: <span class="hljs-number">11</span> },
    { <span class="hljs-attr">date</span>: <span class="hljs-string">&quot;2020/12/3&quot;</span>, <span class="hljs-attr">count</span>: <span class="hljs-number">9</span> },
    { <span class="hljs-attr">date</span>: <span class="hljs-string">&quot;2020/12/4&quot;</span>, <span class="hljs-attr">count</span>: <span class="hljs-number">12</span> },
    { <span class="hljs-attr">date</span>: <span class="hljs-string">&quot;2020/12/5&quot;</span>, <span class="hljs-attr">count</span>: <span class="hljs-number">3</span> }
];
<span class="hljs-comment">// 10より大きい`count`プロパティを持つ最初のオブジェクトのインデックスを取得</span>
<span class="hljs-keyword">const</span> firstRecordIndex = records.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function">(<span class="hljs-params">record</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> record.<span class="hljs-property">count</span> &gt; <span class="hljs-number">10</span>;
});
<span class="hljs-comment">// 10より大きい`count`プロパティを持つ最後のオブジェクトのインデックスを取得</span>
<span class="hljs-keyword">const</span> lastRecordIndex = records.<span class="hljs-title function_">findLastIndex</span>(<span class="hljs-function">(<span class="hljs-params">record</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> record.<span class="hljs-property">count</span> &gt; <span class="hljs-number">10</span>;
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(firstRecordIndex); <span class="hljs-comment">// =&gt; 1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(records[firstRecordIndex]); <span class="hljs-comment">// =&gt; { date: &quot;2020/12/2&quot;, count: 11 }</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(lastRecordIndex); <span class="hljs-comment">// =&gt; 3</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(records[lastRecordIndex]); <span class="hljs-comment">// =&gt; { date: &quot;2020/12/4&quot;, count: 12 }</span>
</code></pre>
<h3 id="find"><a name="find" class="plugin-anchor" href="#find"><i class="fa fa-link" aria-hidden="true"></i></a>条件に一致する要素を取得 </h3>
<p>配列から要素を取得する方法としてインデックスを使うこともできます。
先ほどのように<code>findIndex</code>メソッドでインデックスを取得し、そのインデックスで配列へアクセスすればよいだけです。</p>
<p>しかし、<code>findIndex</code>メソッドを使って要素を取得するケースでは、
そのインデックスが欲しいのか、またはその要素自体が欲しいのかがコードとして明確ではありません。</p>
<p>より明確に要素自体が欲しいということを表現するには、Arrayの<code>find</code>メソッド<sup>[ES2015]</sup>が使えます。
<code>find</code>メソッドには、<code>findIndex</code>メソッドと同様にテストする関数をコールバック関数として渡します。
<code>find</code>メソッドの返り値は、要素そのものとなり、要素が存在しない場合は<code>undefined</code>を返します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// colorプロパティを持つオブジェクトの配列</span>
<span class="hljs-keyword">const</span> colors = [
    { <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;red&quot;</span> },
    { <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;green&quot;</span> },
    { <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;blue&quot;</span> }
];
<span class="hljs-comment">// `color`プロパティが&quot;blue&quot;のオブジェクトを取得</span>
<span class="hljs-keyword">const</span> blueColor = colors.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> obj.<span class="hljs-property">color</span> === <span class="hljs-string">&quot;blue&quot;</span>;
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(blueColor); <span class="hljs-comment">// =&gt; { &quot;color&quot;: &quot;blue&quot; }</span>
<span class="hljs-comment">// 該当する要素がない場合は`undefined`を返す</span>
<span class="hljs-keyword">const</span> whiteColor = colors.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> obj.<span class="hljs-property">color</span> === <span class="hljs-string">&quot;white&quot;</span>;
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(whiteColor); <span class="hljs-comment">// =&gt; undefined</span>
</code></pre>
<p><code>find</code>メソッドにも対となる<code>findLast</code>メソッド<sup>[ES2023]</sup>があり、<code>findLast</code>メソッドは末尾から検索した結果が得られます。
次のように、<code>find</code>は条件に一致した最初の要素を返しますが、<code>findLast</code>は最後の要素を返します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2023" } --></p>
<pre><code class="lang-js"><span class="hljs-comment">// dateとcountプロパティを持つオブジェクトの配列</span>
<span class="hljs-keyword">const</span> records = [
    { <span class="hljs-attr">date</span>: <span class="hljs-string">&quot;2020/12/1&quot;</span>, <span class="hljs-attr">count</span>: <span class="hljs-number">5</span> },
    { <span class="hljs-attr">date</span>: <span class="hljs-string">&quot;2020/12/2&quot;</span>, <span class="hljs-attr">count</span>: <span class="hljs-number">11</span> },
    { <span class="hljs-attr">date</span>: <span class="hljs-string">&quot;2020/12/3&quot;</span>, <span class="hljs-attr">count</span>: <span class="hljs-number">9</span> },
    { <span class="hljs-attr">date</span>: <span class="hljs-string">&quot;2020/12/4&quot;</span>, <span class="hljs-attr">count</span>: <span class="hljs-number">12</span> },
    { <span class="hljs-attr">date</span>: <span class="hljs-string">&quot;2020/12/5&quot;</span>, <span class="hljs-attr">count</span>: <span class="hljs-number">3</span> }
];
<span class="hljs-comment">// 10より大きい`count`プロパティを持つ最初のオブジェクトを取得</span>
<span class="hljs-keyword">const</span> firstRecord = records.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">record</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> record.<span class="hljs-property">count</span> &gt; <span class="hljs-number">10</span>;
});
<span class="hljs-comment">// 10より大きい`count`プロパティを持つ最後のオブジェクトを取得</span>
<span class="hljs-keyword">const</span> lastRecord = records.<span class="hljs-title function_">findLast</span>(<span class="hljs-function">(<span class="hljs-params">record</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> record.<span class="hljs-property">count</span> &gt; <span class="hljs-number">10</span>;
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(firstRecord); <span class="hljs-comment">// =&gt; { date: &quot;2020/12/2&quot;, count: 11 }</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(lastRecord); <span class="hljs-comment">// =&gt; { date: &quot;2020/12/4&quot;, count: 12 }</span>
</code></pre>
<h3 id="slice"><a name="slice" class="plugin-anchor" href="#slice"><i class="fa fa-link" aria-hidden="true"></i></a>指定範囲の要素を取得 </h3>
<p>配列から指定範囲の要素を取り出す方法としてArrayの<code>slice</code>メソッドが利用できます。
<code>slice</code>メソッドは、第一引数の開始位置から第二引数の終了位置（終了位置の要素は含まない）までの範囲を取り出した新しい配列を返します。
第二引数は省略でき、省略した場合は配列の末尾の要素まで含んだ新しい配列を返します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>];
<span class="hljs-comment">// インデックス1から4まで(4の要素は含まない)の範囲を取り出す</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// =&gt; [&quot;B&quot;, &quot;C&quot;, &quot;D&quot;]</span>
<span class="hljs-comment">// 第二引数を省略した場合は、第一引数から末尾の要素までを取り出す</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// =&gt; [&quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;]</span>
<span class="hljs-comment">// マイナスを指定すると後ろから数えた位置となる</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">slice</span>(-<span class="hljs-number">1</span>)); <span class="hljs-comment">// =&gt; [&quot;E&quot;]</span>
<span class="hljs-comment">// 第一引数と第二引数が同じ場合は、空の配列を返す</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)); <span class="hljs-comment">// =&gt; []</span>
<span class="hljs-comment">// 第一引数 &gt; 第二引数の場合、常に空配列を返す</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">slice</span>(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>)); <span class="hljs-comment">// =&gt; []</span>
</code></pre>
<p><code>slice</code>メソッドと引数の関係を図にすると次のようになります。</p>
<pre><code> +-----+-----+-----+-----+-----+
 | &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; |
 +-----+-----+-----+-----+-----+
 0     1     2     3     4     5
-5    -4    -3    -2    -1
</code></pre><h3 id="get-boolean"><a name="get-boolean" class="plugin-anchor" href="#get-boolean"><i class="fa fa-link" aria-hidden="true"></i></a>真偽値を取得 </h3>
<p>最後に、指定した要素が配列に含まれているかを知る方法について見ていきます。
インデックスや要素が取得できれば、その要素は配列に含まれているということはわかります。</p>
<p>しかし、指定した要素が含まれているか<strong>だけ</strong>を知りたい場合に、
Arrayの<code>findIndex</code>メソッドや<code>find</code>メソッドは過剰な機能を持っています。
そのコードを読んだ人には、取得したインデックスや要素を何に使うのかが明確ではありません。</p>
<p>次のコードは、Arrayの<code>indexOf</code>メソッドを利用し、該当する要素が含まれているかを判定しています。
<code>indexOf</code>メソッドの結果を<code>indexOfJS</code>に代入していますが、含まれているかを判定する以外には利用していません。
コードを隅々まで読まないといけないため、意図が明確ではなくコードの読みづらさにつながります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;JavaScript&quot;</span>, <span class="hljs-string">&quot;Ruby&quot;</span>];
<span class="hljs-comment">// `indexOf`メソッドは含まれていないときのみ`-1`を返すことを利用</span>
<span class="hljs-keyword">const</span> indexOfJS = array.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;JavaScript&quot;</span>);
<span class="hljs-keyword">if</span> (indexOfJS !== -<span class="hljs-number">1</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;配列にJavaScriptが含まれている&quot;</span>);
    <span class="hljs-comment">// ... いろいろな処理 ...</span>
    <span class="hljs-comment">// `indexOfJS`は、含まれているのかの判定以外には利用してない</span>
}
</code></pre>
<p>そこで、ES2016で導入されたArrayの<code>includes</code>メソッド<sup>[ES2016]</sup>を利用します。
Arrayの<code>includes</code>メソッドは配列に指定要素が含まれているかを判定します。
<code>includes</code>メソッドは真偽値を返すので、<code>indexOf</code>メソッドを使った場合に比べて意図が明確になります。
前述のコードでは次のように<code>includes</code>メソッドを使うべきでしょう。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;JavaScript&quot;</span>, <span class="hljs-string">&quot;Ruby&quot;</span>];
<span class="hljs-comment">// `includes`は含まれているなら`true`を返す</span>
<span class="hljs-keyword">if</span> (array.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;JavaScript&quot;</span>)) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;配列にJavaScriptが含まれている&quot;</span>);
}
</code></pre>
<p><code>includes</code>メソッドは、<code>indexOf</code>メソッドと同様、異なるオブジェクトだが値が同じものを見つけたい場合には利用できません。
Arrayの<code>find</code>メソッドのようにテストするコールバック関数を利用して真偽値を得るには、Arrayの<code>some</code>メソッドを利用できます。</p>
<p>Arrayの<code>some</code>メソッドはテストするコールバック関数にマッチする要素があるなら<code>true</code>を返し、存在しない場合は<code>false</code>を返します
（「<a href="../loop/#array-some">ループと反復処理</a>」の章を参照）。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// colorプロパティを持つオブジェクトの配列</span>
<span class="hljs-keyword">const</span> colors = [
    { <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;red&quot;</span> },
    { <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;green&quot;</span> },
    { <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;blue&quot;</span> }
];
<span class="hljs-comment">// `color`プロパティが&quot;blue&quot;のオブジェクトがあるかどうか</span>
<span class="hljs-keyword">const</span> isIncludedBlueColor = colors.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> obj.<span class="hljs-property">color</span> === <span class="hljs-string">&quot;blue&quot;</span>;
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(isIncludedBlueColor); <span class="hljs-comment">// =&gt; true</span>
</code></pre>
<h2 id="add-and-delete"><a name="add-and-delete" class="plugin-anchor" href="#add-and-delete"><i class="fa fa-link" aria-hidden="true"></i></a>追加と削除 </h2>
<p>配列は可変長であるため、作成後の配列に対して要素を追加、削除できます。</p>
<p>要素を配列の末尾へ追加するにはArrayの<code>push</code>が利用できます。
一方、末尾から要素を削除するにはArrayの<code>pop</code>が利用できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>];
array.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;D&quot;</span>); <span class="hljs-comment">// &quot;D&quot;を末尾に追加</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array); <span class="hljs-comment">// =&gt; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]</span>
<span class="hljs-keyword">const</span> poppedItem = array.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 最末尾の要素を削除し、その要素を返す</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(poppedItem); <span class="hljs-comment">// =&gt; &quot;D&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array); <span class="hljs-comment">// =&gt; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</span>
</code></pre>
<p>要素を配列の先頭へ追加するにはArrayの<code>unshift</code>が利用できます。
一方、配列の先頭から要素を削除するにはArrayの<code>shift</code>が利用できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>];
array.<span class="hljs-title function_">unshift</span>(<span class="hljs-string">&quot;S&quot;</span>); <span class="hljs-comment">// &quot;S&quot;を先頭に追加</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array); <span class="hljs-comment">// =&gt; [&quot;S&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</span>
<span class="hljs-keyword">const</span> shiftedItem = array.<span class="hljs-title function_">shift</span>(); <span class="hljs-comment">// 先頭の要素を削除</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(shiftedItem); <span class="hljs-comment">// =&gt; &quot;S&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array); <span class="hljs-comment">// =&gt; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</span>
</code></pre>
<h2 id="concat"><a name="concat" class="plugin-anchor" href="#concat"><i class="fa fa-link" aria-hidden="true"></i></a>配列同士を結合 </h2>
<p>Arrayの<code>concat</code>メソッドを使うことで配列と配列を結合した新しい配列を作成できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>];
<span class="hljs-keyword">const</span> newArray = array.<span class="hljs-title function_">concat</span>([<span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>]);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArray); <span class="hljs-comment">// =&gt; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;]</span>
</code></pre>
<p>また、<code>concat</code>メソッドは配列だけではなく任意の値を要素として結合できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>];
<span class="hljs-keyword">const</span> newArray = array.<span class="hljs-title function_">concat</span>(<span class="hljs-string">&quot;新しい要素&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArray); <span class="hljs-comment">// =&gt; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;新しい要素&quot;]</span>
</code></pre>
<h2 id="spread"><a name="spread" class="plugin-anchor" href="#spread"><i class="fa fa-link" aria-hidden="true"></i></a>[ES2015] 配列の展開 </h2>
<p><code>...</code>（Spread構文）を使うことで、配列リテラル中に既存の配列を展開できます。</p>
<p>次のコードでは、配列リテラルの末尾に配列を展開しています。
これは、Arrayの<code>concat</code>メソッドで配列同士を結合するのと同じ結果になります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>];
<span class="hljs-comment">// Spread構文を使った場合</span>
<span class="hljs-keyword">const</span> newArray = [<span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;Y&quot;</span>, <span class="hljs-string">&quot;Z&quot;</span>, ...array];
<span class="hljs-comment">// concatメソッドの場合</span>
<span class="hljs-keyword">const</span> newArrayConcat = [<span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;Y&quot;</span>, <span class="hljs-string">&quot;Z&quot;</span>].<span class="hljs-title function_">concat</span>(array);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArray); <span class="hljs-comment">// =&gt; [&quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArrayConcat); <span class="hljs-comment">// =&gt; [&quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</span>
</code></pre>
<p>Spread構文は、<code>concat</code>メソッドとは異なり、配列リテラル中の任意の位置に配列を展開できます。
そのため、次のように要素の途中に配列を展開できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>];
<span class="hljs-keyword">const</span> newArray = [<span class="hljs-string">&quot;X&quot;</span>, ...array, <span class="hljs-string">&quot;Z&quot;</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArray); <span class="hljs-comment">// =&gt; [&quot;X&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;Z&quot;]</span>
</code></pre>
<h2 id="flat"><a name="flat" class="plugin-anchor" href="#flat"><i class="fa fa-link" aria-hidden="true"></i></a>[ES2019] 配列をフラット化 </h2>
<p>Arrayの<code>flat</code>メソッド<sup>[ES2019]</sup>を使うことで、多次元配列をフラットな配列に変換できます。
引数を指定しなかった場合は1段階のみのフラット化ですが、引数に渡す数値でフラット化する深さを指定できます。
配列をすべてフラット化する場合には、無限を意味する<code>Infinity</code>を値として渡すことで実現できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2019" } --></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [[[<span class="hljs-string">&quot;A&quot;</span>], <span class="hljs-string">&quot;B&quot;</span>], <span class="hljs-string">&quot;C&quot;</span>];
<span class="hljs-comment">// 引数なしは1を指定した場合と同じ</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">flat</span>()); <span class="hljs-comment">// =&gt; [[&quot;A&quot;], &quot;B&quot;, &quot;C&quot;]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">flat</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// =&gt; [[&quot;A&quot;], &quot;B&quot;, &quot;C&quot;]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">flat</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// =&gt; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</span>
<span class="hljs-comment">// すべてをフラット化するにはInfinityを渡す</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">flat</span>(<span class="hljs-title class_">Infinity</span>)); <span class="hljs-comment">// =&gt; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</span>
</code></pre>
<p>また、Arrayの<code>flat</code>メソッドは必ず新しい配列を作成して返すメソッドです。
そのため、これ以上フラット化できない配列をフラット化しても、同じ要素を持つ新しい配列を返します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2019" } --></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">flat</span>()); <span class="hljs-comment">// =&gt; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</span>
</code></pre>
<h2 id="delete-element"><a name="delete-element" class="plugin-anchor" href="#delete-element"><i class="fa fa-link" aria-hidden="true"></i></a>配列から要素を削除 </h2>
<h3 id="splice"><a name="splice" class="plugin-anchor" href="#splice"><i class="fa fa-link" aria-hidden="true"></i></a><code>Array.prototype.splice</code> </h3>
<p>配列の先頭や末尾の要素を削除する場合はArrayの<code>shift</code>メソッドや<code>pop</code>メソッドで行えます。
しかし、配列の任意のインデックスの要素を削除できません。
配列の任意のインデックスの要素を削除するにはArrayの<code>splice</code>メソッドを利用できます。</p>
<p><code>splice</code>メソッドを利用すると、削除した要素を自動で詰めることができます。
<code>splice</code>メソッドは指定したインデックスから、指定した数だけ要素を取り除き、必要ならば要素を同時に追加できます。</p>
<!-- doctest: ReferenceError -->
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [];
array.<span class="hljs-title function_">splice</span>(インデックス, 削除する要素数);
<span class="hljs-comment">// 削除と同時に要素の追加もできる</span>
array.<span class="hljs-title function_">splice</span>(インデックス, 削除する要素数, ...追加する要素);
</code></pre>
<p>たとえば、配列のインデックスが<code>1</code>の要素を削除するには、インデックス<code>1</code>から<code>1</code>つの要素を削除するという指定をする必要があります。
このとき、削除した要素は自動で詰められるため、疎な配列にはなりません。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>];
<span class="hljs-comment">// 1番目から1つの要素(&quot;b&quot;)を削除</span>
array.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array); <span class="hljs-comment">// =&gt; [&quot;a&quot;, &quot;c&quot;]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-property">length</span>); <span class="hljs-comment">// =&gt; 2</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array[<span class="hljs-number">1</span>]); <span class="hljs-comment">// =&gt; &quot;c&quot;</span>
<span class="hljs-comment">// すべて削除</span>
array.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, array.<span class="hljs-property">length</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-property">length</span>); <span class="hljs-comment">// =&gt; 0</span>
</code></pre>
<h3 id="assign-to-length"><a name="assign-to-length" class="plugin-anchor" href="#assign-to-length"><i class="fa fa-link" aria-hidden="true"></i></a><code>length</code>プロパティへの代入 </h3>
<p>配列のすべての要素を削除することはArrayの<code>splice</code>で行えますが、
配列の<code>length</code>プロパティへの代入を利用した方法もあります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
array.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">// 配列を空にする</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array); <span class="hljs-comment">// =&gt; []</span>
</code></pre>
<p>配列の<code>length</code>プロパティへ<code>要素数</code>を代入すると、その要素数に配列が切り詰められます。
つまり、<code>length</code>プロパティへ<code>0</code>を代入すると、インデックスが<code>0</code>以降の要素がすべて削除されます。</p>
<h3 id="assign-empty-array"><a name="assign-empty-array" class="plugin-anchor" href="#assign-empty-array"><i class="fa fa-link" aria-hidden="true"></i></a>空の配列を代入 </h3>
<p>最後に、その配列の要素を削除するのではなく、新しい空の配列を変数へ代入する方法です。
次のコードでは、<code>array</code>変数に空の配列を代入することで、<code>array</code>に空の配列を参照させられます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">let</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-property">length</span>); <span class="hljs-comment">// =&gt; 3</span>
<span class="hljs-comment">// 新しい配列で変数を上書き</span>
array = [];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-property">length</span>); <span class="hljs-comment">// =&gt; 0</span>
</code></pre>
<p>元々、<code>array</code>変数が参照していた<code>[1, 2, 3]</code>はどこからも参照されなくなり、ガベージコレクションによりメモリから解放されます。</p>
<p>また、<code>const</code>で宣言した配列の場合は変数に対して再代入できないため、この手法は使えません。
そのため、再代入をしたい場合は<code>let</code>または<code>var</code>で変数宣言をする必要があります。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-property">length</span>); <span class="hljs-comment">// =&gt; 3</span>
<span class="hljs-comment">// `const`で宣言された変数には再代入できない</span>
array = []; <span class="hljs-comment">// TypeError: invalid assignment to const `array&apos; が発生</span>
</code></pre>
<h2 id="mutable-immutable"><a name="mutable-immutable" class="plugin-anchor" href="#mutable-immutable"><i class="fa fa-link" aria-hidden="true"></i></a>破壊的なメソッドと非破壊的なメソッド </h2>
<p>これまで紹介してきた配列を変更するメソッドには、破壊的なメソッドと非破壊的メソッドがあります。
この破壊的なメソッドと非破壊的メソッドの違いを知ることは、意図しない結果を避けるために重要です。</p>
<p>破壊的なメソッド（Mutable Method）とは、配列オブジェクトそのものを変更し、変更した配列または変更箇所を返すメソッドです。
非破壊的メソッド（Immutable Method）とは、配列オブジェクトのコピーを作成してから変更し、そのコピーした配列を返すメソッドです。</p>
<!-- 具体例:破壊的なメソッド -->
<p>破壊的なメソッドの例として、配列に要素を追加するArrayの<code>push</code>メソッドがあります。
<code>push</code>メソッドは、<code>myArray</code>の配列そのものへ要素を追加しています。
その結果<code>myArray</code>変数の参照する配列が変更されるため破壊的なメソッドです。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> myArray = [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>];
<span class="hljs-keyword">const</span> result = myArray.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;D&quot;</span>);
<span class="hljs-comment">// `push`の返り値は配列ではなく、追加後の配列のlength</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// =&gt; 4</span>
<span class="hljs-comment">// `myArray`が参照する配列そのものが変更されている</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myArray); <span class="hljs-comment">// =&gt; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]</span>
</code></pre>
<!-- 具体例:非破壊的メソッド -->
<p>非破壊的なメソッドの例として、配列に要素を結合するArrayの<code>concat</code>メソッドがあります。
<code>concat</code>メソッドは、<code>myArray</code>をコピーした配列に対して要素を結合し、その配列を返します。
<code>myArray</code>変数の参照する配列は変更されないため非破壊的なメソッドです。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> myArray = [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>];
<span class="hljs-comment">// `concat`の返り値は結合済みの新しい配列</span>
<span class="hljs-keyword">const</span> newArray = myArray.<span class="hljs-title function_">concat</span>(<span class="hljs-string">&quot;D&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArray); <span class="hljs-comment">// =&gt; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]</span>
<span class="hljs-comment">// `myArray`は変更されていない</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myArray); <span class="hljs-comment">// =&gt; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</span>
<span class="hljs-comment">// `newArray`と`myArray`は異なる配列オブジェクト</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myArray === newArray); <span class="hljs-comment">// =&gt; false</span>
</code></pre>
<p>JavaScriptにおいて破壊的なメソッドと非破壊的メソッドを名前から見分けるのは難しいという問題があります。
また、配列を返す破壊的なメソッドもあるため、返り値からも判別できません。
たとえば、Arrayの<code>sort</code>メソッドは返り値がソート済みの配列ですが破壊的メソッドです。</p>
<p>次の表で紹介するメソッドは破壊的なメソッドです。</p>
<table>
<thead>
<tr>
<th>メソッド名</th>
<th>返り値</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" target="_blank"><code>Array.prototype.pop</code></a></td>
<td>配列の末尾の値</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/push" target="_blank"><code>Array.prototype.push</code></a></td>
<td>変更後の配列のlength</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" target="_blank"><code>Array.prototype.splice</code></a></td>
<td>取り除かれた要素を含む配列</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse" target="_blank"><code>Array.prototype.reverse</code></a></td>
<td>反転した配列</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/shift" target="_blank"><code>Array.prototype.shift</code></a></td>
<td>配列の先頭の値</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" target="_blank"><code>Array.prototype.sort</code></a></td>
<td>ソートした配列</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift" target="_blank"><code>Array.prototype.unshift</code></a></td>
<td>変更後の配列のlength</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin" target="_blank"><code>Array.prototype.copyWithin</code></a><sup>[ES2015]</sup></td>
<td>変更後の配列</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/fill" target="_blank"><code>Array.prototype.fill</code></a><sup>[ES2015]</sup></td>
<td>変更後の配列</td>
</tr>
</tbody>
</table>
<p>破壊的メソッドは意図せぬ副作用を与えてしまうことがあるため、そのことを意識して利用する必要があります。
たとえば、配列から特定のインデックスの要素を削除する<code>removeAtIndex</code>という関数を提供したいとします。</p>
<pre><code class="lang-js"><span class="hljs-comment">// `array`の`index`番目の要素を削除した配列を返す関数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">removeAtIndex</span>(<span class="hljs-params">array, index</span>) { <span class="hljs-comment">/* 実装 */</span> }
</code></pre>
<p>次のように、破壊的なメソッドであるArrayの<code>splice</code>メソッドで要素を削除すると、引数として受け取った配列にも影響を与えます。
この場合<code>removeAtIndex</code>関数には副作用があるため、破壊的であることについてのコメントがあると親切です。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// `array`の`index`番目の要素を削除した配列を返す関数</span>
<span class="hljs-comment">// 引数の`array`は破壊的に変更される</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">removeAtIndex</span>(<span class="hljs-params">array, index</span>) {
    array.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">return</span> array;
}
<span class="hljs-keyword">const</span> array = [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>];
<span class="hljs-comment">// `array`から1番目の要素を削除した配列を取得</span>
<span class="hljs-keyword">const</span> newArray = <span class="hljs-title function_">removeAtIndex</span>(array, <span class="hljs-number">1</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArray); <span class="hljs-comment">// =&gt; [&quot;A&quot;, &quot;C&quot;]</span>
<span class="hljs-comment">// `array`自体にも影響を与える</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array); <span class="hljs-comment">// =&gt; [&quot;A&quot;, &quot;C&quot;]</span>
</code></pre>
<p>一方、非破壊的メソッドは配列のコピーを作成するため、元々の配列に対して影響はありません。
この<code>removeAtIndex</code>関数を非破壊的なものにするには、受け取った配列をコピーしてから変更を加える必要があります。</p>
<p>JavaScriptには<code>copy</code>メソッドそのものは存在しませんが、配列をコピーする方法としてArrayの<code>slice</code>メソッドと<code>concat</code>メソッドが利用されています。
<code>slice</code>メソッドと<code>concat</code>メソッドは引数なしで呼び出すと、その配列のコピーを返します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> myArray = [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>];
<span class="hljs-comment">// `slice`は`myArray`のコピーを返す - `myArray.concat()`でも同じ</span>
<span class="hljs-keyword">const</span> copiedArray = myArray.<span class="hljs-title function_">slice</span>();
myArray.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;D&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myArray); <span class="hljs-comment">// =&gt; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]</span>
<span class="hljs-comment">// `array`のコピーである`copiedArray`には影響がない</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(copiedArray); <span class="hljs-comment">// =&gt; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</span>
<span class="hljs-comment">// コピーであるため参照は異なる</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(copiedArray === myArray); <span class="hljs-comment">// =&gt; false</span>
</code></pre>
<p>コピーした配列に変更を加えることで、<code>removeAtIndex</code>関数を非破壊的な関数として実装できます。
非破壊的であれば引数の配列への副作用がないので、注意させるようなコメントは不要です。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// `array`の`index`番目の要素を削除した配列を返す関数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">removeAtIndex</span>(<span class="hljs-params">array, index</span>) {
    <span class="hljs-comment">// コピーを作成してから変更する</span>
    <span class="hljs-keyword">const</span> copiedArray = array.<span class="hljs-title function_">slice</span>();
    copiedArray.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">return</span> copiedArray;
}
<span class="hljs-keyword">const</span> array = [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>];
<span class="hljs-comment">// `array`から1番目の要素を削除した配列を取得</span>
<span class="hljs-keyword">const</span> newArray = <span class="hljs-title function_">removeAtIndex</span>(array, <span class="hljs-number">1</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArray); <span class="hljs-comment">// =&gt; [&quot;A&quot;, &quot;C&quot;]</span>
<span class="hljs-comment">// 元の`array`には影響がない</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array); <span class="hljs-comment">// =&gt; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</span>
</code></pre>
<p>このようにJavaScriptの配列には破壊的なメソッドと非破壊的メソッドが混在しています。
名前からも区別することが難しく、副作用を避けるためにコピーを作ってから破壊的メソッドを使うというパターンが利用されていました。</p>
<p>しかし、ES2023でこの状況を改善する変更が追加されています。
今まで、破壊的なメソッドしかなかった、<code>splice</code>、<code>reverse</code>、<code>sort</code>に対して、
非破壊的なバージョンである<code>toSpliced</code>、<code>toReversed</code>、<code>toSorted</code>が追加されました。</p>
<p>これらの<code>to</code>から始まる非破壊的メソッドが受け取る引数は破壊的なメソッドと同じですが、非破壊的に変更した配列を返す点が異なります。
次のコードの<code>toSpliced</code>メソッドは、配列を複製してから変更するため、元々の配列である<code>array</code>には影響を与えていないことがわかります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2023" } --></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>];
<span class="hljs-comment">// `toSpliced`は`array`を複製してから変更する</span>
<span class="hljs-keyword">const</span> newArray = array.<span class="hljs-title function_">toSpliced</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArray); <span class="hljs-comment">// =&gt; [&quot;A&quot;, &quot;C&quot;]</span>
<span class="hljs-comment">// コピー元の`array`には影響がない</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array); <span class="hljs-comment">// =&gt; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</span>
</code></pre>
<p>先ほど<code>removeAtIndex</code>関数の実装では、<code>slice</code>メソッドで配列をコピーしてから<code>splice</code>メソッドを呼び出していました。
次のコードでは、<code>toSpliced</code>メソッドを使うことで、より簡潔に非破壊的な<code>removeAtIndex</code>関数を実装しています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2023" } --></p>
<pre><code class="lang-js"><span class="hljs-comment">// `array`の`index`番目の要素を削除した配列を返す関数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">removeAtIndex</span>(<span class="hljs-params">array, index</span>) {
    <span class="hljs-comment">// コピーを作成してから変更する</span>
    <span class="hljs-keyword">return</span> array.<span class="hljs-title function_">toSpliced</span>(index, <span class="hljs-number">1</span>);
}
<span class="hljs-keyword">const</span> array = [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>];
<span class="hljs-comment">// `array`から1番目の要素を削除した配列を取得</span>
<span class="hljs-keyword">const</span> newArray = <span class="hljs-title function_">removeAtIndex</span>(array, <span class="hljs-number">1</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArray); <span class="hljs-comment">// =&gt; [&quot;A&quot;, &quot;C&quot;]</span>
<span class="hljs-comment">// 元の`array`には影響がない</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array); <span class="hljs-comment">// =&gt; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</span>
</code></pre>
<p>また、ES2023では配列の指定したインデックスの要素を非破壊的に変更する<code>with</code>メソッドも追加されました。
<code>array[index] = value</code>の代入処理は、元々の配列を変更する破壊的な処理です。
 これに対して<code>with</code>メソッドは、配列を複製してから指定したインデックスの要素を変更した配列を返す非破壊的なメソッドです。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2023" } --></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>];
<span class="hljs-comment">// `array`の1番目の要素を変更した配列を返す</span>
<span class="hljs-keyword">const</span> newArray = array.<span class="hljs-title function_">with</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;B2&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArray); <span class="hljs-comment">// =&gt; [&quot;A&quot;, &quot;B2&quot;, &quot;C&quot;]</span>
</code></pre>
<p>次の表では、破壊的な方法に対応する非破壊的な方法をまとめています。</p>
<!-- TODO: to~のメソッドはMDNのページに日本語がないためen-USになっている) -->
<table>
<thead>
<tr>
<th>破壊的な方法</th>
<th>非破壊な方法</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>array[index] = item</code></td>
<td><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/with" target="_blank"><code>Array.prototype.with</code></a><sup>[ES2023]</sup></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" target="_blank"><code>Array.prototype.pop</code></a></td>
<td><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" target="_blank"><code>array.slice(0, -1)</code></a>と<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/at" target="_blank"><code>array.at(-1)</code></a><sup>[ES2022]</sup></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/push" target="_blank"><code>Array.prototype.push</code></a></td>
<td><code>[...array, item]</code><sup>[ES2015]</sup></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" target="_blank"><code>Array.prototype.splice</code></a></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSpliced" target="_blank"><code>Array.prototype.toSpliced</code></a><sup>[ES2023]</sup></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse" target="_blank"><code>Array.prototype.reverse</code></a></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toReversed" target="_blank"><code>Array.prototype.toReversed</code></a><sup>[ES2023]</sup></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" target="_blank"><code>Array.prototype.sort</code></a></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSorted" target="_blank"><code>Array.prototype.toSorted</code></a><sup>[ES2023]</sup></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/shift" target="_blank"><code>Array.prototype.shift</code></a></td>
<td><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" target="_blank"><code>array.slice(1)</code></a>と<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/at" target="_blank"><code>array.at(0)</code></a><sup>[ES2022]</sup></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift" target="_blank"><code>Array.prototype.unshift</code></a></td>
<td><code>[item, ...array]</code><sup>[ES2015]</sup></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin" target="_blank"><code>Array.prototype.copyWithin</code></a><sup>[ES2015]</sup></td>
<td>なし</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/fill" target="_blank"><code>Array.prototype.fill</code></a><sup>[ES2015]</sup></td>
<td>なし</td>
</tr>
</tbody>
</table>
<p>破壊的なメソッドは、シンプルですが元の配列も変更してしまうため、意図しない副作用が発生しバグの原因となる可能性があります。
非破壊的なメソッドは、使い分けが必要ですが元の配列を変更せずに新しい配列を返すため、副作用が発生することはありません。</p>
<p>そのため、まず非破壊的な方法で書けるかを検討し、そうではない場合に破壊的な方法を利用するとよいでしょう。</p>
<h2 id="array-iterate"><a name="array-iterate" class="plugin-anchor" href="#array-iterate"><i class="fa fa-link" aria-hidden="true"></i></a>配列を反復処理するメソッド </h2>
<p>「<a href="../loop/">ループと反復処理</a>」の章において配列を反復処理する方法を一部解説しましたが、改めて関連するArrayメソッドを見ていきます。
反復処理の中でもよく利用されるのがArrayの<code>forEach</code>、<code>map</code>、<code>filter</code>、<code>reduce</code>メソッドです。
どのメソッドも共通して引数にコールバック関数を受け取るため高階関数と呼ばれます。</p>
<h3 id="array-foreach"><a name="array-foreach" class="plugin-anchor" href="#array-foreach"><i class="fa fa-link" aria-hidden="true"></i></a><code>Array.prototype.forEach</code> </h3>
<p>Arrayの<code>forEach</code>メソッドは配列の要素を先頭から順番にコールバック関数へ渡し、反復処理を行うメソッドです。</p>
<p>次のようにコールバック関数には<code>要素, インデックス, 配列</code>が引数として渡され、配列要素の先頭から順番に反復処理します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
array.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">currentValue, index, array</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(currentValue, index, array);
});
<span class="hljs-comment">// コンソールの出力</span>
<span class="hljs-comment">// 1, 0, [1, 2, 3]</span>
<span class="hljs-comment">// 2, 1, [1, 2, 3]</span>
<span class="hljs-comment">// 3, 2, [1, 2, 3]</span>
</code></pre>
<h3 id="array-map"><a name="array-map" class="plugin-anchor" href="#array-map"><i class="fa fa-link" aria-hidden="true"></i></a><code>Array.prototype.map</code> </h3>
<p>Arrayの<code>map</code>メソッドは配列の要素を順番にコールバック関数へ渡し、コールバック関数が返した値から新しい配列を返す非破壊的なメソッドです。
配列の各要素を加工したい場合に利用します。</p>
<p>次のようにコールバック関数には<code>要素, インデックス, 配列</code>が引数として渡され、配列要素の先頭から順番に反復処理します。
<code>map</code>メソッドの返り値は、それぞれのコールバック関数が返した値を集めた新しい配列です。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-comment">// 各要素に10を乗算した新しい配列を作成する</span>
<span class="hljs-keyword">const</span> newArray = array.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">currentValue, index, array</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> currentValue * <span class="hljs-number">10</span>;
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArray); <span class="hljs-comment">// =&gt; [10, 20, 30]</span>
<span class="hljs-comment">// 元の配列とは異なるインスタンス</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array === newArray); <span class="hljs-comment">// =&gt; false</span>
</code></pre>
<h3 id="array-filter"><a name="array-filter" class="plugin-anchor" href="#array-filter"><i class="fa fa-link" aria-hidden="true"></i></a><code>Array.prototype.filter</code> </h3>
<p>Arrayの<code>filter</code>メソッドは配列の要素を順番にコールバック関数へ渡し、コールバック関数が<code>true</code>を返した要素だけを集めた新しい配列を返す非破壊的なメソッドです。
配列から不要な要素を取り除いた配列を作成したい場合に利用します。</p>
<p>次のようにコールバック関数には<code>要素, インデックス, 配列</code>が引数として渡され、配列要素の先頭から順番に反復処理します。
<code>filter</code>メソッドの返り値は、コールバック関数が<code>true</code>を返した要素だけを集めた新しい配列です。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-comment">// 奇数の値を持つ要素だけを集めた配列を返す</span>
<span class="hljs-keyword">const</span> newArray = array.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">currentValue, index, array</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> currentValue % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>;
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArray); <span class="hljs-comment">// =&gt; [1, 3]</span>
<span class="hljs-comment">// 元の配列とは異なるインスタンス</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array === newArray); <span class="hljs-comment">// =&gt; false</span>
</code></pre>
<h3 id="array-reduce"><a name="array-reduce" class="plugin-anchor" href="#array-reduce"><i class="fa fa-link" aria-hidden="true"></i></a><code>Array.prototype.reduce</code> </h3>
<p>Arrayの<code>reduce</code>メソッドは累積値（アキュムレータ）と配列の要素を順番にコールバック関数へ渡し、1つの累積値を返します。
配列から配列以外を含む任意の値を作成したい場合に利用します。</p>
<p>ここまでで紹介した反復処理のメソッドとは異なり、コールバック関数には<code>累積値, 要素, インデックス, 配列</code>を引数として渡します。
<code>reduce</code>メソッドの第二引数には<code>累積値</code>の初期値となる値を渡せます。</p>
<p>次のコードでは、<code>reduce</code>メソッドは初期値を0として配列の各要素を加算した1つの数値を返します。
つまり配列から配列要素の合計値というNumber型の値を返しています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-comment">// すべての要素を加算した値を返す</span>
<span class="hljs-comment">// accumulatorの初期値は`0`</span>
<span class="hljs-keyword">const</span> totalValue = array.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">accumulator, currentValue, index, array</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> accumulator + currentValue;
}, <span class="hljs-number">0</span>);
<span class="hljs-comment">// 0 + 1 + 2 + 3という式の結果が返り値になる</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(totalValue); <span class="hljs-comment">// =&gt; 6</span>
</code></pre>
<p><code>reduce</code>メソッドに渡したコールバック関数は配列の要素数である3回呼び出され、それぞれ次のような結果になります。</p>
<table>
<thead>
<tr>
<th></th>
<th>accumulator</th>
<th>currentValue</th>
<th>returnした値</th>
</tr>
</thead>
<tbody>
<tr>
<td>1回目の呼び出し</td>
<td>0</td>
<td>1</td>
<td>0 + 1</td>
</tr>
<tr>
<td>2回目の呼び出し</td>
<td>1</td>
<td>2</td>
<td>1 + 2</td>
</tr>
<tr>
<td>3回目の呼び出し</td>
<td>3</td>
<td>3</td>
<td>3 + 3</td>
</tr>
</tbody>
</table>
<p>Arrayの<code>reduce</code>メソッドはやや複雜ですが、配列から配列以外のデータ型の値を作成できる特徴があります。
また、<code>reduce</code>メソッドでは、配列から直接Number型の値を返せるため、<code>totalValue</code>という変数を再代入できない<code>const</code>で宣言していました。</p>
<p>配列の数値の合計を<code>forEach</code>メソッドなど反復処理で計算すると、次のコードのように<code>totalValue</code>という変数は再代入ができる<code>let</code>で宣言する必要があります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-comment">// 初期値は`0`</span>
<span class="hljs-keyword">let</span> totalValue = <span class="hljs-number">0</span>;
array.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">currentValue</span>) =&gt;</span> {
    totalValue += currentValue;
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(totalValue); <span class="hljs-comment">// =&gt; 6</span>
</code></pre>
<p><code>let</code>で宣言した変数は再代入が可能なため、意図しない箇所で変数の値が変更され、バグの原因となることがあります。
そのため、できる限り変数を<code>const</code>で宣言したい場合には<code>reduce</code>メソッドは有用です。
一方で、<code>reduce</code>メソッドは可読性があまりよくないため、コードの意図が伝わりにくいというデメリットもあります。</p>
<p><code>reduce</code>メソッドには利点と可読性のトレードオフがありますが、利用する場合は<code>reduce</code>メソッドを扱う処理を関数にするといった処理の意図がわかるように工夫をする必要があります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">array</span>) {
    <span class="hljs-keyword">return</span> array.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">accumulator, currentValue</span>) =&gt;</span> {
        <span class="hljs-keyword">return</span> accumulator + currentValue;
    }, <span class="hljs-number">0</span>);
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(array)); <span class="hljs-comment">// =&gt; 6</span>
</code></pre>
<h3 id="object-group-by"><a name="object-group-by" class="plugin-anchor" href="#object-group-by"><i class="fa fa-link" aria-hidden="true"></i></a>[ES2024] <code>Object.groupBy</code>静的メソッド </h3>
<p><code>Array.prototype.reduce</code>メソッドを使うことで、配列から数値やオブジェクトなど任意の値を作成できます。</p>
<p>先ほどは配列の合計の数値を計算する例でしたが、配列からオブジェクトを作成することもできます。
配列からオブジェクトを作成したいユースケースとして、配列の要素を条件によってグループ分けしたいケースがあります。
たとえば、数値からなる配列の要素を奇数と偶数の配列に分けたい場合などです。</p>
<p><code>Array.prototype.reduce</code>メソッドを使って、数値からなる配列を奇数と偶数に分けるコードは次のようになります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-keyword">const</span> grouped = array.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">accumulator, currentValue</span>) =&gt;</span> {
    <span class="hljs-comment">// 2で割った余りが0なら偶数(even)、そうでないなら奇数(odd)</span>
    <span class="hljs-keyword">const</span> key = currentValue % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;even&quot;</span> : <span class="hljs-string">&quot;odd&quot;</span>;
    <span class="hljs-keyword">if</span> (!accumulator[key]) {
        accumulator[key] = [];
    }
    <span class="hljs-comment">// グループ分けしたキーの配列に要素を追加</span>
    accumulator[key].<span class="hljs-title function_">push</span>(currentValue);
    <span class="hljs-keyword">return</span> accumulator;
}, {});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(grouped.<span class="hljs-property">even</span>); <span class="hljs-comment">// =&gt; [2, 4]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(grouped.<span class="hljs-property">odd</span>); <span class="hljs-comment">// =&gt; [1, 3, 5]</span>
</code></pre>
<p>しかし、<code>reduce</code>メソッドは使い方がやや複雜であるため、可能なら避けたほうが読みやすいコードとなりやすいです。
ES2024では、<code>Object.groupBy</code>静的メソッドが追加され、配列からグループ分けしたオブジェクトを作成できるようになっています。</p>
<p><code>Object.groupBy</code>静的メソッド<sup><a href="#fn_1" id="reffn_1">1</a></sup>には、第一引数に配列などのiterableオブジェクト、第二引数にグループ分けの条件を返すコールバック関数を渡します。
第二引数のコールバック関数が返した値をキーとして、配列の要素をグループ分けしたオブジェクトが作成されます。</p>
<p>先ほどのコードを<code>Object.groupBy</code>静的メソッドを使って書き換えると、次のようになります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2024" } --></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-keyword">const</span> grouped = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">groupBy</span>(array, <span class="hljs-function">(<span class="hljs-params">currentValue</span>) =&gt;</span> {
    <span class="hljs-comment">// currentValueが偶数なら&quot;even&quot;、そうでないなら&quot;odd&quot;の配列に追加される</span>
    <span class="hljs-keyword">return</span> currentValue % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;even&quot;</span> : <span class="hljs-string">&quot;odd&quot;</span>;
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(grouped.<span class="hljs-property">even</span>); <span class="hljs-comment">// =&gt; [2, 4]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(grouped.<span class="hljs-property">odd</span>); <span class="hljs-comment">// =&gt; [1, 3, 5]</span>
</code></pre>
<p><code>Object.groupBy</code>静的メソッドを使うことで、配列からグループ分けしたオブジェクトを簡潔に作成できます。</p>
<h2 id="array-like"><a name="array-like" class="plugin-anchor" href="#array-like"><i class="fa fa-link" aria-hidden="true"></i></a>[コラム] Array-likeオブジェクト </h2>
<p>配列のように扱えるが配列ではないオブジェクトのことを、<strong>Array-likeオブジェクト</strong>と呼びます。
Array-likeオブジェクトとは配列のようにインデックスにアクセスでき、配列のように<code>length</code>プロパティも持っています。しかし、配列のインスタンスではないため、Arrayのプロトタイプメソッドを持っていないオブジェクトのことです。</p>
<table>
<thead>
<tr>
<th>機能</th>
<th>Array-likeオブジェクト</th>
<th>配列</th>
</tr>
</thead>
<tbody>
<tr>
<td>インデックスアクセス（<code>array[0]</code>）</td>
<td>できる</td>
<td>できる</td>
</tr>
<tr>
<td>長さ（<code>array.length</code>）</td>
<td>持っている</td>
<td>持っている</td>
</tr>
<tr>
<td>Arrayのプロトタイプメソッド(<code>forEach</code>メソッドなど)</td>
<td>持っていない場合もある</td>
<td>持っている</td>
</tr>
</tbody>
</table>
<p>Array-likeオブジェクトの例として<code>arguments</code>があります。
<code>arguments</code>オブジェクトは、<code>function</code>で宣言した関数の中から参照できる変数です。
<code>arguments</code>オブジェクトには関数の引数に渡された値が順番に格納されていて、配列のように引数へアクセスできます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunc</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]); <span class="hljs-comment">// =&gt; &quot;a&quot;</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]); <span class="hljs-comment">// =&gt; &quot;b&quot;</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">2</span>]); <span class="hljs-comment">// =&gt; &quot;c&quot;</span>
    <span class="hljs-comment">// 配列ではないため、配列のメソッドは持っていない</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">forEach</span>); <span class="hljs-comment">// =&gt; &quot;undefined&quot;</span>
}
<span class="hljs-title function_">myFunc</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);
</code></pre>
<p>Array-likeオブジェクトか配列なのかを判別するには<code>Array.isArray</code>メソッドを利用できます。
<code>Array-like</code>オブジェクトは配列ではないので結果は常に<code>false</code>となります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunc</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])); <span class="hljs-comment">// =&gt; true</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(<span class="hljs-variable language_">arguments</span>)); <span class="hljs-comment">// =&gt; false</span>
}
<span class="hljs-title function_">myFunc</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);
</code></pre>
<p>Array-likeオブジェクトは配列のようで配列ではないというもどかしさを持つオブジェクトです。<code>Array.from</code>静的メソッド<sup>[ES2015]</sup>を使うことでArray-likeオブジェクトを配列に変換して扱うことができます。一度配列に変換してしまえばArrayメソッドも利用できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunc</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Array-likeオブジェクトを配列へ変換</span>
    <span class="hljs-keyword">const</span> argumentsArray = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">arguments</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(argumentsArray)); <span class="hljs-comment">// =&gt; true</span>
    <span class="hljs-comment">// 配列のメソッドを利用できる</span>
    argumentsArray.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">arg</span> =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg);
    });
}
<span class="hljs-title function_">myFunc</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);
</code></pre>
<h2 id="method-chain-and-high-order-function"><a name="method-chain-and-high-order-function" class="plugin-anchor" href="#method-chain-and-high-order-function"><i class="fa fa-link" aria-hidden="true"></i></a>メソッドチェーンと高階関数 </h2>
<p>配列で頻出するパターンとしてメソッドチェーンがあります。
メソッドチェーンとは、メソッドを呼び出した返り値に対してさらにメソッド呼び出しをするパターンのことを言います。</p>
<p>次のコードでは、Arrayの<code>concat</code>メソッドの返り値、つまり配列に対してさらに<code>concat</code>メソッドを呼び出すというメソッドチェーンが行われています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">&quot;a&quot;</span>].<span class="hljs-title function_">concat</span>(<span class="hljs-string">&quot;b&quot;</span>).<span class="hljs-title function_">concat</span>(<span class="hljs-string">&quot;c&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array); <span class="hljs-comment">// =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
</code></pre>
<p>このコードの<code>concat</code>メソッドの呼び出しを分解してみると何が行われているのかわかりやすいです。
<code>concat</code>メソッドの返り値は結合した新しい配列です。先ほどのメソッドチェーンでは、その新しい配列に対してさらに<code>concat</code>メソッドで値を結合しているということがわかります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// メソッドチェーンを分解した例</span>
<span class="hljs-comment">// 一時的な`abArray`という変数が増えている</span>
<span class="hljs-keyword">const</span> abArray = [<span class="hljs-string">&quot;a&quot;</span>].<span class="hljs-title function_">concat</span>(<span class="hljs-string">&quot;b&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(abArray); <span class="hljs-comment">// =&gt; [&quot;a&quot;, &quot;b&quot;]</span>
<span class="hljs-keyword">const</span> abcArray = abArray.<span class="hljs-title function_">concat</span>(<span class="hljs-string">&quot;c&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(abcArray); <span class="hljs-comment">// =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
</code></pre>
<p>メソッドチェーンを利用することで処理の見た目を簡潔にできます。メソッドチェーンを利用した場合も最終的な処理結果は同じですが、途中の一時的な変数を省略できます。先ほどの例では<code>abArray</code>という一時的な変数をメソッドチェーンでは省略できています。</p>
<p>メソッドチェーンは配列に限ったものではありませんが、配列では頻出するパターンです。なぜなら、配列に含まれるデータを表示する際には、最終的に文字列や数値など別のデータへ加工することがほとんどであるためです。配列には配列を返す高階関数が多く実装されているため、配列を柔軟に加工できます。</p>
<p>次のコードでは、ECMAScriptのバージョン名と発行年数が定義された<code>ECMAScriptVersions</code>という配列が定義されています。この配列から<code>2000</code>年以前に発行されたECMAScriptのバージョン名の一覧を取り出すことを考えてみます。目的の一覧を取り出すには「2000年以前のデータに絞り込む」と「データから<code>name</code>を取り出す」という2つの加工処理を組み合わせる必要があります。</p>
<p>この2つの加工処理はArrayの<code>filter</code>メソッドと<code>map</code>メソッドで実現できます。
<code>filter</code>メソッドで配列から<code>2000</code>年以前というルールで絞り込み、<code>map</code>メソッドでそれぞれの要素から<code>name</code>プロパティを取り出せます。
どちらのメソッドも配列を返すのでメソッドチェーンで処理をつなげられます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// ECMAScriptのバージョン名と発行年</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">ECMAScriptVersions</span> = [
    { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;ECMAScript 1&quot;</span>, <span class="hljs-attr">year</span>: <span class="hljs-number">1997</span> },
    { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;ECMAScript 2&quot;</span>, <span class="hljs-attr">year</span>: <span class="hljs-number">1998</span> },
    { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;ECMAScript 3&quot;</span>, <span class="hljs-attr">year</span>: <span class="hljs-number">1999</span> },
    { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;ECMAScript 5&quot;</span>, <span class="hljs-attr">year</span>: <span class="hljs-number">2009</span> },
    { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;ECMAScript 5.1&quot;</span>, <span class="hljs-attr">year</span>: <span class="hljs-number">2011</span> },
    { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;ECMAScript 2015&quot;</span>, <span class="hljs-attr">year</span>: <span class="hljs-number">2015</span> },
    { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;ECMAScript 2016&quot;</span>, <span class="hljs-attr">year</span>: <span class="hljs-number">2016</span> },
    { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;ECMAScript 2017&quot;</span>, <span class="hljs-attr">year</span>: <span class="hljs-number">2017</span> },
];
<span class="hljs-comment">// メソッドチェーンで必要な加工処理を並べている</span>
<span class="hljs-keyword">const</span> versionNames = <span class="hljs-title class_">ECMAScriptVersions</span>
    <span class="hljs-comment">// 2000年以下のデータに絞り込み</span>
    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">ECMAScript</span> =&gt;</span> <span class="hljs-title class_">ECMAScript</span>.<span class="hljs-property">year</span> &lt;= <span class="hljs-number">2000</span>)
    <span class="hljs-comment">// それぞれの要素から`name`プロパティを取り出す</span>
    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">ECMAScript</span> =&gt;</span> <span class="hljs-title class_">ECMAScript</span>.<span class="hljs-property">name</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(versionNames); <span class="hljs-comment">// =&gt; [&quot;ECMAScript 1&quot;, &quot;ECMAScript 2&quot;, &quot;ECMAScript 3&quot;]</span>
</code></pre>
<p>メソッドチェーンを使うことで複数の処理からなるものをひとつのまとまった処理のように見せることができます。長過ぎるメソッドチェーンは長過ぎる関数と同じように読みにくくなりますが、適度な単位のメソッドチェーンは処理をスッキリ見せるパターンとして利用されています。</p>
<h2 id="conclusion"><a name="conclusion" class="plugin-anchor" href="#conclusion"><i class="fa fa-link" aria-hidden="true"></i></a>まとめ </h2>
<p>この章では配列について学びました。</p>
<ul>
<li>配列は順序を持った要素を格納できるオブジェクトの一種</li>
<li>配列には破壊的なメソッドと非破壊的なメソッドがある</li>
<li>配列には反復処理を行う高階関数となるメソッドがある</li>
<li>メソッドチェーンは配列のメソッドが配列を返すことを利用している</li>
</ul>
<p>配列はJavaScriptの中でもよく使われるオブジェクトで、メソッドの種類も多いです。
この書籍でもすべてのメソッドは紹介していないため、詳しくは<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank">Arrayについてのドキュメント</a>も参照してみてください。</p>
<blockquote id="fn_1">
<sup>1</sup>. <code>Array.prototype.groupBy</code>メソッドのようなArrayのメソッドではないのは、同じメソッド名を実装するウェブサイトが多く存在しており後方互換性がなかったためです。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> ↩</a>
</blockquote>
</body></html>
                                

                                </section>
                            
                        </div>
                    </div>
                
<footer class="book_footer">
    <p>Copyright (c) 2016-present <a href="https://github.com/asciidwango/js-primer" target="_blank">jsprimer project</a></p>
</footer>

            </div>

            
                
                <a href="../prototype-object/" class="navigation navigation-prev " aria-label="Previous page: プロトタイプオブジェクト">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="../string/" class="navigation navigation-next " aria-label="Next page: 文字列">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"author":"azu","description":"配列は値を順番に格納できるオブジェクトです。この配列の作成、更新、削除などの基本的な操作や実際に使い方についてを紹介します。また配列における破壊的なメソッドと非破壊的メソッドの違いについても紹介します。","sponsors":[],"title":"配列","level":"1.3.14","depth":2,"next":{"title":"文字列","level":"1.3.15","depth":2,"path":"basic/string/README.md","ref":"./basic/string/README.md","articles":[]},"previous":{"title":"プロトタイプオブジェクト","level":"1.3.13","depth":2,"path":"basic/prototype-object/README.md","ref":"./basic/prototype-object/README.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-lunr","page-toc-button","include-codeblock","anchors","canonical-link","js-console","github-issue-feedback","sandpack"],"root":"./source/","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"docSearch":{"index":"83I8JIFICQ","apiKey":"9169ce4cd84fcf2376f29d9585c89254"},"github-issue-feedback":{"repo":"asciidwango/js-primer","label":"問題を報告する"},"fontsettings":{"theme":"white","family":"sans","size":2},"js-console":{},"canonical-link":{"baseURL":"https://jsprimer.net"},"highlight":{},"page-toc-button":{"maxTocDepth":2,"minTocSize":2},"include-codeblock":{"check":false,"edit":false,"lang":"","fixlang":false,"template":"./resources/gitbook-plugin-include-codeblock.hbs","theme":"chrome","unindent":false},"sandpack":{},"edit-link":{"base":"https://github.com/asciidwango/js-primer/edit/master/source/","label":"Edit"},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"anchors":{}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"IPAexMincho","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"index.md","glossary":"GLOSSARY.md","summary":"README.md"},"variables":{"esversion":"2024","nodeversion":"22.7.0","npmversion":"10.8.2","triplebackticks":"```","console":"<a class=\"gitbook-plugin-js-console\" aria-hidden=\"true\"></a>"},"title":"JavaScript Primer #jsprimer","gitbook":">=3.0.0","description":"JavaScriptの基本的な書き方からアプリケーションの作成などのユースケースを学ぶための入門書です"},"file":{"path":"basic/array/README.md","mtime":"2024-08-25T14:19:02.244Z","type":"markdown"},"gitbook":{"version":"5.1.4","time":"2024-08-25T14:19:21.571Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-page-toc-button/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-js-console/console-ui.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-github-issue-feedback/plugin.js"></script>
        
    
        
        <script src="../../gitbook/honkit-plugin-sandpack/honkit-plugin-sandpack.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

