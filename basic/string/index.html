
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>文字列 · JavaScript Primer #jsprimer</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="文字列リテラルを使った文字列の作成から検索や置換など基本的な文字列操作について紹介します。また正規表現と組み合わせた文字列操作やタグ付きテンプレート関数を使ったテンプレート処理などについても紹介します。">
        <meta name="generator" content="HonKit 5.1.4">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-page-toc-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-anchors/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

         
    
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="../string-unicode/" />
    
    
    <link rel="prev" href="../array/" />
    

    <link rel="canonical" href="https://jsprimer.net/basic/string/">

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-DWY0DLHWB6"></script>
<script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }

    gtag("js", new Date());

    gtag("config", "G-DWY0DLHWB6");
</script>
<script type="module">
    // コンソールUIでコード実行したらイベントとして送信する
    const onExecuteCode = (scriptType) => {
        gtag("event", "execute_code", {
            "event_category": "console",
            "event_label": "execute_code",
            "script_type": scriptType || "unknown"
        });
    };
    let observer;
    const observeEvalEvent = () => {
        if (observer) {
            observer.disconnect();
        }
        const callback = function(mutationsList) {
            for (const mutation of mutationsList) {
                const mirrorConsole = Array.from(mutation.addedNodes).find(node => Boolean(node.dataset.mirrorConsole));
                if (mirrorConsole) {
                    return onExecuteCode(mirrorConsole.dataset.mirrorConsole);
                }
            }
        };
        observer = new MutationObserver(callback);
        observer.observe(document.body, { childList: true });
    };
    const eventMap = new WeakMap();
    // 問題を報告ボタンを押したらイベントとして送信する
    const onClickIssueReport = () => {
        console.log("click_issue_report");
        gtag("event", "click_issue_report", {
            "event_category": "contribution",
            "event_label": "click_issue_report"
        });
    };
    const observeIssueReport = () => {
        const targetButton = document.querySelector(".gitbook-plugin-github-issue-feedback");
        // すでにイベントが登録されていたら何もしない
        if (eventMap.has(targetButton)) {
            return;
        }
        if (targetButton) {
            targetButton.addEventListener("click", onClickIssueReport);
            eventMap.set(targetButton, onClickIssueReport);
        }
    };
    window.addEventListener("DOMContentLoaded", function() {
        gitbook.events.on("page.change", function() {
            observeEvalEvent();
            observeIssueReport();
        });
    });

</script>
<meta name="google-site-verification" content="bMotEbgYwkzA3k4PkuyK_NUdz0bKh-Phz0oUwNmRSVo"/>
<style>
    /*
     * Disable antialias
     */
    * {
        -webkit-font-smoothing: initial !important
    }

    body {
        text-rendering: initial !important;
        font-smoothing: initial !important;
    }

    /* deny access chapter */
    .summary li.chapter > span {
        cursor: not-allowed;
        opacity: .3;
    }

    /* console ui */

    .mirror-console-attach-button-wrapper {
        margin-top: -1.275em;
        margin-bottom: 1.275em
    }

    .mirror-console-wrapper {
        margin-top: 1.275em;
        margin-bottom: 1.275em
    }

    /* file name for codeblock */
    .code-filename {
        background-color: #eee;
        display: inline-block;
        padding: 2px 8px;
        line-height: inherit;
        margin-bottom: 0px !important;
    }

    /* Markdown */
    /* Support horizon scroll */
    /* https://stackoverflow.com/questions/17770257/scrolling-tables-horizontally-without-wrapping-them-in-div */
    .markdown-section table {
        max-width: 100%;
        overflow-x: auto;
        display: block;
    }
    .markdown-section sup,
    .markdown-section sub {
        font-size: 75%;
    }

    .book_footer {
        text-align: center;
        color: #000000;
        background: #ddd;
        font-size: 16px;
        margin-top: 16px;
        padding: 16px;
    }

    /* github-issue-feedback */
    .gitbook-plugin-github-issue-feedback {
        background-color: #333;
        color: #fff;
        opacity: 0.8;
        padding: 4px;
        margin-right: 24px;
        margin-bottom: 4px;
        border-radius: 6px;
    }

    .gitbook-plugin-github-issue-feedback:hover {
        opacity: 1;
    }

    /* Hide footer on mobile */
    /* Use navigation width */
    @media (max-width: 1240px) {
        .book_footer {
            display: none;
        }
    }

    .navigation {
        min-width: 50px;
    }

    @media (min-width: 1240px) {
        .honkit-plugin-sandpack {
            width: calc(100% + 180px);
            margin: 0 0 1em -90px;
        }
    }

    .honkit-plugin-sandpack, .honkit-plugin-sandpack--buttonContainer {
        margin-bottom: 1em;
    }

</style>
<meta name="theme-color" content="#ffffff">
<link rel="manifest" href="../../manifest.json">
<script defer async>
    // unregister old service worker(remove workbox)
    // https://github.com/asciidwango/js-primer/pull/1701
    navigator.serviceWorker.getRegistrations().then(function(registrations) {
        for (const registration of registrations) {
            registration.unregister();
        }
    }).catch(function(err) {
        console.error(new Error("Can not getRegistrations", {
            cause: err
        }));
    });
</script>

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                    この書籍について
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../../intro/">
            
                <a href="../../intro/">
            
                    
                    はじめに
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../../intro/authors/">
            
                <a href="../../intro/authors/">
            
                    
                    著者紹介
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../../intro/sponsors/">
            
                <a href="../../intro/sponsors/">
            
                    
                    JavaScript Primerスポンサー
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../../intro/preparation/">
            
                <a href="../../intro/preparation/">
            
                    
                    読み始める前の事前準備
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="../../intro/feedback/">
            
                <a href="../../intro/feedback/">
            
                    
                    文章の間違いに気づいたら
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../">
            
                <a href="../">
            
                    
                    第一部: 基本文法
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../introduction/">
            
                <a href="../introduction/">
            
                    
                    JavaScriptとは
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../comments/">
            
                <a href="../comments/">
            
                    
                    コメント
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../variables/">
            
                <a href="../variables/">
            
                    
                    変数と宣言
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../read-eval-print/">
            
                <a href="../read-eval-print/">
            
                    
                    値の評価と表示
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="../data-type/">
            
                <a href="../data-type/">
            
                    
                    データ型とリテラル
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="../operator/">
            
                <a href="../operator/">
            
                    
                    演算子
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="../implicit-coercion/">
            
                <a href="../implicit-coercion/">
            
                    
                    暗黙的な型変換
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="../function-declaration/">
            
                <a href="../function-declaration/">
            
                    
                    関数と宣言
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.9" data-path="../statement-expression/">
            
                <a href="../statement-expression/">
            
                    
                    文と式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.10" data-path="../condition/">
            
                <a href="../condition/">
            
                    
                    条件分岐
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.11" data-path="../loop/">
            
                <a href="../loop/">
            
                    
                    ループと反復処理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.12" data-path="../object/">
            
                <a href="../object/">
            
                    
                    オブジェクト
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.13" data-path="../prototype-object/">
            
                <a href="../prototype-object/">
            
                    
                    プロトタイプオブジェクト
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.14" data-path="../array/">
            
                <a href="../array/">
            
                    
                    配列
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.3.15" data-path="./">
            
                <a href="./">
            
                    
                    文字列
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.16" data-path="../string-unicode/">
            
                <a href="../string-unicode/">
            
                    
                    文字列とUnicode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.17" data-path="../wrapper-object/">
            
                <a href="../wrapper-object/">
            
                    
                    ラッパーオブジェクト
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.18" data-path="../function-scope/">
            
                <a href="../function-scope/">
            
                    
                    関数とスコープ
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.19" data-path="../function-this/">
            
                <a href="../function-this/">
            
                    
                    関数とthis
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.20" data-path="../class/">
            
                <a href="../class/">
            
                    
                    クラス
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.21" data-path="../error-try-catch/">
            
                <a href="../error-try-catch/">
            
                    
                    例外処理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.22" data-path="../async/">
            
                <a href="../async/">
            
                    
                    非同期処理:Promise/Async Function
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.23" data-path="../map-and-set/">
            
                <a href="../map-and-set/">
            
                    
                    Map/Set
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.24" data-path="../json/">
            
                <a href="../json/">
            
                    
                    JSON
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.25" data-path="../date/">
            
                <a href="../date/">
            
                    
                    Date
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.26" data-path="../math/">
            
                <a href="../math/">
            
                    
                    Math
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.27" data-path="../module/">
            
                <a href="../module/">
            
                    
                    ECMAScriptモジュール
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.28" data-path="../ecmascript/">
            
                <a href="../ecmascript/">
            
                    
                    ECMAScript
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.29" data-path="../other-parts/">
            
                <a href="../other-parts/">
            
                    
                    第一部: おわりに
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../../use-case/">
            
                <a href="../../use-case/">
            
                    
                    第二部: 応用編（ユースケース）
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../../use-case/setup-local-env/">
            
                <a href="../../use-case/setup-local-env/">
            
                    
                    アプリケーション開発の準備
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../../use-case/ajaxapp/">
            
                <a href="../../use-case/ajaxapp/">
            
                    
                    Ajax通信
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.2.1" data-path="../../use-case/ajaxapp/entrypoint/">
            
                <a href="../../use-case/ajaxapp/entrypoint/">
            
                    
                    エントリーポイント
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.2" data-path="../../use-case/ajaxapp/http/">
            
                <a href="../../use-case/ajaxapp/http/">
            
                    
                    HTTP通信
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.3" data-path="../../use-case/ajaxapp/display/">
            
                <a href="../../use-case/ajaxapp/display/">
            
                    
                    データを表示する
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.4" data-path="../../use-case/ajaxapp/promise/">
            
                <a href="../../use-case/ajaxapp/promise/">
            
                    
                    Promiseを活用する
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../../use-case/nodecli/">
            
                <a href="../../use-case/nodecli/">
            
                    
                    Node.jsでCLIアプリ
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.3.1" data-path="../../use-case/nodecli/helloworld/">
            
                <a href="../../use-case/nodecli/helloworld/">
            
                    
                    Node.jsでHello World
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3.2" data-path="../../use-case/nodecli/argument-parse/">
            
                <a href="../../use-case/nodecli/argument-parse/">
            
                    
                    コマンドライン引数を処理する
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3.3" data-path="../../use-case/nodecli/read-file/">
            
                <a href="../../use-case/nodecli/read-file/">
            
                    
                    ファイルを読み込む
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3.4" data-path="../../use-case/nodecli/md-to-html/">
            
                <a href="../../use-case/nodecli/md-to-html/">
            
                    
                    MarkdownをHTMLに変換する
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3.5" data-path="../../use-case/nodecli/refactor-and-unittest/">
            
                <a href="../../use-case/nodecli/refactor-and-unittest/">
            
                    
                    ユニットテストを記述する
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="../../use-case/todoapp/">
            
                <a href="../../use-case/todoapp/">
            
                    
                    Todoアプリ
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.4.1" data-path="../../use-case/todoapp/entrypoint/">
            
                <a href="../../use-case/todoapp/entrypoint/">
            
                    
                    エントリーポイント
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.2" data-path="../../use-case/todoapp/app-structure/">
            
                <a href="../../use-case/todoapp/app-structure/">
            
                    
                    アプリの構成要素
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.3" data-path="../../use-case/todoapp/form-event/">
            
                <a href="../../use-case/todoapp/form-event/">
            
                    
                    Todoアイテムの追加を実装する
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.4" data-path="../../use-case/todoapp/event-model/">
            
                <a href="../../use-case/todoapp/event-model/">
            
                    
                    イベントとモデル
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.5" data-path="../../use-case/todoapp/update-delete/">
            
                <a href="../../use-case/todoapp/update-delete/">
            
                    
                    Todoアイテムの更新と削除を実装する
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.6" data-path="../../use-case/todoapp/final/">
            
                <a href="../../use-case/todoapp/final/">
            
                    
                    Todoアプリのリファクタリング
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../../appendix/links/">
            
                <a href="../../appendix/links/">
            
                    
                    付録: 参考リンク集
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../../cheatsheet/">
            
                <a href="../../cheatsheet/">
            
                    
                    付録: JavaScriptチートシート
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../../outro/">
            
                <a href="../../outro/">
            
                    
                    おわりに
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<!-- Header -->
<meta name="keywords" content="JavaScript,ECMAScript,JS,入門,チュートリアル,書籍,本,無料,Node.js,ブラウザ"/>
<link rel="author" href="https://www.hatena.ne.jp/efcl/"/>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css"/>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<style>
    .book-header {
        display: flex;
        flex-direction: row;
        background-color: #333;
    }

    /* link color */
    .book-header a {
        color: #fff;
    }

    /* hover color */
    .book-header .btn:hover, .book-header .btn:focus, .book-header a:focus, .book-header a:hover {
        color: hsla(0, 0%, 100%, 0.75) !important;
    }

    /* Mobile header fixed */
    @media (max-width: 768px) {
        /* Headerを固定する */
        .book-header {
            position: fixed;
            width: 100%;
        }

        /* Icon only */
        .book-header-title-img {
            margin: auto 18px auto 0 !important;
        }

        .book-header-title-h {
            display: none;
        }

        /* Header分のズレを入れる */
        .page-wrapper {
            padding-top: 60px;
        }

        /* github-issue-feedbackを非表示にする */
        .gitbook-plugin-github-issue-feedback {
            display: none;
        }
    }

    /* Dynamic created by GitBook*/
    .btn.pull-left.js-toolbar-action {
        order: 1;
    }

    .book-header-title {
        order: 2;
        display: inline-flex;
        flex-direction: row;
        color: #fff;
    }

    .book-header-title:hover {
        color: hsla(0, 0%, 100%, 0.75);
    }

    .book-header-title-img {
        width: 32px;
        height: 32px;
        padding: 0;
        margin: auto 10px auto 0;
    }

    .book-header-title-h {
        font-size: 20px;
        margin: auto;
        padding: 0;
    }

    .header-center {
        order: 3;
        display: inline-flex;
        flex-direction: column;
        justify-content: center;
        /* self */
        flex-grow: 1;
        flex-shrink: 0;
        flex-basis: auto;
    }

    .header-right {
        order: 4;
        display: inline-flex;
        flex-direction: row;
        justify-content: center;
        align-items: center;
        /* icon size */
        font-size: 24px;
    }

    .amazon-link, .github-link {
        color: #fff;
        /* Padding and make Vertical */
        display: inline-flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding-left: 4px;
        padding-right: 4px;
    }

    /* Desktop */
    @media (min-width: 768px) {
        .header-center {
            align-items: center;
        }

        .header-right {
            margin-right: 24px;
        }
    }

    /* DocSearch */
    @media (max-width: 768px) {
        .algolia-autocomplete .ds-dropdown-menu {
            max-width: calc(100vw - 32px) !important;
            min-width: calc(100vw - 32px) !important;
            width: calc(100vw - 32px) !important;
            /* negative margin
              This is absolute element
              */
            margin-left: -32px !important;
        }

        .algolia-autocomplete .algolia-docsearch-suggestion--content {
            width: 100% !important;
            padding-left: 0 !important;
        }

        .algolia-autocomplete .algolia-docsearch-suggestion--content:before {
            display: none !important;
        }

        .algolia-autocomplete .algolia-docsearch-suggestion--subcategory-column {
            display: none !important;
        }

        .algolia-autocomplete.algolia-autocomplete-right .ds-dropdown-menu {
            right: inherit !important
        }

        .algolia-autocomplete.algolia-autocomplete-right .ds-dropdown-menu::before {
            right: 50%;
        }

        .sbx-custom {
            width: 92px !important;
            padding: initial !important;
        }

        .amazon-link {
            display: none;
        }
    }

    /* SearchBox */
    .searchbarWrapper {
        height: 50px;
    }


    .sbx-custom {
        display: inline-block;
        position: relative;
        min-width: 150px;
        width: 300px;
        max-width: 300px;
        height: 33px;
        white-space: nowrap;
        box-sizing: border-box;
        font-size: 14px;
    }

    .sbx-custom__wrapper {
        width: 100%;
        height: 100%;
    }

    .sbx-custom__input {
        display: inline-block;
        -webkit-transition: box-shadow .4s ease, background .4s ease;
        transition: box-shadow .4s ease, background .4s ease;
        border: 0;
        border-radius: 5px;
        box-shadow: inset 0 0 0 2px #CCCCCC;
        background: #FFFFFF;
        padding: 0 27px 0 33px;
        width: 100%;
        height: 100%;
        vertical-align: middle;
        white-space: normal;
        font-size: inherit;
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
    }

    .sbx-custom__input::-webkit-search-decoration, .sbx-custom__input::-webkit-search-cancel-button, .sbx-custom__input::-webkit-search-results-button, .sbx-custom__input::-webkit-search-results-decoration {
        display: none;
    }

    .sbx-custom__input:hover {
        box-shadow: inset 0 0 0 2px #b3b3b3;
    }

    .sbx-custom__input:focus, .sbx-custom__input:active {
        outline: 0;
        box-shadow: inset 0 0 0 2px #4B54DE;
        background: #FFFFFF;
    }

    .sbx-custom__input::-webkit-input-placeholder {
        color: #BBBBBB;
    }

    .sbx-custom__input::-moz-placeholder {
        color: #BBBBBB;
    }

    .sbx-custom__input:-ms-input-placeholder {
        color: #BBBBBB;
    }

    .sbx-custom__input::placeholder {
        color: #BBBBBB;
    }

    .sbx-custom__submit {
        position: absolute;
        top: 0;
        right: inherit;
        left: 0;
        margin: 0;
        border: 0;
        border-radius: 4px 0 0 4px;
        background-color: rgba(255, 255, 255, 0);
        padding: 0;
        width: 33px;
        height: 100%;
        vertical-align: middle;
        text-align: center;
        font-size: inherit;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }

    .sbx-custom__submit::before {
        display: inline-block;
        margin-right: -4px;
        height: 100%;
        vertical-align: middle;
        content: '';
    }

    .sbx-custom__submit:hover, .sbx-custom__submit:active {
        cursor: pointer;
    }

    .sbx-custom__submit:focus {
        outline: 0;
    }

    .sbx-custom__submit svg {
        width: 17px;
        height: 17px;
        vertical-align: middle;
        fill: #3A33D1;
    }

    .sbx-custom__reset {
        display: none;
        position: absolute;
        top: 4px;
        right: 4px;
        margin: 0;
        border: 0;
        background: none;
        cursor: pointer;
        padding: 0;
        font-size: inherit;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        fill: rgba(0, 0, 0, 0.5);
    }

    .sbx-custom__reset:focus {
        outline: 0;
    }

    .sbx-custom__reset svg {
        display: block;
        margin: 4px;
        width: 17px;
        height: 17px;
    }

    .sbx-custom__input:valid ~ .sbx-custom__reset {
        display: block;
        -webkit-animation-name: sbx-reset-in;
        animation-name: sbx-reset-in;
        -webkit-animation-duration: .15s;
        animation-duration: .15s;
    }

    @-webkit-keyframes sbx-reset-in {
        0% {
            -webkit-transform: translate3d(-20%, 0, 0);
            transform: translate3d(-20%, 0, 0);
            opacity: 0;
        }
        100% {
            -webkit-transform: none;
            transform: none;
            opacity: 1;
        }
    }

    @keyframes sbx-reset-in {
        0% {
            -webkit-transform: translate3d(-20%, 0, 0);
            transform: translate3d(-20%, 0, 0);
            opacity: 0;
        }
        100% {
            -webkit-transform: none;
            transform: none;
            opacity: 1;
        }
    }
</style>
<div class="book-header" role="navigation">
    
    <a class="book-header-title" href="../..">
        <img class="book-header-title-img" alt="JavaScript Primer"
             src="../../gitbook/icons/icon-128x128.png"/>
        <h2 class="book-header-title-h" title="JavaScript Primer - 迷わないための入門書">JavaScript Primer</h2>
    </a>
    <div class="searchbarWrapper header-center">
        <svg xmlns="http://www.w3.org/2000/svg" style="display:none">
            <symbol xmlns="http://www.w3.org/2000/svg" id="sbx-icon-search-8" viewBox="0 0 40 40">
                <path d="M16 32c8.835 0 16-7.165 16-16 0-8.837-7.165-16-16-16C7.162 0 0 7.163 0 16c0 8.835 7.163 16 16 16zm0-5.76c5.654 0 10.24-4.586 10.24-10.24 0-5.656-4.586-10.24-10.24-10.24-5.656 0-10.24 4.584-10.24 10.24 0 5.654 4.584 10.24 10.24 10.24zM28.156 32.8c-1.282-1.282-1.278-3.363.002-4.643 1.282-1.284 3.365-1.28 4.642-.003l6.238 6.238c1.282 1.282 1.278 3.363-.002 4.643-1.283 1.283-3.366 1.28-4.643.002l-6.238-6.238z"
                      fill-rule="evenodd"></path>
            </symbol>
            <symbol xmlns="http://www.w3.org/2000/svg" id="sbx-icon-clear-5" viewBox="0 0 20 20">
                <path d="M10 20c5.523 0 10-4.477 10-10S15.523 0 10 0 0 4.477 0 10s4.477 10 10 10zm1.35-10.123l3.567 3.568-1.225 1.226-3.57-3.568-3.567 3.57-1.226-1.227 3.568-3.568-3.57-3.57 1.227-1.224 3.568 3.568 3.57-3.567 1.224 1.225-3.568 3.57zM10 18.272c4.568 0 8.272-3.704 8.272-8.272S14.568 1.728 10 1.728 1.728 5.432 1.728 10 5.432 18.272 10 18.272z"
                      fill-rule="evenodd"></path>
            </symbol>
        </svg>

        <form novalidate="novalidate" onsubmit="return false;" class="searchbox sbx-custom">
            <div role="search" class="sbx-custom__wrapper">
                <input name="search" placeholder="Search words" autocomplete="off" required="required"
                       class="sbx-custom__input" type="search">
                <button type="submit" title="Submit your search query." class="sbx-custom__submit">
                    <svg role="img" aria-label="Search">
                        <use xlink:href="#sbx-icon-search-8"></use>
                    </svg>
                </button>
                <button type="reset" title="Clear the search query." class="sbx-custom__reset">
                    <svg role="img" aria-label="Reset">
                        <use xlink:href="#sbx-icon-clear-5"></use>
                    </svg>
                </button>
            </div>
        </form>
    </div>
    <div class="header-right">
        <!-- Icon: https://www.iconfinder.com/iconsets/circle-payment -->
        <a class="amazon-link" title="Amazon: JavaScript Primer 改訂2版 迷わないための入門書"
           href="https://www.amazon.co.jp/dp/4048931105/" target="_blank"><img
                width="22"
                height="22"
                style="margin: 1px;"
                src="../../gitbook/icons/amazon-icon.png" alt=""></a>
        <a class="github-link" title="GitHub: asciidwango/js-primer" href="https://github.com/asciidwango/js-primer"
           target="_blank"><i
                class="fa fa-github fa-fw"></i></a>
    </div>
</div>

<script defer>
    // focus on search box
    document.querySelector(".searchbox [type=\"reset\"]").addEventListener("click", function() {
        this.parentNode.querySelector("input").focus();
    });
    // init DocSearch
    var search = docsearch({
        apiKey: "fd28ebaba94be0c39fb9fa1b2fed4f23", // use a SEARCH-ONLY api key here
        indexName: "asciidwango",
        inputSelector: ".sbx-custom__input",
        debug: false // set to `true` if you want to inspect the dropdown menu's CSS
    });
</script>
<script>
    window.addEventListener("DOMContentLoaded", function() {
        gitbook.events.on("page.change", function() {
            setTimeout(() => console.clear(), 1000);
        });
    });
</script>





                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
<style>
    .page-sponsors {
        background: #fafafa;
    }
    .page-sponsors .page-sponsors-list {
        display: flex;
        justify-content: center;
        align-items: center;
        margin: 0;
        padding: 1em 0;
        list-style: none;
        gap: 8px;
    }
    .page-sponsors-footer {
        text-align: center;
        padding: 0;
        margin: 0;
    }
</style>
<div class="page-sponsors">

    <div class="page-sponsors-footer">
        JavaScript Primerの<a href="https://jsprimer.net/intro/sponsors/">スポンサーを募集中</a>
    </div>

</div>

                                <html><head></head><body><h1 id="string"><a name="string" class="plugin-anchor" href="#string"><i class="fa fa-link" aria-hidden="true"></i></a>文字列 </h1>
<p>この章ではJavaScriptにおける文字列について学んでいきます。
まずは、文字列の作成方法や文字列の操作方法について見ていきます。
そして、文字列を編集して自由に文字列を作れるようになることがこの章の目的です。</p>
<h2 id="create"><a name="create" class="plugin-anchor" href="#create"><i class="fa fa-link" aria-hidden="true"></i></a>文字列を作成する </h2>
<p>文字列を作成するには、文字列リテラルを利用します。
「<a href="../data-type/">データ型とリテラル</a>」の章でも紹介しましたが、文字列リテラルには<code>&quot;</code>（ダブルクォート）、<code>&apos;</code>（シングルクォート）、<code>`</code>（バッククォート）の3種類があります。</p>
<p>まずは<code>&quot;</code>（ダブルクォート）と<code>&apos;</code>（シングルクォート）について見ていきます。</p>
<p><code>&quot;</code>（ダブルクォート）と<code>&apos;</code>（シングルクォート）に意味的な違いはありません。
そのため、どちらを使うかは好みやプロジェクトごとのコーディング規約によって異なります。
この書籍では、<code>&quot;</code>（ダブルクォート）を主な文字列リテラルとして利用します。</p>
<!-- textlint-disable eslint -->
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> double = <span class="hljs-string">&quot;文字列&quot;</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(double); <span class="hljs-comment">// =&gt; &quot;文字列&quot;</span>
<span class="hljs-keyword">const</span> single = <span class="hljs-string">&apos;文字列&apos;</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(single); <span class="hljs-comment">// =&gt; &apos;文字列&apos;</span>
<span class="hljs-comment">// どちらも同じ文字列</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(double === single);<span class="hljs-comment">// =&gt; true</span>
</code></pre>
<!-- textlint-disable ja-technical-writing/sentence-length -->
<p>ES2015では、テンプレートリテラル <code>`</code>（バッククォート）が追加されました。
<code>`</code>（バッククォート）を利用することで文字列を作成できる点は、他の文字列リテラルと同じです。</p>
<!-- textlint-enable ja-technical-writing/sentence-length -->
<p>これに加えてテンプレートリテラルでは、文字列中に改行を入力できます。
次のコードでは、テンプレートリテラルを使って複数行の文字列を見た目どおりに定義しています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> multiline = <span class="hljs-string">`1行目
2行目
3行目`</span>;
<span class="hljs-comment">// \n は改行を意味する</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(multiline); <span class="hljs-comment">// =&gt; &quot;1行目\n2行目\n3行目&quot;</span>
</code></pre>
<!-- textlint-enable eslint -->
<p>どの文字列リテラルでも共通ですが、文字列リテラルは同じ記号が対になります。
そのため、文字列の中にリテラルと同じ記号が出現した場合は、<code>\</code>（バックスラッシュ）を使いエスケープする必要があります。
次のコードでは、文字列中の<code>&quot;</code>を<code>\&quot;</code>のようにエスケープしています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;This book is \&quot;js-primer\&quot;&quot;</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str); <span class="hljs-comment">// =&gt; &apos;This book is &quot;js-primer&quot;&apos;</span>
</code></pre>
<h2 id="escape-sequence"><a name="escape-sequence" class="plugin-anchor" href="#escape-sequence"><i class="fa fa-link" aria-hidden="true"></i></a>エスケープシーケンス </h2>
<p>文字列リテラル中にはそのままでは入力できない特殊な文字もあります。
改行もそのひとつで、<code>&quot;</code>（ダブルクォート）と<code>&apos;</code>（シングルクォート）の文字列リテラルには改行をそのまま入力できません
（テンプレートリテラル中には例外的に改行をそのまま入力できます）。</p>
<p>次のコードは、JavaScriptの構文として正しくないため、構文エラー（SyntaxError）となります。</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// JavaScriptエンジンが構文として解釈できないため、SyntaxErrorとなる</span>
<span class="hljs-keyword">const</span> invalidString = <span class="hljs-string">&quot;1行目
2行目
3行目&quot;</span>;
</code></pre>
<p>この問題を回避するためには、改行のような特殊な文字をエスケープシーケンスとして書く必要があります。
エスケープシーケンスは、<code>\</code>と特定の文字を組み合わせることで、特殊文字を表現します。</p>
<p>次の表では、代表的な<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/String#%E3%82%A8%E3%82%B9%E3%82%B1%E3%83%BC%E3%83%97%E3%82%B7%E3%83%BC%E3%82%B1%E3%83%B3%E3%82%B9" target="_blank">エスケープシーケンス</a>を紹介しています。
エスケープシーケンスは、<code>&quot;</code>（ダブルクォート）、<code>&apos;</code>（シングルクォート）、<code>`</code>（バッククォート）すべての文字列リテラルの中で利用できます。</p>
<table>
<thead>
<tr>
<th>エスケープシーケンス</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\&apos;</code></td>
<td>シングルクォート</td>
</tr>
<tr>
<td><code>\&quot;</code></td>
<td>ダブルクォート</td>
</tr>
<tr>
<td><code>\` </code></td>
<td>バッククォート</td>
</tr>
<tr>
<td><code>\\</code></td>
<td>バックスラッシュ(<code>\</code>そのものを表示する)</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>改行</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>タブ</td>
</tr>
<tr>
<td><code>\uXXXX</code></td>
<td>Code Unit(<code>\u</code>と4桁のHexDigit)</td>
</tr>
<tr>
<td><code>\u{X}</code> ... <code>\u{XXXXXX}</code></td>
<td>Code Point（<code>\u{}</code>のカッコ中にHexDigit）</td>
</tr>
</tbody>
</table>
<p>このエスケープシーケンスを利用することで、先ほどの<code>&quot;</code>（ダブルクォート）の中に改行（<code>\n</code>）を入力できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// 改行を\nのエスケープシーケンスとして入力している</span>
<span class="hljs-keyword">const</span> multiline = <span class="hljs-string">&quot;1行目\n2行目\n3行目&quot;</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(multiline); 
<span class="hljs-comment">/* 改行した結果が出力される
1行目
2行目
3行目
*/</span>
</code></pre>
<p>また、<code>\</code>からはじまる文字は自動的にエスケープシーケンスとして扱われます。
しかし、<code>\a</code>のように定義されていないエスケープシーケンスは、<code>\</code>が単に無視され<code>a</code>という文字列として扱われます。
これにより、<code>\</code>（バックスラッシュ）そのものを入力していたつもりが、その文字がエスケープシーケンスとして扱われてしまう問題があります。</p>
<p>次のコードでは、<code>\_</code>という組み合わせのエスケープシーケンスはないため、<code>\</code>が無視された文字列として評価されます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;¯\_(ツ)_/¯&quot;</span>);
<span class="hljs-comment">// ¯_(ツ)_/¯ のように\が無視されて表示される</span>
</code></pre>
<p><code>\</code>（バックスラッシュ）そのものを入力したい場合は、<code>\\</code>のようにエスケープする必要があります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;¯\\_(ツ)_/¯&quot;</span>);
<span class="hljs-comment">//　¯\_(ツ)_/¯ と表示される</span>
</code></pre>
<!-- Note: https://tc39.es/ecma262/#prod-NonEscapeCharacter

- 指定外の組み合わせもNonEscapeCharacterとして扱われ構文的には無害
- 単純に \ がないように使われる。

 -->
<h2 id="concat"><a name="concat" class="plugin-anchor" href="#concat"><i class="fa fa-link" aria-hidden="true"></i></a>文字列を結合する </h2>
<p>文字列を結合する簡単な方法は文字列結合演算子（<code>+</code>）を使う方法です。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str); <span class="hljs-comment">// =&gt; &quot;ab&quot;</span>
</code></pre>
<p>変数と文字列を結合したい場合も文字列結合演算子で行えます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;JavaScript&quot;</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello &quot;</span> + name + <span class="hljs-string">&quot;!&quot;</span>);<span class="hljs-comment">// =&gt; &quot;Hello JavaScript!&quot;</span>
</code></pre>
<p>特定の書式に文字列を埋め込むには、テンプレートリテラルを使うとより宣言的に書けます。</p>
<p>テンプレートリテラル中に<code>${変数名}</code>で書かれた変数は評価時に展開されます。
つまり、先ほどの文字列結合は次のように書けます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;JavaScript&quot;</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>!`</span>);<span class="hljs-comment">// =&gt; &quot;Hello JavaScript!&quot;</span>
</code></pre>
<h2 id="get-char"><a name="get-char" class="plugin-anchor" href="#get-char"><i class="fa fa-link" aria-hidden="true"></i></a>文字へのアクセス </h2>
<p>文字列の特定の位置にある文字にはインデックスを指定してアクセスできます。
これは、配列における要素へのアクセスにインデックスを指定するのと同じです。</p>
<p>文字列では<code>文字列[インデックス]</code>のように指定した位置（インデックス）の文字へアクセスできます。
インデックスの値は<code>0</code>以上<code>2^53 - 1</code>未満の整数が指定できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;文字列&quot;</span>;
<span class="hljs-comment">// 配列と同じようにインデックスでアクセスできる</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str[<span class="hljs-number">0</span>]); <span class="hljs-comment">// =&gt; &quot;文&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str[<span class="hljs-number">1</span>]); <span class="hljs-comment">// =&gt; &quot;字&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str[<span class="hljs-number">2</span>]); <span class="hljs-comment">// =&gt; &quot;列&quot;</span>
</code></pre>
<p>また、存在しないインデックスへのアクセスでは配列やオブジェクトと同じように<code>undefined</code>を返します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;文字列&quot;</span>;
<span class="hljs-comment">// 42番目の要素は存在しない</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str[<span class="hljs-number">42</span>]); <span class="hljs-comment">// =&gt; undefined</span>
</code></pre>
<h3 id="string-at"><a name="string-at" class="plugin-anchor" href="#string-at"><i class="fa fa-link" aria-hidden="true"></i></a>[ES2022] <code>String.prototype.at</code> </h3>
<p>ES2022から<code>String.prototype.at</code>メソッドが追加されています。
Stringの<code>at</code>メソッドは、Arrayの<code>at</code>メソッドと同じく、相対的なインデックスを渡してその位置の文字へアクセスできます。
<code>at</code>メソッドへ<code>-1</code>のようにマイナスのインデックスを渡した場合は、末尾から数えた位置の文字へアクセスできます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2022" } --></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;文字列&quot;</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">at</span>(<span class="hljs-number">0</span>)); <span class="hljs-comment">// =&gt; &quot;文&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">at</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// =&gt; &quot;字&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">at</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// =&gt; &quot;列&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">at</span>(-<span class="hljs-number">1</span>)); <span class="hljs-comment">// =&gt; &quot;列&quot;</span>
</code></pre>
<h2 id="what-is-string"><a name="what-is-string" class="plugin-anchor" href="#what-is-string"><i class="fa fa-link" aria-hidden="true"></i></a>文字列とは </h2>
<p>今まで何気なく「文字列」という言葉を利用していましたが、ここでいう文字列とはどのようなものでしょうか？　コンピュータのメモリ上に文字列の「ア」といった文字をそのまま保存できないため、0と1からなるビット列へ変換する必要があります。
この文字からビット列へ変換することを符号化（エンコード）と呼びます。</p>
<p>一方で、変換後のビット列が何の文字なのかを管理する表が必要になります。
この文字に対応するIDの一覧表のことを符号化文字集合と呼びます。</p>
<p>次の表は、Unicodeという文字コードにおける符号化文字集合からカタカナの一部分を取り出したものです。<sup><a href="#fn_1" id="reffn_1">1</a></sup>
Unicodeはすべての文字に対してID（Code Point）を振ることを目的に作成されている仕様です。</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
</tr>
</thead>
<tbody>
<tr>
<td>30A0</td>
<td>゠</td>
<td>ァ</td>
<td>ア</td>
<td>ィ</td>
<td>イ</td>
<td>ゥ</td>
<td>ウ</td>
<td>ェ</td>
<td>エ</td>
<td>ォ</td>
<td>オ</td>
<td>カ</td>
<td>ガ</td>
<td>キ</td>
<td>ギ</td>
<td>ク</td>
</tr>
<tr>
<td>30B0</td>
<td>グ</td>
<td>ケ</td>
<td>ゲ</td>
<td>コ</td>
<td>ゴ</td>
<td>サ</td>
<td>ザ</td>
<td>シ</td>
<td>ジ</td>
<td>ス</td>
<td>ズ</td>
<td>セ</td>
<td>ゼ</td>
<td>ソ</td>
<td>ゾ</td>
<td>タ</td>
</tr>
<tr>
<td>30C0</td>
<td>ダ</td>
<td>チ</td>
<td>ヂ</td>
<td>ッ</td>
<td>ツ</td>
<td>ヅ</td>
<td>テ</td>
<td>デ</td>
<td>ト</td>
<td>ド</td>
<td>ナ</td>
<td>ニ</td>
<td>ヌ</td>
<td>ネ</td>
<td>ノ</td>
<td>ハ</td>
</tr>
</tbody>
</table>
<p>JavaScript（ECMAScript）は文字コードとしてUnicodeを採用し、文字をエンコードする方式としてUTF-16を採用しています。
UTF-16とは、それぞれの文字を16ビットのビット列に変換するエンコード方式です。
Unicodeでは1文字を表すのに使う最小限のビットの組み合わせを<strong>Code Unit</strong>（符号単位）と呼び、UTF-16では各Code Unitのサイズが16ビット（2バイト）です。</p>
<!--
- 用語集: http://unicode.org/glossary/
- 比較表: http://unicode.org/faq/utf_bom.html#gen6
 -->
<p>次のコードは、文字列を構成するCode Unitをhex値（16進数）にして表示する例です。
Stringの<code>charCodeAt</code>メソッドは、文字列の指定インデックスのCode Unitを整数として返します。
そのCode Unitの整数値をNumberの<code>toString</code>メソッドでhex値（16進数）にしています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;アオイ&quot;</span>;
<span class="hljs-comment">// それぞれの文字をCode Unitのhex値（16進数）に変換する</span>
<span class="hljs-comment">// toStringの引数に16を渡すと16進数に変換される</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>)); <span class="hljs-comment">// =&gt; &quot;30a2&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>)); <span class="hljs-comment">// =&gt; &quot;30aa&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>));  <span class="hljs-comment">// =&gt; &quot;30a4&quot;</span>
</code></pre>
<p>逆に、Code Unitをhex値（16進数）から文字へと変換するには<code>String.fromCharCode</code>メソッドを使います。
次のコードでは、16進数の整数リテラルである<code>0x</code>で記述したCode Unitから文字列へと変換しています
（<code>0x</code>リテラルについては「<a href="../data-type/">データ型とリテラル</a>」の章を参照）。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> str = <span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCharCode</span>(
    <span class="hljs-number">0x30a2</span>, <span class="hljs-comment">// アのCode Unit</span>
    <span class="hljs-number">0x30aa</span>, <span class="hljs-comment">// オのCode Unit</span>
    <span class="hljs-number">0x30a4</span>  <span class="hljs-comment">// イのCode Unit</span>
);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str); <span class="hljs-comment">// =&gt; &quot;アオイ&quot;</span>
</code></pre>
<p>これらの結果をまとめると、この文字列と文字列を構成するUTF-16のCode Unitとの関係は次のようになります。</p>
<table>
<thead>
<tr>
<th>インデックス</th>
<th>0</th>
<th>1</th>
<th>2</th>
</tr>
</thead>
<tbody>
<tr>
<td>文字列</td>
<td>ア</td>
<td>オ</td>
<td>イ</td>
</tr>
<tr>
<td>UTF-16のCode Unit（16進数）</td>
<td>0x30A2</td>
<td>0x30AA</td>
<td>0x30A4</td>
</tr>
</tbody>
</table>
<p>このように、JavaScriptにおける文字列は16ビットのCode Unitが順番に並んだものとして内部的に管理されています。
これは、ECMAScriptの内部表現としてUTF-16を採用しているだけで、JavaScriptファイル（ソースコードを書いたファイル）のエンコーディングとは関係ありません。そのため、JavaScriptファイル自体のエンコードは、UTF-16以外の文字コードであっても問題ありません。</p>
<p>UTF-16を利用していることはJavaScriptの内部的な表現であるため、気にする必要がないようにも思えます。
しかし、このJavaScriptがUTF-16を利用していることは、これから見ていくStringのAPIにも影響しています。
このUTF-16と文字列については、次の章である「<a href="../string-unicode/">文字列とUnicode</a>」で詳しく見ていきます。</p>
<p>ここでは、「JavaScriptの文字列の各要素はUTF-16のCode Unitで構成されている」ということだけを覚えておけば問題ありません。</p>
<h2 id="split-join"><a name="split-join" class="plugin-anchor" href="#split-join"><i class="fa fa-link" aria-hidden="true"></i></a>文字列の分解と結合 </h2>
<p>文字列を配列へ分解するにはStringの<code>split</code>メソッドを利用できます。
一方、配列の要素を結合して文字列にするにはArrayの<code>join</code>メソッドを利用できます。</p>
<p>この２つはよく組み合わせて利用されるため、合わせて見ていきます。</p>
<p>Stringの<code>split</code>メソッドは、第一引数に指定した区切り文字で文字列を分解した配列を返します。
次のコードでは、文字列を<code>・</code>で区切った配列を作成しています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> strings = <span class="hljs-string">&quot;赤・青・緑&quot;</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;・&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(strings); <span class="hljs-comment">// =&gt; [&quot;赤&quot;, &quot;青&quot;, &quot;緑&quot;]</span>
</code></pre>
<p>分解してできた文字列の配列を結合して文字列を作る際に、Arrayの<code>join</code>メソッドが利用できます。
Arrayの<code>join</code>メソッドの第一引数には区切り文字を指定し、その区切り文字で結合した文字列を返します。</p>
<p>この２つを合わせれば、区切り文字を<code>・</code>から<code>、</code>へ変換する処理を次のように書くことができます。
<code>・</code>で文字列を分割（<code>split</code>）してから、区切り文字を<code>、</code>にして結合（<code>join</code>）すれば変換できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;赤・青・緑&quot;</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;・&quot;</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;、&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str); <span class="hljs-comment">// =&gt; &quot;赤、青、緑&quot;</span>
</code></pre>
<p>Stringの<code>split</code>メソッドの第一引数には正規表現も指定できます。
これを利用すると、次のように文字列をスペースで区切るような処理を簡単に書けます。
<code>/\s+/</code>は1つ以上のスペースにマッチする正規表現オブジェクトを作成する正規表現リテラルです。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// 文字間に1つ以上のスペースがある</span>
<span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;a     b    c      d&quot;</span>;
<span class="hljs-comment">// 1つ以上のスペースにマッチして分解する</span>
<span class="hljs-keyword">const</span> strings = str.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/\s+/</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(strings); <span class="hljs-comment">// =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
</code></pre>
<h2 id="length"><a name="length" class="plugin-anchor" href="#length"><i class="fa fa-link" aria-hidden="true"></i></a>文字列の長さ </h2>
<p>Stringの<code>length</code>プロパティは文字列の要素数を返します。
文字列の構成要素はCode Unitであるため、<code>length</code>プロパティはCode Unitの個数を返します。</p>
<p>次の文字列は3つの要素（Code Unit）が並んだものであるため、<code>length</code>プロパティは<code>3</code>を返します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;文字列&quot;</span>.<span class="hljs-property">length</span>); <span class="hljs-comment">// =&gt; 3</span>
</code></pre>
<p>また、空文字列は要素数が<code>0</code>であるため、<code>length</code>プロパティの結果も<code>0</code>となります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;&quot;</span>.<span class="hljs-property">length</span>); <span class="hljs-comment">// =&gt; 0</span>
</code></pre>
<h2 id="compare"><a name="compare" class="plugin-anchor" href="#compare"><i class="fa fa-link" aria-hidden="true"></i></a>文字列の比較 </h2>
<p>文字列の比較には<code>===</code>（厳密比較演算子）を利用します。
次の条件を満たしていれば同じ文字列となります。</p>
<ul>
<li>文字列の要素であるCode Unitが同じ順番で並んでいるか</li>
<li>文字列の長さ（length）は同じか</li>
</ul>
<p>難しく書いていますが、同じ文字列同士なら<code>===</code>（厳密比較演算子）の結果は<code>true</code>となります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;文字列&quot;</span> === <span class="hljs-string">&quot;文字列&quot;</span>); <span class="hljs-comment">// =&gt; true</span>
<span class="hljs-comment">// 一致しなければfalseとなる</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;JS&quot;</span> === <span class="hljs-string">&quot;ES&quot;</span>); <span class="hljs-comment">// =&gt; false</span>
<span class="hljs-comment">// 文字列の長さが異なるのでfalseとなる</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;文字列&quot;</span> === <span class="hljs-string">&quot;文字&quot;</span>); <span class="hljs-comment">// =&gt; false</span>
</code></pre>
<p>また、<code>===</code>などの比較演算子だけではなく、
<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>など大小の関係演算子で文字列同士の比較もできます。</p>
<p>これらの関係演算子も、文字列の要素であるCode Unit同士を先頭から順番に比較します。
文字列からCode Unitの数値を取得するには、Stringの<code>charCodeAt</code>メソッドを利用できます。</p>
<p>次のコードでは、<code>ABC</code>と<code>ABD</code>を比較した場合にどちらが大きい（Code Unitの値が大きい）かを比較しています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// &quot;A&quot;と&quot;B&quot;のCode Unitは65と66</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;A&quot;</span>.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">0</span>)); <span class="hljs-comment">// =&gt; 65</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;B&quot;</span>.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">0</span>)); <span class="hljs-comment">// =&gt; 66</span>
<span class="hljs-comment">// &quot;A&quot;（65）は&quot;B&quot;（66）よりCode Unitの値が小さい</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;A&quot;</span> &gt; <span class="hljs-string">&quot;B&quot;</span>); <span class="hljs-comment">// =&gt; false</span>
<span class="hljs-comment">// 先頭から順番に比較し C &gt; D が falseであるため</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;ABC&quot;</span> &gt; <span class="hljs-string">&quot;ABD&quot;</span>); <span class="hljs-comment">// =&gt; false</span>
</code></pre>
<p>このように、関係演算子での文字列比較はCode Unit同士を比較しています。
この結果を予測することは難しく、また直感的ではない結果が生まれることも多いです。
文字の順番は国や言語によっても異なるため、国際化（Internationalization）に関する知識も必要です。</p>
<p>JavaScriptにおいても、<a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-402/" title="Standard ECMA-402" target="_blank">ECMA-402</a>というECMAScriptと関連する別の仕様として国際化についての取り決めがされています。
この国際化に関するAPIを定義した<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Intl" target="_blank">Intl</a>というビルトインオブジェクトもありますが、このAPIについての詳細は省略します。</p>
<h2 id="slice"><a name="slice" class="plugin-anchor" href="#slice"><i class="fa fa-link" aria-hidden="true"></i></a>文字列の一部を取得 </h2>
<p>文字列からその一部を取り出したい場合には、Stringの<code>slice</code>メソッドや<code>substring</code>メソッドが利用できます。</p>
<p><code>slice</code>メソッドについては、すでに配列で学んでいますが、基本的な動作は文字列でも同様です。
まずは<code>slice</code>メソッドについて見ていきます。</p>
<!-- textlint-disable ja-technical-writing/max-ten -->
<p>Stringの<code>slice</code>メソッドは、第一引数の開始位置から第二引数の終了位置（終了位置の要素は含まない）までの範囲を取り出した新しい文字列を返します。
第二引数は省略でき、省略した場合は文字列の末尾まで含んだ新しい文字列を返します。</p>
<!-- textlint-enable ja-technical-writing/max-ten -->
<p>位置にマイナスの値を指定した場合は文字列の末尾から数えた位置となります。
また、第一引数の位置が第二引数の位置より大きい場合、常に空の文字列を返します。</p>
<p>そのため、メソッドの引数の扱い方は<a href="../array/#slice">配列の<code>slice</code>メソッド</a>と同様です。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;ABCDE&quot;</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// =&gt; &quot;BCDE&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)); <span class="hljs-comment">// =&gt; &quot;BCDE&quot;</span>
<span class="hljs-comment">// マイナスを指定すると後ろからの位置となる</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">slice</span>(-<span class="hljs-number">1</span>)); <span class="hljs-comment">// =&gt; &quot;E&quot;</span>
<span class="hljs-comment">// インデックスが1から4の範囲を取り出す</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// =&gt; &quot;BCD&quot;</span>
<span class="hljs-comment">// 第一引数 &gt; 第二引数の場合、常に空文字列を返す</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>)); <span class="hljs-comment">// =&gt; &quot;&quot;</span>
</code></pre>
<p>Stringの<code>substring</code>メソッドは、<code>slice</code>メソッドと同じく第一引数に開始位置、第二引数に終了位置を指定し、その範囲を取り出して新しい文字列を返します。
第二引数を省略した場合の挙動も同様で、省略した場合は文字列の末尾が終了位置となります。</p>
<p><code>slice</code>メソッドとは異なる点として、位置にマイナスの値を指定した場合は常に<code>0</code>として扱われます。
また、第一引数の位置が第二引数の位置より大きい場合、第一引数と第二引数が入れ替わるという予想しにくい挙動となります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;ABCDE&quot;</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// =&gt; &quot;BCDE&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)); <span class="hljs-comment">// =&gt; &quot;BCDE&quot;</span>
<span class="hljs-comment">// マイナスを指定すると0として扱われる</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">substring</span>(-<span class="hljs-number">1</span>)); <span class="hljs-comment">// =&gt; &quot;ABCDE&quot;</span>
<span class="hljs-comment">// 位置:1から4の範囲を取り出す</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// =&gt; &quot;BCD&quot;</span>
<span class="hljs-comment">// 第一引数 &gt; 第二引数の場合、引数が入れ替わる</span>
<span class="hljs-comment">// str.substring(1, 4)と同じ結果になる</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>)); <span class="hljs-comment">// =&gt; &quot;BCD&quot;</span>
</code></pre>
<p>このように、マイナスの位置や引数が交換される挙動はわかりやすいものとは言えません。
そのため、<code>slice</code>メソッドと<code>substring</code>メソッドに指定する引数は、どちらとも同じ結果となる範囲に限定したほうが直感的な挙動となります。
つまり、指定するインデックスは0以上にして、第二引数を指定する場合は<code>第一引数の位置 &lt; 第二引数の位置</code>にするということです。</p>
<p>Stringの<code>slice</code>メソッドは、<code>indexOf</code>メソッドなどの位置を取得するものと組み合わせて使うことが多いでしょう。
次のコードでは、<code>?</code>の位置を<code>indexOf</code>メソッドで取得し、それ以降の文字列を<code>slice</code>メソッドで切り出しています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> url = <span class="hljs-string">&quot;https://example.com?param=1&quot;</span>;
<span class="hljs-keyword">const</span> indexOfQuery = url.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;?&quot;</span>);
<span class="hljs-keyword">const</span> queryString = url.<span class="hljs-title function_">slice</span>(indexOfQuery);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(queryString); <span class="hljs-comment">// =&gt; &quot;?param=1&quot;</span>
</code></pre>
<p>また、配列とは異なりプリミティブ型の値である文字列は、<code>slice</code>メソッドと<code>substring</code>メソッド共に非破壊的です。
機能的な違いがほとんどないため、どちらを利用するかは好みの問題となるでしょう。</p>
<h2 id="search"><a name="search" class="plugin-anchor" href="#search"><i class="fa fa-link" aria-hidden="true"></i></a>文字列の検索 </h2>
<p>文字列の検索方法として、大きく分けて文字列による検索と正規表現による検索があります。</p>
<p>指定した文字列が文字列中に含まれているかを検索する方法として、Stringメソッドには取得したい結果ごとにメソッドが用意されています。
ここでは、次の3種類の結果を取得する方法について文字列と正規表現それぞれの検索方法を見ていきます。</p>
<ul>
<li>マッチした箇所のインデックスを取得</li>
<li>マッチした文字列の取得</li>
<li>マッチしたかどうかの真偽値を取得</li>
</ul>
<!-- Note: 検索はある目的を持って探すこと、探索は目的外の有益な情報も探すことを含んでいる -->
<!-- ここでは目的が決まっているので"検索" -->
<!-- http://www.st38.net/chigaino-zatugaku/z0174.html -->
<h3 id="search-by-string"><a name="search-by-string" class="plugin-anchor" href="#search-by-string"><i class="fa fa-link" aria-hidden="true"></i></a>文字列による検索 </h3>
<p><code>String</code>オブジェクトには、指定した文字列で検索するメソッドが用意されています。</p>
<h4 id="search-index-by-string"><a name="search-index-by-string" class="plugin-anchor" href="#search-index-by-string"><i class="fa fa-link" aria-hidden="true"></i></a>文字列によるインデックスの取得 </h4>
<p>Stringの<code>indexOf</code>メソッドと<code>lastIndexOf</code>メソッドは、指定した文字列で検索し、その文字列が最初に現れたインデックスを返します。
これらは配列のArrayの<code>indexOf</code>メソッドと同じで、厳密等価演算子（<code>===</code>）で文字列を検索します。
一致する文字列がない場合は<code>-1</code>を返します。</p>
<ul>
<li><code>文字列.indexOf(&quot;検索文字列&quot;)</code>: 先頭から検索し、指定された文字列が最初に現れたインデックスを返す</li>
<li><code>文字列.lastIndexOf(&quot;検索文字列&quot;)</code>: 末尾から検索し、指定された文字列が最初に現れたインデックスを返す</li>
</ul>
<p>どちらのメソッドも一致する文字列が複数個ある場合でも、指定した検索文字列を最初に見つけた時点で検索は終了します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// 検索対象となる文字列</span>
<span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;にわにはにわにわとりがいる&quot;</span>;
<span class="hljs-comment">// indexOfは先頭から検索しインデックスを返す - &quot;**にわ**にはにわにわとりがいる&quot;</span>
<span class="hljs-comment">// &quot;にわ&quot;の先頭のインデックスを返すため 0 となる</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;にわ&quot;</span>)); <span class="hljs-comment">// =&gt; 0</span>
<span class="hljs-comment">// lastIndexOfは末尾から検索しインデックスを返す- &quot;にわにはにわ**にわ**とりがいる&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&quot;にわ&quot;</span>)); <span class="hljs-comment">// =&gt; 6</span>
<span class="hljs-comment">// 指定した文字列が見つからない場合は -1 を返す</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;未知のキーワード&quot;</span>)); <span class="hljs-comment">// =&gt; -1</span>
</code></pre>
<h3 id="match-by-string"><a name="match-by-string" class="plugin-anchor" href="#match-by-string"><i class="fa fa-link" aria-hidden="true"></i></a>文字列にマッチした文字列の取得 </h3>
<p>文字列を検索してマッチした文字列は、検索文字列そのものになるので自明です。</p>
<p>次のコードでは<code>&quot;Script&quot;</code>という文字列で検索していますが、その検索文字列にマッチする文字列はもちろん<code>&quot;Script&quot;</code>になります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;JavaScript&quot;</span>;
<span class="hljs-keyword">const</span> searchWord = <span class="hljs-string">&quot;Script&quot;</span>;
<span class="hljs-keyword">const</span> index = str.<span class="hljs-title function_">indexOf</span>(searchWord);
<span class="hljs-keyword">if</span> (index !== -<span class="hljs-number">1</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${searchWord}</span>が見つかりました`</span>);
} <span class="hljs-keyword">else</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${searchWord}</span>は見つかりませんでした`</span>);
}
</code></pre>
<h4 id="test-by-string"><a name="test-by-string" class="plugin-anchor" href="#test-by-string"><i class="fa fa-link" aria-hidden="true"></i></a>真偽値の取得 </h4>
<p>「文字列」に「検索文字列」が含まれているかを検索する方法がいくつか用意されています。
次の3つのメソッドはES2015で導入されました。</p>
<ul>
<li><code>String.prototype.startsWith(検索文字列)</code><sup>[ES2015]</sup>: 検索文字列が先頭にあるかの真偽値を返す</li>
<li><code>String.prototype.endsWith(検索文字列)</code><sup>[ES2015]</sup>: 検索文字列が末尾にあるかの真偽値を返す</li>
<li><code>String.prototype.includes(検索文字列)</code><sup>[ES2015]</sup>: 検索文字列を含むかの真偽値を返す</li>
</ul>
<p>具体的な例をいくつか見てみましょう。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// 検索対象となる文字列</span>
<span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;にわにはにわにわとりがいる&quot;</span>;
<span class="hljs-comment">// startsWith - 検索文字列が先頭ならtrue</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&quot;にわ&quot;</span>)); <span class="hljs-comment">// =&gt; true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&quot;いる&quot;</span>)); <span class="hljs-comment">// =&gt; false</span>
<span class="hljs-comment">// endsWith - 検索文字列が末尾ならtrue</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&quot;にわ&quot;</span>)); <span class="hljs-comment">// =&gt; false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&quot;いる&quot;</span>)); <span class="hljs-comment">// =&gt; true</span>
<span class="hljs-comment">// includes - 検索文字列が含まれるならtrue</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;にわ&quot;</span>)); <span class="hljs-comment">// =&gt; true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;いる&quot;</span>)); <span class="hljs-comment">// =&gt; true</span>
</code></pre>
<h2 id="regexp-object"><a name="regexp-object" class="plugin-anchor" href="#regexp-object"><i class="fa fa-link" aria-hidden="true"></i></a>正規表現オブジェクト </h2>
<!-- パターンと正規表現オブジェクトの用語については https://github.com/asciidwango/js-primer/issues/21#issuecomment-293502813 -->
<p>文字列による検索では、固定の文字列にマッチするものしか検索できません。
一方で正規表現による検索では、あるパターン（規則性）にマッチするという柔軟な検索ができます。</p>
<p>正規表現は正規表現オブジェクト（<code>RegExp</code>オブジェクト）として表現されます。
正規表現オブジェクトはマッチする範囲を決める<code>パターン</code>と正規表現の検索モードを指定する<code>フラグ</code>の2つで構成されます。
正規表現のパターン内では、次の文字は<strong>特殊文字</strong>と呼ばれ、特別な意味を持ちます。特殊文字として解釈されないように入力する場合には<code>\</code>（バックスラッシュ）でエスケープする必要があります。</p>
<pre><code>\ ^ $ . * + ? ( ) [ ] { } |
</code></pre><p>正規表現オブジェクトを作成するには、正規表現リテラルと<code>RegExp</code>コンストラクタを使う2つの方法があります。</p>
<!-- textlint-disable eslint -->
<!-- doctest:disable -->
<pre><code class="lang-js"><span class="hljs-comment">// 正規表現リテラルで正規表現オブジェクトを作成</span>
<span class="hljs-keyword">const</span> patternA = <span class="hljs-regexp">/パターン/</span>フラグ;
<span class="hljs-comment">// `RegExp`コンストラクタで正規表現オブジェクトを作成</span>
<span class="hljs-keyword">const</span> patternB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot;パターン文字列&quot;</span>, <span class="hljs-string">&quot;フラグ&quot;</span>);
</code></pre>
<!-- textlint-enable eslint -->
<p>正規表現リテラルは、<code>/</code>と<code>/</code>のリテラル内に正規表現のパターンを書くことで、正規表現オブジェクトを作成できます。
次のコードでは、<code>+</code>という1回以上の繰り返しを意味する特殊文字を使い、<code>a</code>が1回以上連続する文字列にマッチする正規表現オブジェクトを作成しています。</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/a+/</span>;
</code></pre>
<p>正規表現オブジェクトを作成するもうひとつの方法として<code>RegExp</code>コンストラクタがあります。
<code>RegExp</code>コンストラクタでは、文字列から正規表現オブジェクトを作成できます。</p>
<p>次のコードでは、<code>RegExp</code>コンストラクタを使って<code>a</code>が1文字以上連続している文字列にマッチする正規表現オブジェクトを作成しています。
これは先ほどの正規表現リテラルで作成した正規表現オブジェクトと同じ意味になります。</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> pattern = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot;a+&quot;</span>);
</code></pre>
<h3 id="difference-regexp-literal-regexp-constructor"><a name="difference-regexp-literal-regexp-constructor" class="plugin-anchor" href="#difference-regexp-literal-regexp-constructor"><i class="fa fa-link" aria-hidden="true"></i></a>正規表現リテラルと<code>RegExp</code>コンストラクタの違い </h3>
<!-- 評価とコンパイルは仕様から来てる用語 https://tc39.es/ecma262/#sec-pattern -->
<p>正規表現リテラルと<code>RegExp</code>コンストラクタの違いとして、正規表現のパターンが評価されるタイミングの違いがあります。
正規表現リテラルは、ソースコードをロード（パース）した段階で正規表現のパターンが評価されます。
一方で、<code>RegExp</code>コンストラクタでは通常の関数と同じように、<code>RegExp</code>コンストラクタを呼び出すまで正規表現のパターンは評価されません。</p>
<p>単独の<code>[</code>という不正なパターンである正規表現を例に、評価されているタイミングの違いを見てみます。
<code>[</code>は対になる<code>]</code>と組み合わせて利用する特殊文字であるため、正規表現のパターンに単独で書くと構文エラーの例外が発生します。</p>
<p>正規表現リテラルは、ソースコードのロード時に正規表現のパターンが評価されるため、
次のように<code>main</code>関数を呼び出していなくても構文エラー（<code>SyntaxError</code>）が発生します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-javascript"><span class="hljs-comment">// 正規表現リテラルはロード時にパターンが評価され、例外が発生する</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// `[`は対となる`]`を組み合わせる特殊文字であるため、単独で書けない</span>
    <span class="hljs-keyword">const</span> invalidPattern = <span class="hljs-regexp">/[/;
}

// `main`関数を呼び出さなくても例外が発生する
</span></code></pre>
<p>一方で、<code>RegExp</code>コンストラクタは実行時に正規表現のパターンが評価されるため、
<code>main</code>関数を呼び出すことで初めて構文エラー（<code>SyntaxError</code>）が発生します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-javascript"><span class="hljs-comment">// `RegExp`コンストラクタは実行時にパターンが評価され、例外が発生する</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// `[`は対となる`]`を組み合わせる特殊文字であるため、単独で書けない</span>
    <span class="hljs-keyword">const</span> invalidPattern = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot;[&quot;</span>);
}

<span class="hljs-comment">// `main`関数を呼び出すことで初めて例外が発生する</span>
<span class="hljs-title function_">main</span>();
</code></pre>
<p>これを言い換えると、正規表現リテラルはコードを書いた時点で決まったパターンの正規表現オブジェクトを作成する構文です。
一方で、<code>RegExp</code>コンストラクタは変数と組み合わせるなど、実行時に変わることがあるパターンの正規表現オブジェクトを作成できます。</p>
<p>例として、指定個数のホワイトスペース（空白文字）が連続した場合にマッチする正規表現オブジェクトで比較してみます。</p>
<p>次のコードでは、正規表現リテラルを使って3つ連続するホワイトスペースにマッチする正規表現オブジェクトを作成しています。
<code>\s</code>はスペースやタブなどのホワイトスペースにマッチする特殊文字です。
また、<code>{数字}</code>は指定した回数だけ繰り返しを意味する特殊文字です。</p>
<pre><code class="lang-js"><span class="hljs-comment">// 3つの連続するスペースなどにマッチする正規表現</span>
<span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/\s{3}/</span>;
</code></pre>
<p>正規表現リテラルは、ロード時に正規表現のパターンが評価されるため、<code>\s</code>の連続する回数を動的に変更することはできません。
一方で、<code>RegExp</code>コンストラクタは、実行時に正規表現のパターンが評価されるため、変数を含んだ正規表現オブジェクトを作成できます。</p>
<p>次のコードでは、<code>RegExp</code>コンストラクタで変数<code>spaceCount</code>の数だけ連続するホワイトスペースにマッチする正規表現オブジェクトを作成しています。
注意点として、<code>\</code>（バックスラッシュ）自体が、文字列中ではエスケープ文字であることに注意してください。
そのため、<code>RegExp</code>コンストラクタの引数のパターン文字列では、バックスラッシュからはじまる特殊文字は<code>\</code>（バックスラッシュ）自体をエスケープする必要があります。</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> spaceCount = <span class="hljs-number">3</span>;
<span class="hljs-comment">// `/\s{3}/`の正規表現を文字列から作成する</span>
<span class="hljs-comment">// &quot;\&quot;がエスケープ文字であるため、&quot;\&quot;自身を文字列として書くには、&quot;\\&quot;のように2つ書く</span>
<span class="hljs-keyword">const</span> pattern = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`\\s{<span class="hljs-subst">${spaceCount}</span>}`</span>);
</code></pre>
<p>このように、<code>RegExp</code>コンストラクタは文字列から正規表現オブジェクトを作成できますが、特殊文字のエスケープが必要となります。
そのため、正規表現リテラルで表現できる場合は、リテラルを利用したほうが簡潔でパフォーマンスもよいです。
正規表現のパターンに変数を利用する場合などは、<code>RegExp</code>コンストラクタを利用します。</p>
<h3 id="search-by-regexp"><a name="search-by-regexp" class="plugin-anchor" href="#search-by-regexp"><i class="fa fa-link" aria-hidden="true"></i></a>正規表現による検索 </h3>
<p>正規表現による検索は、正規表現オブジェクトと対応した<code>String</code>オブジェクトまたは<code>RegExp</code>オブジェクトのメソッドを利用します。</p>
<h4 id="search-index-by-regexp"><a name="search-index-by-regexp" class="plugin-anchor" href="#search-index-by-regexp"><i class="fa fa-link" aria-hidden="true"></i></a>正規表現によるインデックスの取得 </h4>
<p>Stringの<code>indexOf</code>メソッドの正規表現版ともいえるStringの<code>search</code>メソッドがあります。
<code>search</code>メソッドは正規表現のパターンにマッチした箇所のインデックスを返し、マッチする文字列がない場合は<code>-1</code>を返します。</p>
<ul>
<li><code>String.prototype.indexOf(検索文字列)</code>: 指定された文字列にマッチした箇所のインデックスを返す</li>
<li><code>String.prototype.search(/パターン/)</code>: 指定された正規表現のパターンにマッチした箇所のインデックスを返す</li>
</ul>
<p>次のコードでは、数字が3つ連続しているかを検索し、該当した箇所のインデックスを返しています。
<code>\d</code>は、1文字の数字（<code>0</code>から<code>9</code>）にマッチする特殊文字です。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;ABC123EFG&quot;</span>;
<span class="hljs-keyword">const</span> searchPattern = <span class="hljs-regexp">/\d{3}/</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">search</span>(searchPattern)); <span class="hljs-comment">// =&gt; 3</span>
</code></pre>
<h4 id="match-by-regexp"><a name="match-by-regexp" class="plugin-anchor" href="#match-by-regexp"><i class="fa fa-link" aria-hidden="true"></i></a>正規表現によるマッチした文字列の取得 </h4>
<p>文字列による検索では、検索した文字列そのものがマッチした文字列になります。
しかし、<code>search</code>メソッドの正規表現による検索は、正規表現パターンによる検索であるため、検索してマッチした文字列の長さは固定ではありません。
つまり、次のようにStringの<code>search</code>メソッドでマッチしたインデックスのみを取得しても、実際にマッチした文字列がわかりません。</p>
<!-- doctest:disable -->
<pre><code class="lang-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;abc123def&quot;</span>;
<span class="hljs-comment">// 連続した数字にマッチする正規表現</span>
<span class="hljs-keyword">const</span> searchPattern = <span class="hljs-regexp">/\d+/</span>;
<span class="hljs-keyword">const</span> index = str.<span class="hljs-title function_">search</span>(searchPattern); <span class="hljs-comment">// =&gt; 3</span>
<span class="hljs-comment">// `index` だけではマッチした文字列の長さがわからない</span>
str.<span class="hljs-title function_">slice</span>(index, index + マッチした文字列の長さ); <span class="hljs-comment">// マッチした文字列は取得できない</span>
</code></pre>
<p>そのため、マッチした文字列を取得するStringの<code>match</code>メソッドと<code>matchAll</code>メソッドが用意されています。
また、これらのメソッドは正規表現のマッチを文字列の最後まで繰り返す<code>g</code>フラグ（globalの略称）によって挙動が変わります。</p>
<h5 id="match"><a name="match" class="plugin-anchor" href="#match"><i class="fa fa-link" aria-hidden="true"></i></a>マッチした文字列の取得 </h5>
<p>まずは、マッチした文字列を取得するStringの<code>match</code>メソッドから見ていきます。
<code>match</code>メソッドは、正規表現の<code>/パターン/</code>が<code>&quot;文字列&quot;</code>にマッチすると、マッチした文字列に関する情報を返すメソッドです。</p>
<pre><code class="lang-js"><span class="hljs-string">&quot;文字列&quot;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/パターン/</span>);
</code></pre>
<p><code>match</code>メソッドで検索した結果、正規表現にマッチする文字列がなかった場合は<code>null</code>を返します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;文字列&quot;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/マッチしないパターン/</span>)); <span class="hljs-comment">// =&gt; null</span>
</code></pre>
<p><code>match</code>メソッドは正規表現の<code>g</code>フラグなしのパターンで検索した場合、最初にマッチしたものが見つかった時点で検索が終了します。
このときの<code>match</code>メソッドの返り値は、<code>index</code>プロパティと<code>input</code>プロパティをもった特殊な配列となります。
<code>index</code>プロパティにはマッチした文字列の先頭のインデックスが、<code>input</code>プロパティには検索対象となった文字列全体が含まれています。</p>
<p>次のコードの<code>/[a-zA-Z]+/</code>という正規表現は<code>a</code>から<code>Z</code>のどれかの文字が1つ以上連続しているものにマッチします。
この正規表現にマッチした文字列は、返り値の配列からインデックスアクセスで取得できます。
<code>g</code>フラグなしでは、最初にマッチしたものを見つけた時点で検索が終了するので、返り値の配列には1つの要素しか含まれていません。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;ABC あいう DE えお&quot;</span>;
<span class="hljs-keyword">const</span> alphabetsPattern = <span class="hljs-regexp">/[a-zA-Z]+/</span>;
<span class="hljs-comment">// gフラグなしでは、最初の結果のみを含んだ特殊な配列を返す</span>
<span class="hljs-keyword">const</span> results = str.<span class="hljs-title function_">match</span>(alphabetsPattern);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results.<span class="hljs-property">length</span>); <span class="hljs-comment">// =&gt; 1</span>
<span class="hljs-comment">// マッチした文字列はインデックスでアクセスできる</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results[<span class="hljs-number">0</span>]); <span class="hljs-comment">// =&gt; &quot;ABC&quot;</span>
<span class="hljs-comment">// マッチした文字列の先頭のインデックス</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results.<span class="hljs-property">index</span>); <span class="hljs-comment">// =&gt; 0</span>
<span class="hljs-comment">// 検索対象となった文字列全体</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results.<span class="hljs-property">input</span>); <span class="hljs-comment">// =&gt; &quot;ABC あいう DE えお&quot;</span>
</code></pre>
<p><code>match</code>メソッドは正規表現の<code>g</code>フラグありのパターンで検索した場合、マッチしたすべての文字列を含んだ配列を返します。</p>
<p>次のコードの<code>/[a-zA-Z]+/g</code>という正規表現は<code>a</code>から<code>Z</code>のどれかの文字が1つ以上連続しているものに繰り返しマッチします。
この正規表現にマッチする箇所は&quot;ABC&quot;と&quot;DE&quot;の2つとなるため、<code>match</code>メソッドの返り値である配列にも2つの要素が含まれています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;ABC あいう DE えお&quot;</span>;
<span class="hljs-keyword">const</span> alphabetsPattern = <span class="hljs-regexp">/[a-zA-Z]+/g</span>;
<span class="hljs-comment">// gフラグありでは、すべての検索結果を含む配列を返す</span>
<span class="hljs-keyword">const</span> resultsWithG = str.<span class="hljs-title function_">match</span>(alphabetsPattern);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resultsWithG.<span class="hljs-property">length</span>); <span class="hljs-comment">// =&gt; 2</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resultsWithG[<span class="hljs-number">0</span>]); <span class="hljs-comment">// =&gt; &quot;ABC&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resultsWithG[<span class="hljs-number">1</span>]); <span class="hljs-comment">// =&gt; &quot;DE&quot;</span>
<span class="hljs-comment">// indexとinputはgフラグありの場合は追加されない</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resultsWithG.<span class="hljs-property">index</span>); <span class="hljs-comment">// =&gt; undefined</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resultsWithG.<span class="hljs-property">input</span>); <span class="hljs-comment">// =&gt; undefined</span>
</code></pre>
<p>このときの<code>match</code>メソッドの返り値である配列には<code>index</code>と<code>input</code>プロパティはありません。
なぜなら、複数の箇所にマッチする場合においては、1つの<code>index</code>プロパティでは意味が一意に決まらないためです。</p>
<p>Stringの<code>match</code>メソッドの挙動をまとめると次のようになります。</p>
<ul>
<li>マッチしない場合は、<code>null</code>を返す</li>
<li>マッチした場合は、マッチした文字列を含んだ特殊な配列を返す</li>
<li>正規表現の<code>g</code>フラグがある場合は、マッチしたすべての結果を含んだただの配列を返す</li>
</ul>
<!--
RegExp.prototype.match globalがtrueの場合はプロパティがないただの配列を返す
https://tc39.es/ecma262/#sec-regexp.prototype-@@match
RegExp.prototype.match globalがfalseの場合はString.prototype.execと同じ
 -->
<p>ES2020では、正規表現の<code>g</code>フラグを使った繰り返しマッチする場合においても、それぞれマッチした文字列ごとの情報を得るためのStringの<code>matchAll</code>が追加されています。
<code>matchAll</code>メソッドは、マッチした結果をIteratorで返します。</p>
<p>次のコードでは、<code>matchAll</code>メソッドでアルファベットにマッチする結果のIteratorオブジェクトを取得しています。
Iteratorオブジェクトは<code>for...of</code>構文で反復処理すると、Iteratorから値を1つずつ取り出して処理できます（詳細は「<a href="../loop/">ループと反復処理</a>」の章を参照）。
このときの反復処理で取得できる値は、それぞれのマッチした文字列と<code>index</code>と<code>input</code>プロパティを持つ特殊な配列となります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": 2020 } --></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;ABC あいう DE えお&quot;</span>;
<span class="hljs-keyword">const</span> alphabetsPattern = <span class="hljs-regexp">/[a-zA-Z]+/g</span>;
<span class="hljs-comment">// matchAllはIteratorを返す</span>
<span class="hljs-keyword">const</span> matchesIterator = str.<span class="hljs-title function_">matchAll</span>(alphabetsPattern);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> match <span class="hljs-keyword">of</span> matchesIterator) {
    <span class="hljs-comment">// マッチした要素ごとの情報を含んでいる</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`match: &quot;<span class="hljs-subst">${match[<span class="hljs-number">0</span>]}</span>&quot;, index: <span class="hljs-subst">${match.index}</span>, input: &quot;<span class="hljs-subst">${match.input}</span>&quot;`</span>);
}
<span class="hljs-comment">// 次の順番でコンソールに出力される</span>
<span class="hljs-comment">// match: &quot;ABC&quot;, index: 0, input: &quot;ABC あいう DE えお&quot;</span>
<span class="hljs-comment">// match: &quot;DE&quot;, index: 8, input: &quot;ABC あいう DE えお&quot;</span>
</code></pre>
<p>そのため、正規表現の<code>g</code>フラグを使った繰り返しマッチを行う場合には、<code>match</code>メソッドではなく<code>matchAll</code>メソッドを利用します。
また、<code>matchAll</code>メソッドは<code>g</code>フラグなしの正規表現はサポートしていないため、<code>g</code>フラグなしの正規表現を渡した場合は例外が発生します。</p>
<h4 id="match-capture-by-regexp"><a name="match-capture-by-regexp" class="plugin-anchor" href="#match-capture-by-regexp"><i class="fa fa-link" aria-hidden="true"></i></a>マッチした文字列の一部を取得 </h4>
<p>Stringの<code>match</code>メソッドと<code>matchAll</code>メソッドは、どちらも正規表現のキャプチャリングに対応しています。
キャプチャリングとは、正規表現中で<code>/パターン1(パターン2)/</code>のようにカッコで囲んだ部分を取り出すことです。
このキャプチャリングによって、正規表現でマッチした一部分だけを取り出せます。</p>
<p><code>match</code>メソッドと<code>matchAll</code>メソッドはどちらもマッチした結果を配列として返します。</p>
<p>そのマッチしているパターンにキャプチャが含まれている場合は、返り値の配列へキャプチャした部分が追加されていきます。
配列の先頭にはマッチした文字列全体が入り、順番にキャプチャリング（<code>(</code>と<code>)</code>）で囲んだ範囲が配列に含まれます。</p>
<!-- doctest:disable -->
<pre><code class="lang-js"><span class="hljs-keyword">const</span> [マッチした全体の文字列, キャプチャ<span class="hljs-number">1</span>, キャプチャ<span class="hljs-number">2</span>] = 文字列.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/パターン(キャプチャ1)と(キャプチャ2)/</span>);
</code></pre>
<p>次のコードでは、<code>ECMAScript 数字</code>の<code>数字</code>部分だけを取り出そうとしています。
Stringの<code>match</code>メソッドとキャプチャリングによって数字(<code>\d+</code>)にマッチする部分を取り出しています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// &quot;ECMAScript (数字+)&quot;にマッチするが、欲しい文字列は数字の部分のみ</span>
<span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/ECMAScript (\d+)/</span>;
<span class="hljs-comment">// 返り値は0番目がマッチした全体、1番目がキャプチャの1番目というように対応している</span>
<span class="hljs-comment">// [マッチした全部の文字列, キャプチャの1番目, キャプチャの2番目 ....]</span>
<span class="hljs-keyword">const</span> [all, capture1] = <span class="hljs-string">&quot;ECMAScript 6&quot;</span>.<span class="hljs-title function_">match</span>(pattern);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(all); <span class="hljs-comment">// =&gt; &quot;ECMAScript 6&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(capture1); <span class="hljs-comment">// =&gt; &quot;6&quot;</span>
</code></pre>
<p>正規表現の<code>g</code>フラグを使い繰り返し文字列にマッチする場合には、<code>matchAll</code>メソッドを利用します。
先ほども紹介したように、<code>match</code>メソッドは繰り返しマッチした場合に、それぞれ個別のマッチした情報を取得できないためです。</p>
<p>次のコードでは、<code>ES数字</code>の数字(<code>\d+</code>)にマッチする部分を取り出しています。
<code>matchAll</code>の返り値であるIteratorを反復処理することで、それぞれマッチしたキャプチャを取り出しています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": 2020 } --></p>
<pre><code class="lang-js"><span class="hljs-comment">// &quot;ES(数字+)&quot;にマッチするが、欲しい文字列は数字の部分のみ</span>
<span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/ES(\d+)/g</span>;
<span class="hljs-comment">// iteratorを返す</span>
<span class="hljs-keyword">const</span> matchesIterator = <span class="hljs-string">&quot;ES2015、ES2016、ES2017&quot;</span>.<span class="hljs-title function_">matchAll</span>(pattern);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> match <span class="hljs-keyword">of</span> matchesIterator) {
    <span class="hljs-comment">// マッチした要素ごとの情報を含んでいる</span>
    <span class="hljs-comment">// 0番目はマッチした文字列全体、1番目がキャプチャの1番目である数字</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`match: &quot;<span class="hljs-subst">${match[<span class="hljs-number">0</span>]}</span>&quot;, capture1: <span class="hljs-subst">${match[<span class="hljs-number">1</span>]}</span>, index: <span class="hljs-subst">${match.index}</span>, input: &quot;<span class="hljs-subst">${match.input}</span>&quot;`</span>);
}
<span class="hljs-comment">// 次の順番でコンソールに出力される</span>
<span class="hljs-comment">// match: &quot;ES2015&quot;, capture1: 2015, index: 0, input: &quot;ES2015、ES2016、ES2017&quot;</span>
<span class="hljs-comment">// match: &quot;ES2016&quot;, capture1: 2016, index: 7, input: &quot;ES2015、ES2016、ES2017&quot;</span>
<span class="hljs-comment">// match: &quot;ES2017&quot;, capture1: 2017, index: 14, input: &quot;ES2015、ES2016、ES2017&quot;</span>
</code></pre>
<h4 id="regexp-exec"><a name="regexp-exec" class="plugin-anchor" href="#regexp-exec"><i class="fa fa-link" aria-hidden="true"></i></a>[コラム] RegExp.prototype.execでのString.prototype.matchAll </h4>
<p>Stringの<code>matchAll</code>メソッドは、ES2020で導入されたメソッドです。
それまでは、RegExpの<code>exec</code>メソッドというStringの<code>match</code>メソッドによく似た挙動をするメソッドを利用して、Stringの<code>matchAll</code>メソッド相当の表現を実装していました。</p>
<p>RegExpの<code>exec</code>メソッドは、引数に文字列を受け取るメソッドです。</p>
<pre><code class="lang-js">/pattern/.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&quot;文字列&quot;</span>);
</code></pre>
<p>RegExpの<code>exec</code>メソッドは<code>g</code>フラグなしのパターンで検索した場合、マッチした最初の結果のみを含む特殊な配列を返します。
このときの<code>exec</code>メソッドの返り値である配列が<code>index</code>プロパティと<code>input</code>プロパティが追加された特殊な配列となるのは、Stringの<code>match</code>メソッドと同様です。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;ABC あいう DE えお&quot;</span>;
<span class="hljs-keyword">const</span> alphabetsPattern = <span class="hljs-regexp">/[a-zA-Z]+/</span>;
<span class="hljs-comment">// gフラグなしでは、最初の結果のみを持つ配列を返す</span>
<span class="hljs-keyword">const</span> results = alphabetsPattern.<span class="hljs-title function_">exec</span>(str);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results.<span class="hljs-property">length</span>); <span class="hljs-comment">// =&gt; 1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results[<span class="hljs-number">0</span>]); <span class="hljs-comment">// =&gt; &quot;ABC&quot;</span>
<span class="hljs-comment">// マッチした文字列の先頭のインデックス</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results.<span class="hljs-property">index</span>); <span class="hljs-comment">// =&gt; 0</span>
<span class="hljs-comment">// 検索対象となった文字列全体</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results.<span class="hljs-property">input</span>); <span class="hljs-comment">// =&gt; &quot;ABC あいう DE えお&quot;</span>
</code></pre>
<p>RegExpの<code>exec</code>メソッドは<code>g</code>フラグありのパターンで検索した場合も、マッチした最初の結果のみを含む特殊な配列を返します。
この点はStringの<code>match</code>メソッドとは異なります。
また、最後にマッチした文字列末尾のインデックスを正規表現オブジェクトの<code>lastIndex</code>プロパティに記録します。
そしてもう一度<code>exec</code>メソッドを呼び出すと最後にマッチした末尾のインデックス（<code>lastIndex</code>プロパティの位置）から検索が開始されます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;ABC あいう DE えお&quot;</span>;
<span class="hljs-keyword">const</span> alphabetsPattern = <span class="hljs-regexp">/[a-zA-Z]+/g</span>;
<span class="hljs-comment">// まだ一度も検索していないので、lastIndexは0となり先頭から検索が開始される</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(alphabetsPattern.<span class="hljs-property">lastIndex</span>); <span class="hljs-comment">// =&gt; 0</span>
<span class="hljs-comment">// gフラグありでも、一回目の結果は同じだが、`lastIndex`プロパティが更新される</span>
<span class="hljs-keyword">const</span> result1 = alphabetsPattern.<span class="hljs-title function_">exec</span>(str);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result1[<span class="hljs-number">0</span>]); <span class="hljs-comment">// =&gt; &quot;ABC&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(alphabetsPattern.<span class="hljs-property">lastIndex</span>); <span class="hljs-comment">// =&gt; 3</span>
<span class="hljs-comment">// 2回目の検索が、`lastIndex`の値のインデックスから開始される</span>
<span class="hljs-keyword">const</span> result2 = alphabetsPattern.<span class="hljs-title function_">exec</span>(str);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result2[<span class="hljs-number">0</span>]); <span class="hljs-comment">// =&gt; &quot;DE&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(alphabetsPattern.<span class="hljs-property">lastIndex</span>); <span class="hljs-comment">// =&gt; 10</span>
<span class="hljs-comment">// 検索結果が見つからない場合はnullを返し、`lastIndex`プロパティは0にリセットされる</span>
<span class="hljs-keyword">const</span> result3 = alphabetsPattern.<span class="hljs-title function_">exec</span>(str);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result3); <span class="hljs-comment">// =&gt; null</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(alphabetsPattern.<span class="hljs-property">lastIndex</span>); <span class="hljs-comment">// =&gt; 0</span>
</code></pre>
<p>RegExpの<code>exec</code>メソッドの挙動をまとめると次のようになります。
正規表現の<code>g</code>フラグがない場合は、Stringの<code>match</code>メソッドと同じ結果です。
一方で、正規表現の<code>g</code>フラグがある場合は、Stringの<code>match</code>メソッドとは異なる挙動をします。</p>
<ul>
<li>マッチしない場合は、<code>null</code>を返す</li>
<li>マッチした場合は、マッチした文字列を含んだ特殊な配列を返す</li>
<li>正規表現の<code>g</code>フラグがある場合は、マッチした文字列を含んだ特殊な配列を返し、マッチした末尾のインデックスを正規表現オブジェクトの<code>lastIndex</code>プロパティに記録する</li>
</ul>
<p>この正規表現の<code>g</code>フラグと<code>exec</code>メソッドで検索した場合に、<code>lastIndex</code>プロパティが検索ごとに更新される仕組みを利用して、マッチするすべての結果を取得できます。</p>
<p>次のコードでは、RegExpの<code>exec</code>メソッドを使い、アルファベットにマッチした結果を<code>matches</code>に保持しています。
<code>g</code>フラグがある場合の<code>exec</code>メソッドでは最後にマッチした位置が記録されているため、<code>while</code>文で反復処理して続きから検索しています。
また、<code>exec</code>メソッドはマッチしなければ<code>null</code>を返すため、マッチするものがなくなればwhile文から自動的に脱出します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;ABC あいう DE えお&quot;</span>;
<span class="hljs-keyword">const</span> alphabetsPattern = <span class="hljs-regexp">/[a-zA-Z]+/g</span>;
<span class="hljs-keyword">let</span> matches;
<span class="hljs-keyword">while</span> (matches = alphabetsPattern.<span class="hljs-title function_">exec</span>(str)) {
    <span class="hljs-comment">// RegExpの`exec`メソッドの返り値は`index`プロパティなどを含む特殊な配列</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`match: <span class="hljs-subst">${matches[<span class="hljs-number">0</span>]}</span>, index: <span class="hljs-subst">${matches.index}</span>, lastIndex: <span class="hljs-subst">${alphabetsPattern.lastIndex}</span>`</span>);
}
<span class="hljs-comment">// 次の順番でコンソールに出力される</span>
<span class="hljs-comment">// match: ABC, index: 0, lastIndex: 3</span>
<span class="hljs-comment">// match: DE, index: 8, lastIndex: 10</span>
</code></pre>
<p>このようにRegExpの<code>exec</code>メソッドと正規表現の<code>g</code>フラグを使い、Stringの<code>matchAll</code>メソッド相当の反復処理を実装していました。
RegExpの<code>exec</code>はIteratorオブジェクトという反復処理のためのオブジェクトが導入される以前からあるメソッドです。</p>
<p>Stringの<code>matchAll</code>がIteratorを扱うわかりやすい反復処理に比べて、RegExpの<code>exec</code>メソッドは<code>while</code>文などで手動で反復処理を書く必要があるため直感的ではありません。
そのため、Stringの<code>matchAll</code>メソッドが利用できる場合に、RegExpの<code>exec</code>メソッドを利用する必要はありません。</p>
<h4 id="test-by-regexp"><a name="test-by-regexp" class="plugin-anchor" href="#test-by-regexp"><i class="fa fa-link" aria-hidden="true"></i></a>真偽値を取得 </h4>
<p>正規表現オブジェクトを使って、そのパターンにマッチするかをテストするには、RegExpの<code>test</code>メソッドを利用できます。</p>
<p>正規表現のパターンには、パターンの位置を指定する特殊文字があります。
そのため、「文字列による検索」で登場したメソッドは、特殊文字とRegExpの<code>test</code>メソッドで表現できます。</p>
<ul>
<li>Stringの<code>startsWith</code>相当: <code>/^パターン/.test(文字列)</code><ul>
<li><code>^</code> は先頭に一致する特殊文字</li>
</ul>
</li>
<li>Stringの<code>endsWith</code>相当: <code>/パターン$/.test(文字列)</code><ul>
<li><code>$</code> は末尾に一致する特殊文字</li>
</ul>
</li>
<li>Stringの<code>includes</code>相当: <code>/パターン/.test(文字列)</code></li>
</ul>
<p>具体的な例を見てみましょう。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// 検索対象となる文字列</span>
<span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;にわにはにわにわとりがいる&quot;</span>;
<span class="hljs-comment">// ^ - 検索文字列が先頭ならtrue</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-regexp">/^にわ/</span>.<span class="hljs-title function_">test</span>(str)); <span class="hljs-comment">// =&gt; true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-regexp">/^いる/</span>.<span class="hljs-title function_">test</span>(str)); <span class="hljs-comment">// =&gt; false</span>
<span class="hljs-comment">// $ - 検索文字列が末尾ならtrue</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-regexp">/にわ$/</span>.<span class="hljs-title function_">test</span>(str)); <span class="hljs-comment">// =&gt; false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-regexp">/いる$/</span>.<span class="hljs-title function_">test</span>(str)); <span class="hljs-comment">// =&gt; true</span>
<span class="hljs-comment">// 検索文字列が含まれるならtrue</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-regexp">/にわ/</span>.<span class="hljs-title function_">test</span>(str)); <span class="hljs-comment">// =&gt; true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-regexp">/いる/</span>.<span class="hljs-title function_">test</span>(str)); <span class="hljs-comment">// =&gt; true</span>
</code></pre>
<p>そのほかにも、正規表現では繰り返しや文字の集合などを特殊文字で表現できるため柔軟な検索が可能です。</p>
<h3 id="string-or-regexp"><a name="string-or-regexp" class="plugin-anchor" href="#string-or-regexp"><i class="fa fa-link" aria-hidden="true"></i></a>文字列と正規表現どちらを使うべきか </h3>
<p>Stringメソッドでの検索と同等のことは、正規表現でもできることがわかりました。
Stringメソッドと正規表現で同じ結果が得られる場合はどちらを利用するのがよいでしょうか？</p>
<p>正規表現は曖昧な検索に強く、特殊文字を使うことで柔軟な検索結果を得られます。
一方、曖昧であるため、コードを見ても何を検索しているかが正規表現のパターン自体からわからないことがあります。</p>
<p>次の例は、<code>/</code>からはじまり<code>/</code>で終わる文字列かを判定しようとしています。
この判定を正規表現とStringメソッドを使ってそれぞれ実装しています
（これは意図的に正規表現に不利な例となっています）。</p>
<p>正規表現の場合、<code>/^\/.*\/$/</code>のようにパターンそのものを見ても何をしたいのかはひと目ではわかりにくいです。
Stringメソッドの場合は、<code>/</code>からはじまり<code>/</code>で終わるかを判定してることがそのままコードに表現できています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;/正規表現のような文字列/&quot;</span>;
<span class="hljs-comment">// 正規表現で`/`からはじまり`/`で終わる文字列のパターン</span>
<span class="hljs-keyword">const</span> regExpLikePattern = <span class="hljs-regexp">/^\/.*\/$/</span>;
<span class="hljs-comment">// RegExpの`test`メソッドでパターンにマッチするかを判定</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(regExpLikePattern.<span class="hljs-title function_">test</span>(str)); <span class="hljs-comment">// =&gt; true</span>
<span class="hljs-comment">// Stringメソッドで、`/`からはじまり`/`で終わる文字列かを判定する関数</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">isRegExpLikeString</span> = (<span class="hljs-params">str</span>) =&gt; {
    <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&quot;/&quot;</span>) &amp;&amp; str.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&quot;/&quot;</span>);
};
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isRegExpLikeString</span>(str)); <span class="hljs-comment">// =&gt; true</span>
</code></pre>
<p>このように、正規表現は柔軟で便利ですが、コード上から意図が消えてしまいやすいです。
そのため、正規表現を扱う際にはコメントや変数名で具体的な意図を補足したほうがよいでしょう。</p>
<p>「Stringメソッドと正規表現で同じ結果が得られる場合はどちらを利用するのがよいでしょうか？」という疑問に戻ります。
Stringメソッドで表現できることはStringメソッドで表現し、柔軟性や曖昧な検索が必要な場合はコメントとともに正規表現を利用するという方針を推奨します。</p>
<p>正規表現についてより詳しくは<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Regular_Expressions" title="正規表現 - JavaScript | MDN" target="_blank">MDNの正規表現ドキュメント</a>や、コンソールで実行しながら試せる<a href="https://regex101.com/" title="Online regex tester and debugger: PHP, PCRE, Python, Golang and JavaScript" target="_blank">regex101</a>のようなサイトを参照してください。</p>
<h2 id="replace-delete"><a name="replace-delete" class="plugin-anchor" href="#replace-delete"><i class="fa fa-link" aria-hidden="true"></i></a>文字列の置換/削除 </h2>
<p>文字列の一部を置換したり削除するにはStringの<code>replace</code>メソッドを利用します。
「<a href="../data-type/">データ型とリテラル</a>」で説明したようにプリミティブ型である文字列は不変な特性を持ちます。
そのため、文字列から一部の文字を削除するような操作はできません。</p>
<p>つまり、<code>delete</code>演算子は文字列に対して利用できません。
strict modeでは、<code>delete</code>演算子で削除できないプロパティを削除しようとするとエラーが発生します。
strict modeでない場合は、エラーも発生せず単に無視されます（詳細は「<a href="../introduction/">JavaScriptとは</a>」の<a href="../introduction/#strict-mode">strict mode</a>を参照）。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-meta">&quot;use strict&quot;</span>;
<span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;文字列&quot;</span>;
<span class="hljs-comment">// 文字列の0番目の削除を試みるがStrict modeでは例外が発生する</span>
<span class="hljs-keyword">delete</span> str[<span class="hljs-number">0</span>]; <span class="hljs-comment">// =&gt; TypeError: property 0 is non-configurable and can&apos;t be deleted</span>
</code></pre>
<p>代わりに、Stringの<code>replace</code>メソッドで、削除したい文字を取り除いた新しい文字列を返すことで削除を表現します。
<code>replace</code>メソッドは、<strong>文字列</strong>から第一引数の<code>検索文字列</code>または正規表現にマッチする部分を、第二引数の<code>置換文字列</code>へ置換します。
第一引数には、文字列と正規表現を指定できます。</p>
<!-- doctest: ReferenceError -->
<pre><code class="lang-js">文字列.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;検索文字列&quot;</span>, <span class="hljs-string">&quot;置換文字列&quot;</span>);
文字列.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/パターン/</span>, <span class="hljs-string">&quot;置換文字列&quot;</span>);
</code></pre>
<p>次のように、<code>replace</code>メソッドで削除したい部分を空文字列へ置換することで、文字列を削除できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;文字列&quot;</span>;
<span class="hljs-comment">// &quot;文字&quot;を&quot;&quot;（空文字列）へ置換することで&quot;削除&quot;を表現</span>
<span class="hljs-keyword">const</span> newStr = str.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;文字&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newStr); <span class="hljs-comment">// =&gt; &quot;列&quot;</span>
</code></pre>
<p><code>replace</code>メソッドには正規表現も指定できます。
<code>g</code>フラグを有効化した正規表現を渡すことで、文字列からパターンにマッチするものをすべて置換できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// 検索対象となる文字列</span>
<span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;にわにはにわにわとりがいる&quot;</span>;
<span class="hljs-comment">// 文字列を指定した場合は、最初に一致したものだけが置換される</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;にわ&quot;</span>, <span class="hljs-string">&quot;niwa&quot;</span>)); <span class="hljs-comment">// =&gt; &quot;niwaにはにわにわとりがいる&quot;</span>
<span class="hljs-comment">// `g`フラグなし正規表現の場合は、最初に一致したものだけが置換される</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/にわ/</span>, <span class="hljs-string">&quot;niwa&quot;</span>)); <span class="hljs-comment">// =&gt; &quot;niwaにはにわにわとりがいる&quot;</span>
<span class="hljs-comment">// `g`フラグあり正規表現の場合は、繰り返し置換を行う</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/にわ/g</span>, <span class="hljs-string">&quot;niwa&quot;</span>)); <span class="hljs-comment">// =&gt; &quot;niwaにはniwaniwaとりがいる&quot;</span>
</code></pre>
<p>文字列から検索文字列にマッチするものをすべて置換する場合には、ES2021で追加されたStringの<code>replaceAll</code>メソッドも利用できます。
<code>replace</code>メソッドでは、最初に一致したものだけが置換されますが、<code>replaceAll</code>メソッドでは一致したものがすべて置換されます。</p>
<p>Stringの<code>replace</code>と<code>g</code>フラグ付きの正規表現を使った場合との違いとして、
Stringの<code>replaceAll</code>メソッドでは、正規表現ではなく文字列を使ってすべてを置換できます。
そのため、正規表現では特殊な意味を持つ<code>?</code>のような文字列も検索文字列にそのまま書いて置換ができます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2021" } --></p>
<pre><code class="lang-js"><span class="hljs-comment">// 検索対象となる文字列</span>
<span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;???&quot;</span>;
<span class="hljs-comment">// replaceメソッドに文字列を指定した場合は、最初に一致したものだけが置換される</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;?&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>)); <span class="hljs-comment">// =&gt; &quot;!??&quot;</span>
<span class="hljs-comment">// replaceAllメソッドに文字列を指定した場合は、一致したものがすべて置換される</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-string">&quot;?&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>)); <span class="hljs-comment">// =&gt; &quot;!!!&quot;</span>
<span class="hljs-comment">// replaceメソッドの場合は、正規表現の特殊文字はエスケープが必要となる</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\?/g</span>, <span class="hljs-string">&quot;!&quot;</span>)); <span class="hljs-comment">// =&gt; &quot;!!!&quot;</span>
<span class="hljs-comment">// replaceAllメソッドにも正規表現を渡せるが、この場合はエスケープが必要となるためreplaceと同じ</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-regexp">/\?/g</span>, <span class="hljs-string">&quot;!&quot;</span>)); <span class="hljs-comment">// =&gt; &quot;!!!&quot;</span>
</code></pre>
<p><code>replace</code>メソッドと<code>replaceAll</code>メソッドでは、キャプチャした文字列を利用して複雑な置換処理もできます。</p>
<p><code>replace</code>メソッドと<code>replaceAll</code>メソッドの第二引数にはコールバック関数を渡せます。
第一引数の<code>パターン</code>にマッチした部分がコールバック関数の返り値で置換されます。
コールバック関数の第一引数には<code>パターン</code>に一致した文字列全体、第二引数以降へキャプチャした文字列が順番に入ります。</p>
<!-- doctest:disable -->
<pre><code class="lang-js"><span class="hljs-keyword">const</span> 置換した結果の文字列 = 文字列.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(パターン)/</span>, <span class="hljs-function">(<span class="hljs-params">all, ...captures</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> 置換したい文字列;
});
</code></pre>
<p>例として、<code>2017-03-01</code>を<code>2017年03月01日</code>に置換する処理を書いてみましょう。</p>
<p><code>/(\d{4})-(\d{2})-(\d{2})/g</code>という正規表現が<code>&quot;2017-03-01&quot;</code>という文字列にマッチします。
コールバック関数の<code>year</code>、<code>month</code>、<code>day</code>にはそれぞれキャプチャした文字列が入り、
マッチした文字列全体がコールバック関数の返り値に置換されます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">toDateJa</span>(<span class="hljs-params">dateString</span>) {
    <span class="hljs-comment">// パターンにマッチしたときのみ、コールバック関数で置換処理が行われる</span>
    <span class="hljs-keyword">return</span> dateString.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(\d{4})-(\d{2})-(\d{2})/g</span>, <span class="hljs-function">(<span class="hljs-params">all, year, month, day</span>) =&gt;</span> {
        <span class="hljs-comment">// `all`には、マッチした文字列全体が入っているが今回は利用しない</span>
        <span class="hljs-comment">// `all`が次の返す値で置換されるイメージ</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${year}</span>年<span class="hljs-subst">${month}</span>月<span class="hljs-subst">${day}</span>日`</span>;
    });
}
<span class="hljs-comment">// マッチしない文字列の場合は、そのままの文字列が返る</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">toDateJa</span>(<span class="hljs-string">&quot;本日ハ晴天ナリ&quot;</span>)); <span class="hljs-comment">// =&gt; &quot;本日ハ晴天ナリ&quot;</span>
<span class="hljs-comment">// マッチした場合は置換した結果を返す</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">toDateJa</span>(<span class="hljs-string">&quot;今日は2017-03-01です&quot;</span>)); <span class="hljs-comment">// =&gt; &quot;今日は2017年03月01日です&quot;</span>
</code></pre>
<h2 id="built"><a name="built" class="plugin-anchor" href="#built"><i class="fa fa-link" aria-hidden="true"></i></a>文字列の組み立て </h2>
<p>最後に文字列の組み立てについて見ていきましょう。
最初に述べたようにこの章の目的は、「自由に文字列を作れるようになること」です。</p>
<p>文字列を単純に結合したり置換することで新しい文字列を作れることがわかりました。
一方、構造的な文字列の場合は単純に結合するだけでは意味が異なってしまうことがあります。</p>
<p>ここでの構造的な文字列とは、URL文字列やファイルパス文字列といった文字列中にコンテキストを持っているものを指します。
たとえば、URL文字列は次のような構造を持っており、それぞれの要素に入る文字列の種類などが決められています（詳細は「<a href="https://url.spec.whatwg.org/" title="URL Standard" target="_blank">URL Standard</a>」を参照）。</p>
<pre><code>&quot;https://example.com/index.html&quot;
 ^^^^^   ^^^^^^^^^^^ ^^^^^^^^^^
   |          |     　　　|
 scheme      host     pathname
</code></pre><p>これらの文字列を作成する場合は、文字列結合演算子（<code>+</code>）で単純に結合するよりも専用の関数を用意するほうが安全です。</p>
<p>たとえば、次のように<code>baseURL</code>と<code>pathname</code>を渡し、それらを結合したURLにあるリソースを取得する<code>getResource</code>関数があるとします。
この<code>getResource</code>関数には、ベースURL(<code>baseURL</code>)とパス（<code>pathname</code>）を引数に渡して利用します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// `baseURL`と`pathname`にあるリソースを取得する</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getResource</span>(<span class="hljs-params">baseURL, pathname</span>) {
    <span class="hljs-keyword">const</span> url = baseURL + pathname;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(url); <span class="hljs-comment">// =&gt; &quot;http://example.com/resouces/example.js&quot;</span>
    <span class="hljs-comment">// 省略) リソースを取得する処理...</span>
}
<span class="hljs-keyword">const</span> baseURL = <span class="hljs-string">&quot;http://example.com/resouces&quot;</span>;
<span class="hljs-keyword">const</span> pathname = <span class="hljs-string">&quot;/example.js&quot;</span>;
<span class="hljs-title function_">getResource</span>(baseURL, pathname);
</code></pre>
<p>しかし、人によっては、<code>baseURL</code>の末尾には<code>/</code>が含まれると考える場合もあります。
<code>getResource</code>関数は、<code>baseURL</code>の末尾に<code>/</code>が含まれているケースを想定していませんでした。
そのため、意図しないURLからリソースを取得するという問題が発生します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// `baseURL`と`pathname`にあるリソースを取得する</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getResource</span>(<span class="hljs-params">baseURL, pathname</span>) {
    <span class="hljs-keyword">const</span> url = baseURL + pathname;
    <span class="hljs-comment">// `/` と `/` が２つ重なってしまっている</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(url); <span class="hljs-comment">// =&gt; &quot;http://example.com/resouces//example.js&quot;</span>
    <span class="hljs-comment">// 省略) リソースを取得する処理...</span>
}
<span class="hljs-keyword">const</span> baseURL = <span class="hljs-string">&quot;http://example.com/resouces/&quot;</span>;
<span class="hljs-keyword">const</span> pathname = <span class="hljs-string">&quot;/example.js&quot;</span>;
<span class="hljs-title function_">getResource</span>(baseURL, pathname);
</code></pre>
<p>この問題が難しいところは、結合してできた<code>url</code>は文字列としては正しいため、エラーではないということです。
つまり、一見すると問題ないように見えますが、実際に動かしてみて初めてわかるような問題が生じやすいのです。</p>
<p>そのため、このような構造的な文字列を扱う場合は、専用の関数や専用のオブジェクトを作ることで安全に文字列を処理します。</p>
<p>先ほどのような、URL文字列の結合を安全に行うには、入力される<code>baseURL</code>文字列の表記揺れを吸収する仕組みを作成します。
次の<code>baseJoin</code>関数はベースURLとパスを結合した文字列を返しますが、ベースURLの末尾に<code>/</code>があるかの揺れを吸収しています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// ベースURLとパスを結合した文字列を返す</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">baseJoin</span>(<span class="hljs-params">baseURL, pathname</span>) {
    <span class="hljs-comment">// 末尾に / がある場合は、/ を削除してから結合する</span>
    <span class="hljs-keyword">const</span> stripSlashBaseURL = baseURL.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\/$/</span>, <span class="hljs-string">&quot;&quot;</span>);
    <span class="hljs-keyword">return</span> stripSlashBaseURL + pathname;
}
<span class="hljs-comment">// `baseURL`と`pathname`にあるリソースを取得する</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getResource</span>(<span class="hljs-params">baseURL, pathname</span>) {
    <span class="hljs-keyword">const</span> url = <span class="hljs-title function_">baseJoin</span>(baseURL, pathname);
    <span class="hljs-comment">// baseURLの末尾に / があってもなくても同じ結果となる</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(url); <span class="hljs-comment">// =&gt; &quot;http://example.com/resouces/example.js&quot;</span>
    <span class="hljs-comment">// 省略) リソースを取得する処理...</span>
}
<span class="hljs-keyword">const</span> baseURL = <span class="hljs-string">&quot;http://example.com/resouces/&quot;</span>;
<span class="hljs-keyword">const</span> pathname = <span class="hljs-string">&quot;/example.js&quot;</span>;
<span class="hljs-title function_">getResource</span>(baseURL, pathname);
</code></pre>
<p>ECMAScriptの範囲ではありませんが、URLやファイルパスといった典型的なものに対してはすでに専用のものがあります。
URLを扱うものとしてウェブ標準APIである<a href="https://developer.mozilla.org/ja/docs/Web/API/URL" title="URL - Web API インターフェイス | MDN" target="_blank">URL</a>オブジェクト、ファイルパスを扱うものとしてはNode.jsのコアモジュールである<a href="https://nodejs.org/api/path.html" title="Path | Node.js v7.9.0 Documentation" target="_blank">Path</a>モジュールなどがあります。専用の仕組みがある場合は、直接<code>+</code>演算子で結合するような文字列処理は避けるべきです。</p>
<h3 id="tagged-template-function"><a name="tagged-template-function" class="plugin-anchor" href="#tagged-template-function"><i class="fa fa-link" aria-hidden="true"></i></a>[ES2015] タグつきテンプレート関数 </h3>
<p>JavaScriptでは、テンプレートとなる文字列に対して一部分だけを変更する処理を行う方法として、タグつきテンプレート関数があります。
タグつきテンプレート関数とは、<code>関数`テンプレート` </code>という形式で記述する関数とテンプレートリテラルを合わせた表現です。
関数の呼び出しに<code>関数(`テンプレート`)</code>ではなく、<code>関数`テンプレート` </code>という書式を使っていることに注意してください。</p>
<p>通常の関数として呼び出した場合、関数の引数にはただの文字列が渡ってきます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">tag</span>(<span class="hljs-params">str</span>) {
    <span class="hljs-comment">// 引数`str`にはただの文字列が渡ってくる</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str); <span class="hljs-comment">// =&gt; &quot;template 0 literal 1&quot;</span>
}
<span class="hljs-comment">// ()をつけて関数を呼び出す</span>
<span class="hljs-title function_">tag</span>(<span class="hljs-string">`template <span class="hljs-subst">${<span class="hljs-number">0</span>}</span> literal <span class="hljs-subst">${<span class="hljs-number">1</span>}</span>`</span>);
</code></pre>
<p>しかし、<code>()</code>ではなく <code>関数`テンプレート` </code> と記述することで、<code>関数</code>が受け取る引数にはタグつきテンプレート向けの値が渡ってきます。
このとき、関数の第一引数にはテンプレートの中身が<code>${}</code>で区切られた文字列の配列、第二引数以降は<code>${}</code>の中に書いた式の評価結果が順番に渡されます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:disable --></p>
<pre><code class="lang-js"><span class="hljs-comment">// 呼び出し方によって受け取る引数の形式が変わる</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">tag</span>(<span class="hljs-params">strings, ...values</span>) {
    <span class="hljs-comment">// stringsは文字列のパーツが${}で区切られた配列となる</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(strings); <span class="hljs-comment">// =&gt; [&quot;template &quot;,&quot; literal &quot;,&quot;&quot;]</span>
    <span class="hljs-comment">// valuesには${}の評価値が順番に入る</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(values); <span class="hljs-comment">// =&gt; [0, 1]</span>
}
<span class="hljs-comment">// ()をつけずにテンプレートを呼び出す</span>
tag<span class="hljs-string">`template <span class="hljs-subst">${<span class="hljs-number">0</span>}</span> literal <span class="hljs-subst">${<span class="hljs-number">1</span>}</span>`</span>;
</code></pre>
<p>どちらも同じ関数ですが、<code>関数`テンプレート` </code>という書式で呼び出すと渡される引数が特殊な形になります。
そのため、タグつきテンプレートで利用する関数のことを<strong>タグ関数</strong>（Tag function）と呼び分けることにします。</p>
<p>まずは引数をどう扱うかを見ていくために、タグつきテンプレートの内容をそのまま結合して返す<code>stringRaw</code>というタグ関数を実装してみます。
Arrayの<code>reduce</code>メソッドを使うことで、テンプレートの文字列と変数を順番に結合できます（<a href="../array/#array-reduce"><code>reduce</code>メソッド</a>については「<a href="../array/">配列</a>」の章を参照）。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// テンプレートを順番どおりに結合した文字列を返すタグ関数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">stringRaw</span>(<span class="hljs-params">strings, ...values</span>) {
    <span class="hljs-comment">// 配列から文字列を返すためにreduceメソッドを利用する</span>
    <span class="hljs-comment">// resultの初期値はstrings[0]の値となる</span>
    <span class="hljs-keyword">return</span> strings.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">result, str, i</span>) =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([result, values[i - <span class="hljs-number">1</span>], str]);
        <span class="hljs-comment">// それぞれループで次のような出力となる</span>
        <span class="hljs-comment">// 1度目: [&quot;template &quot;, 0, &quot; literal &quot;]</span>
        <span class="hljs-comment">// 2度目: [&quot;template 0 literal &quot;, 1, &quot;&quot;]</span>
        <span class="hljs-keyword">return</span> result + values[i - <span class="hljs-number">1</span>] + str;
    });
}
<span class="hljs-comment">// 関数`テンプレートリテラル` という形で呼び出す</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stringRaw<span class="hljs-string">`template <span class="hljs-subst">${<span class="hljs-number">0</span>}</span> literal <span class="hljs-subst">${<span class="hljs-number">1</span>}</span>`</span>); <span class="hljs-comment">// =&gt; &quot;template 0 literal 1&quot;</span>
</code></pre>
<p>ここで実装した<code>stringRaw</code>タグ関数と同様のものが、<code>String.raw</code>メソッド<sup>[ES2015]</sup>として提供されています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>.<span class="hljs-property">raw</span><span class="hljs-string">`template <span class="hljs-subst">${<span class="hljs-number">0</span>}</span> literal <span class="hljs-subst">${<span class="hljs-number">1</span>}</span>`</span>); <span class="hljs-comment">// =&gt; &quot;template 0 literal 1&quot;</span>
</code></pre>
<p>タグつきテンプレート関数を利用することで、テンプレートとなる文字列に対して特定の形式に変換したデータを埋め込むといったテンプレート処理が行えます。</p>
<p>次のコードでは、テンプレート中の変数をURLエスケープしてから埋め込むタグつきテンプレート関数を定義しています。
<code>encodeURIComponent</code>関数は引数の値をURLエスケープする関数です。
<code>escapeURL</code>では受け取った変数を<code>encodeURIComponent</code>関数でURLエスケープしてから埋め込んでいます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// 変数をURLエスケープするタグ関数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">escapeURL</span>(<span class="hljs-params">strings, ...values</span>) {
    <span class="hljs-keyword">return</span> strings.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">result, str, i</span>) =&gt;</span> {
        <span class="hljs-keyword">return</span> result + <span class="hljs-built_in">encodeURIComponent</span>(values[i - <span class="hljs-number">1</span>]) + str;
    });
}

<span class="hljs-keyword">const</span> input = <span class="hljs-string">&quot;A&amp;B&quot;</span>;
<span class="hljs-comment">// escapeURLタグ関数を使ったタグつきテンプレート</span>
<span class="hljs-keyword">const</span> escapedURL = escapeURL<span class="hljs-string">`https://example.com/search?q=<span class="hljs-subst">${input}</span>&amp;sort=desc`</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(escapedURL); <span class="hljs-comment">// =&gt; &quot;https://example.com/search?q=A%26B&amp;sort=desc&quot;</span>
</code></pre>
<p>このようにタグつきテンプレートリテラルを使うことで、コンテキストに応じた処理をつけ加えることができます。
この機能はJavaScript内にHTMLなどの別の言語やDSL（ドメイン固有言語）を埋め込む際に利用されることが多いです。</p>
<h2 id="string-summary"><a name="string-summary" class="plugin-anchor" href="#string-summary"><i class="fa fa-link" aria-hidden="true"></i></a>終わりに </h2>
<p>この章では、JavaScriptにおける文字列(<code>String</code>オブジェクト)について紹介しました。
文字列処理するStringメソッドにはさまざまなものがあり、正規表現と組み合わせて使うものも含まれます。</p>
<p>正規表現は、正規表現のみで1冊の本が作れるようなJavaScript言語内にある別言語です。
詳細は<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Regular_Expressions" title="正規表現 - JavaScript | MDN" target="_blank">MDNの正規表現ドキュメント</a>なども参照してください。</p>
<p>文字列は一見すると単純に見えますが、URLやパスといったコンテキストを持つものもあります。
それらの文字列を安全に扱うためには、コンテキストに応じた処理が必要になります。
また、タグつきテンプレートリテラルを利用することで、テンプレート中の変数を自動でエスケープするといった処理を実現できます。</p>
<blockquote id="fn_1">
<sup>1</sup>. Unicodeのカタカナの一覧 <a href="https://unicode-table.com/jp/#katakana" target="_blank">https://unicode-table.com/jp/#katakana</a> から取り出したテーブルです。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> ↩</a>
</blockquote>
</body></html>
                                

                                </section>
                            
                        </div>
                    </div>
                
<footer class="book_footer">
    <p>Copyright (c) 2016-present <a href="https://github.com/asciidwango/js-primer" target="_blank">jsprimer project</a></p>
</footer>

            </div>

            
                
                <a href="../array/" class="navigation navigation-prev " aria-label="Previous page: 配列">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="../string-unicode/" class="navigation navigation-next " aria-label="Next page: 文字列とUnicode">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"author":"azu","description":"文字列リテラルを使った文字列の作成から検索や置換など基本的な文字列操作について紹介します。また正規表現と組み合わせた文字列操作やタグ付きテンプレート関数を使ったテンプレート処理などについても紹介します。","sponsors":[],"title":"文字列","level":"1.3.15","depth":2,"next":{"title":"文字列とUnicode","level":"1.3.16","depth":2,"path":"basic/string-unicode/README.md","ref":"./basic/string-unicode/README.md","articles":[]},"previous":{"title":"配列","level":"1.3.14","depth":2,"path":"basic/array/README.md","ref":"./basic/array/README.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-lunr","page-toc-button","include-codeblock","anchors","canonical-link","js-console","github-issue-feedback","sandpack"],"root":"./source/","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"docSearch":{"index":"83I8JIFICQ","apiKey":"9169ce4cd84fcf2376f29d9585c89254"},"github-issue-feedback":{"repo":"asciidwango/js-primer","label":"問題を報告する"},"fontsettings":{"theme":"white","family":"sans","size":2},"js-console":{},"canonical-link":{"baseURL":"https://jsprimer.net"},"highlight":{},"page-toc-button":{"maxTocDepth":2,"minTocSize":2},"include-codeblock":{"check":false,"edit":false,"lang":"","fixlang":false,"template":"./resources/gitbook-plugin-include-codeblock.hbs","theme":"chrome","unindent":false},"sandpack":{},"edit-link":{"base":"https://github.com/asciidwango/js-primer/edit/master/source/","label":"Edit"},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"anchors":{}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"IPAexMincho","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"index.md","glossary":"GLOSSARY.md","summary":"README.md"},"variables":{"esversion":"2023","nodeversion":"18.14.0","npmversion":"9.3.1","triplebackticks":"```","console":"<a class=\"gitbook-plugin-js-console\" aria-hidden=\"true\"></a>"},"title":"JavaScript Primer #jsprimer","gitbook":">=3.0.0","description":"JavaScriptの基本的な書き方からアプリケーションの作成などのユースケースを学ぶための入門書です"},"file":{"path":"basic/string/README.md","mtime":"2024-03-17T00:43:12.444Z","type":"markdown"},"gitbook":{"version":"5.1.4","time":"2024-03-17T00:43:38.528Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-page-toc-button/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-js-console/console-ui.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-github-issue-feedback/plugin.js"></script>
        
    
        
        <script src="../../gitbook/honkit-plugin-sandpack/honkit-plugin-sandpack.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

