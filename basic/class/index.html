
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>クラス · JavaScript Primer #jsprimer</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="JavaScriptにおけるクラスの定義方法や継承方法を紹介します。プロトタイプベースの言語であるJavaScriptがどのように継承などを実現しているのかを紹介します。">
        <meta name="generator" content="HonKit 4.0.4">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-page-toc-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-anchors/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

         
    
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="../error-try-catch/" />
    
    
    <link rel="prev" href="../function-this/" />
    

    <link rel="canonical" href="https://jsprimer.net/basic/class/">

<meta name="google-site-verification" content="bMotEbgYwkzA3k4PkuyK_NUdz0bKh-Phz0oUwNmRSVo" />
<style>
    /*
     * Disable antialias
     */
    * {
        -webkit-font-smoothing: initial !important
    }

    body {
        text-rendering: initial !important;
        font-smoothing: initial !important;
    }

    /* deny access chapter */
    .summary li.chapter>span {
        cursor: not-allowed;
        opacity: .3;
    }

    /* console ui */

    .mirror-console-attach-button-wrapper {
        margin-top: -1.275em;
        margin-bottom: 1.275em
    }

    .mirror-console-wrapper {
        margin-top: 1.275em;
        margin-bottom: 1.275em
    }

    /* file name for codeblock */
    .code-filename {
        background-color: #eee;
        display: inline-block;
        padding: 2px 8px;
        line-height: inherit;
        margin-bottom: 0px !important;
    }

    /* Markdown */
    .markdown-section sup,
    .markdown-section sub {
        font-size: 75%;
    }

    .book_footer {
        text-align: center;
        color: #000000;
        background: #ddd;
        font-size: 16px;
        margin-top: 16px;
        padding: 16px;
    }

    /* github-issue-feedback */
    .gitbook-plugin-github-issue-feedback {
        background-color: #333;
        color: #fff;
        opacity: 0.8;
        padding: 4px;
        margin-right: 24px;
        margin-bottom: 4px;
        border-radius: 6px;
    }

    .gitbook-plugin-github-issue-feedback:hover {
        opacity: 1;
    }

    /* Hide footer on mobile */
    /* Use navigation width */
    @media (max-width: 1240px) {
        .book_footer {
            display: none;
        }
    }

    .navigation {
        min-width: 50px;
    }

    @media (min-width: 1240px) {
        .honkit-plugin-sandpack {
            width: calc(100% + 180px);
            margin: 0 0 1em -90px;
        }
    }

    .honkit-plugin-sandpack, .honkit-plugin-sandpack--buttonContainer {
        margin-bottom: 1em;
    }

</style>
<meta name="theme-color" content="#ffffff">
<link rel="manifest" href="../../manifest.json">
<script>
    if ("serviceWorker" in navigator) {
        const isLocalhost = Boolean(
            // preview
            /netlify.com/.test(window.location.hostname) ||
            // local
            window.location.hostname === "localhost" ||
            // [::1] is the IPv6 localhost address.
            window.location.hostname === "[::1]" ||
            // 127.0.0.1/8 is considered localhost for IPv4.
            window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)
        );
        if (!isLocalhost) {
            window.addEventListener("load", () => {
                navigator.serviceWorker.register("../../sw.js");
            });
        }
    }
</script>

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                    この書籍について
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../../intro/">
            
                <a href="../../intro/">
            
                    
                    はじめに
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../../intro/authors/">
            
                <a href="../../intro/authors/">
            
                    
                    著者紹介
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../../intro/preparation/">
            
                <a href="../../intro/preparation/">
            
                    
                    読み始める前の事前準備
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../../intro/feedback/">
            
                <a href="../../intro/feedback/">
            
                    
                    文章の間違いに気づいたら
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../">
            
                <a href="../">
            
                    
                    第一部: 基本文法
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../introduction/">
            
                <a href="../introduction/">
            
                    
                    JavaScriptとは
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../comments/">
            
                <a href="../comments/">
            
                    
                    コメント
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../variables/">
            
                <a href="../variables/">
            
                    
                    変数と宣言
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../read-eval-print/">
            
                <a href="../read-eval-print/">
            
                    
                    値の評価と表示
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="../data-type/">
            
                <a href="../data-type/">
            
                    
                    データ型とリテラル
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="../operator/">
            
                <a href="../operator/">
            
                    
                    演算子
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="../implicit-coercion/">
            
                <a href="../implicit-coercion/">
            
                    
                    暗黙的な型変換
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="../function-declaration/">
            
                <a href="../function-declaration/">
            
                    
                    関数と宣言
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.9" data-path="../statement-expression/">
            
                <a href="../statement-expression/">
            
                    
                    文と式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.10" data-path="../condition/">
            
                <a href="../condition/">
            
                    
                    条件分岐
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.11" data-path="../loop/">
            
                <a href="../loop/">
            
                    
                    ループと反復処理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.12" data-path="../object/">
            
                <a href="../object/">
            
                    
                    オブジェクト
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.13" data-path="../prototype-object/">
            
                <a href="../prototype-object/">
            
                    
                    プロトタイプオブジェクト
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.14" data-path="../array/">
            
                <a href="../array/">
            
                    
                    配列
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.15" data-path="../string/">
            
                <a href="../string/">
            
                    
                    文字列
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.16" data-path="../string-unicode/">
            
                <a href="../string-unicode/">
            
                    
                    文字列とUnicode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.17" data-path="../wrapper-object/">
            
                <a href="../wrapper-object/">
            
                    
                    ラッパーオブジェクト
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.18" data-path="../function-scope/">
            
                <a href="../function-scope/">
            
                    
                    関数とスコープ
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.19" data-path="../function-this/">
            
                <a href="../function-this/">
            
                    
                    関数とthis
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.3.20" data-path="./">
            
                <a href="./">
            
                    
                    クラス
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.21" data-path="../error-try-catch/">
            
                <a href="../error-try-catch/">
            
                    
                    例外処理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.22" data-path="../async/">
            
                <a href="../async/">
            
                    
                    非同期処理:Promise/Async Function
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.23" data-path="../map-and-set/">
            
                <a href="../map-and-set/">
            
                    
                    Map/Set
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.24" data-path="../json/">
            
                <a href="../json/">
            
                    
                    JSON
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.25" data-path="../date/">
            
                <a href="../date/">
            
                    
                    Date
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.26" data-path="../math/">
            
                <a href="../math/">
            
                    
                    Math
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.27" data-path="../module/">
            
                <a href="../module/">
            
                    
                    ECMAScriptモジュール
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.28" data-path="../ecmascript/">
            
                <a href="../ecmascript/">
            
                    
                    ECMAScript
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.29" data-path="../other-parts/">
            
                <a href="../other-parts/">
            
                    
                    第一部: おわりに
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../../use-case/">
            
                <a href="../../use-case/">
            
                    
                    第二部: 応用編（ユースケース）
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../../use-case/setup-local-env/">
            
                <a href="../../use-case/setup-local-env/">
            
                    
                    アプリケーション開発の準備
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../../use-case/ajaxapp/">
            
                <a href="../../use-case/ajaxapp/">
            
                    
                    Ajax通信
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.2.1" data-path="../../use-case/ajaxapp/entrypoint/">
            
                <a href="../../use-case/ajaxapp/entrypoint/">
            
                    
                    エントリーポイント
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.2" data-path="../../use-case/ajaxapp/http/">
            
                <a href="../../use-case/ajaxapp/http/">
            
                    
                    HTTP通信
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.3" data-path="../../use-case/ajaxapp/display/">
            
                <a href="../../use-case/ajaxapp/display/">
            
                    
                    データを表示する
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.4" data-path="../../use-case/ajaxapp/promise/">
            
                <a href="../../use-case/ajaxapp/promise/">
            
                    
                    Promiseを活用する
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../../use-case/nodecli/">
            
                <a href="../../use-case/nodecli/">
            
                    
                    Node.jsでCLIアプリ
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.3.1" data-path="../../use-case/nodecli/helloworld/">
            
                <a href="../../use-case/nodecli/helloworld/">
            
                    
                    Node.jsでHello World
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3.2" data-path="../../use-case/nodecli/argument-parse/">
            
                <a href="../../use-case/nodecli/argument-parse/">
            
                    
                    コマンドライン引数を処理する
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3.3" data-path="../../use-case/nodecli/read-file/">
            
                <a href="../../use-case/nodecli/read-file/">
            
                    
                    ファイルを読み込む
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3.4" data-path="../../use-case/nodecli/md-to-html/">
            
                <a href="../../use-case/nodecli/md-to-html/">
            
                    
                    MarkdownをHTMLに変換する
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3.5" data-path="../../use-case/nodecli/refactor-and-unittest/">
            
                <a href="../../use-case/nodecli/refactor-and-unittest/">
            
                    
                    ユニットテストを記述する
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="../../use-case/todoapp/">
            
                <a href="../../use-case/todoapp/">
            
                    
                    Todoアプリ
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.4.1" data-path="../../use-case/todoapp/entrypoint/">
            
                <a href="../../use-case/todoapp/entrypoint/">
            
                    
                    エントリーポイント
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.2" data-path="../../use-case/todoapp/app-structure/">
            
                <a href="../../use-case/todoapp/app-structure/">
            
                    
                    アプリの構成要素
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.3" data-path="../../use-case/todoapp/form-event/">
            
                <a href="../../use-case/todoapp/form-event/">
            
                    
                    Todoアイテムの追加を実装する
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.4" data-path="../../use-case/todoapp/event-model/">
            
                <a href="../../use-case/todoapp/event-model/">
            
                    
                    イベントとモデル
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.5" data-path="../../use-case/todoapp/update-delete/">
            
                <a href="../../use-case/todoapp/update-delete/">
            
                    
                    Todoアイテムの更新と削除を実装する
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.6" data-path="../../use-case/todoapp/final/">
            
                <a href="../../use-case/todoapp/final/">
            
                    
                    Todoアプリのリファクタリング
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../../appendix/links/">
            
                <a href="../../appendix/links/">
            
                    
                    付録: 参考リンク集
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../../cheatsheet/">
            
                <a href="../../cheatsheet/">
            
                    
                    付録: JavaScriptチートシート
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../../outro/">
            
                <a href="../../outro/">
            
                    
                    おわりに
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                 
                    

<!-- Header -->
<meta name="keywords" content="JavaScript,入門,入門書,チュートリアル,書籍,本,無料,Node.js,ブラウザ"/>
<link rel="author" href="https://www.hatena.ne.jp/efcl/"/>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css"/>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<style>
    .book-header {
        display: flex;
        flex-direction: row;
        background-color: #333;
    }

    /* link color */
    .book-header a {
        color: #fff;
    }

    /* hover color */
    .book-header .btn:hover, .book-header .btn:focus, .book-header a:focus, .book-header a:hover {
        color: hsla(0, 0%, 100%, 0.75) !important;
    }

    /* Mobile header fixed */
    @media (max-width: 768px) {
        /* Headerを固定する */
        .book-header {
            position: fixed;
            width: 100%;
        }

        /* Icon only */
        .book-header-title-img {
            margin: auto 18px auto 0 !important;
        }

        .book-header-title-h {
            display: none;
        }

        /* Header分のズレを入れる */
        .page-wrapper {
            padding-top: 60px;
        }

        /* github-issue-feedbackを非表示にする */
        .gitbook-plugin-github-issue-feedback {
            display: none;
        }
    }

    /* Dynamic created by GitBook*/
    .btn.pull-left.js-toolbar-action {
        order: 1;
    }

    .book-header-title {
        order: 2;
        display: inline-flex;
        flex-direction: row;
        color: #fff;
    }

    .book-header-title:hover {
        color: hsla(0, 0%, 100%, 0.75);
    }

    .book-header-title-img {
        width: 32px;
        height: 32px;
        padding: 0;
        margin: auto 10px auto 0;
    }

    .book-header-title-h {
        font-size: 20px;
        margin: auto;
        padding: 0;
    }

    .header-center {
        order: 3;
        display: inline-flex;
        flex-direction: column;
        justify-content: center;
        /* self */
        flex-grow: 1;
        flex-shrink: 0;
        flex-basis: auto;
    }

    .header-right {
        order: 4;
        display: inline-flex;
        flex-direction: row;
        justify-content: center;
        align-items: center;
        /* icon size */
        font-size: 24px;
    }

    .amazon-link, .github-link {
        color: #fff;
        /* Padding and make Vertical */
        display: inline-flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding-left: 4px;
        padding-right: 4px;
    }

    /* Desktop */
    @media (min-width: 768px) {
        .header-center {
            align-items: center;
        }

        .header-right {
            margin-right: 24px;
        }
    }

    /* DocSearch */
    @media (max-width: 768px) {
        .algolia-autocomplete .ds-dropdown-menu {
            max-width: calc(100vw - 32px) !important;
            min-width: calc(100vw - 32px) !important;
            width: calc(100vw - 32px) !important;
            /* negative margin
              This is absolute element
              */
            margin-left: -32px !important;
        }

        .algolia-autocomplete .algolia-docsearch-suggestion--content {
            width: 100% !important;
            padding-left: 0 !important;
        }

        .algolia-autocomplete .algolia-docsearch-suggestion--content:before {
            display: none !important;
        }

        .algolia-autocomplete .algolia-docsearch-suggestion--subcategory-column {
            display: none !important;
        }

        .algolia-autocomplete.algolia-autocomplete-right .ds-dropdown-menu {
            right: inherit !important
        }

        .algolia-autocomplete.algolia-autocomplete-right .ds-dropdown-menu::before {
            right: 50%;
        }

        .sbx-custom {
            width: 92px !important;
            padding: initial !important;
        }

        .amazon-link {
            display: none;
        }
    }

    /* SearchBox */
    .searchbarWrapper {
        height: 50px;
    }


    .sbx-custom {
        display: inline-block;
        position: relative;
        min-width: 150px;
        width: 300px;
        max-width: 300px;
        height: 33px;
        white-space: nowrap;
        box-sizing: border-box;
        font-size: 14px;
    }

    .sbx-custom__wrapper {
        width: 100%;
        height: 100%;
    }

    .sbx-custom__input {
        display: inline-block;
        -webkit-transition: box-shadow .4s ease, background .4s ease;
        transition: box-shadow .4s ease, background .4s ease;
        border: 0;
        border-radius: 5px;
        box-shadow: inset 0 0 0 2px #CCCCCC;
        background: #FFFFFF;
        padding: 0 27px 0 33px;
        width: 100%;
        height: 100%;
        vertical-align: middle;
        white-space: normal;
        font-size: inherit;
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
    }

    .sbx-custom__input::-webkit-search-decoration, .sbx-custom__input::-webkit-search-cancel-button, .sbx-custom__input::-webkit-search-results-button, .sbx-custom__input::-webkit-search-results-decoration {
        display: none;
    }

    .sbx-custom__input:hover {
        box-shadow: inset 0 0 0 2px #b3b3b3;
    }

    .sbx-custom__input:focus, .sbx-custom__input:active {
        outline: 0;
        box-shadow: inset 0 0 0 2px #4B54DE;
        background: #FFFFFF;
    }

    .sbx-custom__input::-webkit-input-placeholder {
        color: #BBBBBB;
    }

    .sbx-custom__input::-moz-placeholder {
        color: #BBBBBB;
    }

    .sbx-custom__input:-ms-input-placeholder {
        color: #BBBBBB;
    }

    .sbx-custom__input::placeholder {
        color: #BBBBBB;
    }

    .sbx-custom__submit {
        position: absolute;
        top: 0;
        right: inherit;
        left: 0;
        margin: 0;
        border: 0;
        border-radius: 4px 0 0 4px;
        background-color: rgba(255, 255, 255, 0);
        padding: 0;
        width: 33px;
        height: 100%;
        vertical-align: middle;
        text-align: center;
        font-size: inherit;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }

    .sbx-custom__submit::before {
        display: inline-block;
        margin-right: -4px;
        height: 100%;
        vertical-align: middle;
        content: '';
    }

    .sbx-custom__submit:hover, .sbx-custom__submit:active {
        cursor: pointer;
    }

    .sbx-custom__submit:focus {
        outline: 0;
    }

    .sbx-custom__submit svg {
        width: 17px;
        height: 17px;
        vertical-align: middle;
        fill: #3A33D1;
    }

    .sbx-custom__reset {
        display: none;
        position: absolute;
        top: 4px;
        right: 4px;
        margin: 0;
        border: 0;
        background: none;
        cursor: pointer;
        padding: 0;
        font-size: inherit;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        fill: rgba(0, 0, 0, 0.5);
    }

    .sbx-custom__reset:focus {
        outline: 0;
    }

    .sbx-custom__reset svg {
        display: block;
        margin: 4px;
        width: 17px;
        height: 17px;
    }

    .sbx-custom__input:valid ~ .sbx-custom__reset {
        display: block;
        -webkit-animation-name: sbx-reset-in;
        animation-name: sbx-reset-in;
        -webkit-animation-duration: .15s;
        animation-duration: .15s;
    }

    @-webkit-keyframes sbx-reset-in {
        0% {
            -webkit-transform: translate3d(-20%, 0, 0);
            transform: translate3d(-20%, 0, 0);
            opacity: 0;
        }
        100% {
            -webkit-transform: none;
            transform: none;
            opacity: 1;
        }
    }

    @keyframes sbx-reset-in {
        0% {
            -webkit-transform: translate3d(-20%, 0, 0);
            transform: translate3d(-20%, 0, 0);
            opacity: 0;
        }
        100% {
            -webkit-transform: none;
            transform: none;
            opacity: 1;
        }
    }
</style>
<div class="book-header" role="navigation">
    
    <a class="book-header-title" href="../..">
        <img class="book-header-title-img" alt="JavaScript Primer"
             src="../../gitbook/icons/icon-128x128.png"/>
        <h2 class="book-header-title-h" title="JavaScript Primer - 迷わないための入門書">JavaScript Primer</h2>
    </a>
    <div class="searchbarWrapper header-center">
        <svg xmlns="http://www.w3.org/2000/svg" style="display:none">
            <symbol xmlns="http://www.w3.org/2000/svg" id="sbx-icon-search-8" viewBox="0 0 40 40">
                <path d="M16 32c8.835 0 16-7.165 16-16 0-8.837-7.165-16-16-16C7.162 0 0 7.163 0 16c0 8.835 7.163 16 16 16zm0-5.76c5.654 0 10.24-4.586 10.24-10.24 0-5.656-4.586-10.24-10.24-10.24-5.656 0-10.24 4.584-10.24 10.24 0 5.654 4.584 10.24 10.24 10.24zM28.156 32.8c-1.282-1.282-1.278-3.363.002-4.643 1.282-1.284 3.365-1.28 4.642-.003l6.238 6.238c1.282 1.282 1.278 3.363-.002 4.643-1.283 1.283-3.366 1.28-4.643.002l-6.238-6.238z"
                      fill-rule="evenodd"></path>
            </symbol>
            <symbol xmlns="http://www.w3.org/2000/svg" id="sbx-icon-clear-5" viewBox="0 0 20 20">
                <path d="M10 20c5.523 0 10-4.477 10-10S15.523 0 10 0 0 4.477 0 10s4.477 10 10 10zm1.35-10.123l3.567 3.568-1.225 1.226-3.57-3.568-3.567 3.57-1.226-1.227 3.568-3.568-3.57-3.57 1.227-1.224 3.568 3.568 3.57-3.567 1.224 1.225-3.568 3.57zM10 18.272c4.568 0 8.272-3.704 8.272-8.272S14.568 1.728 10 1.728 1.728 5.432 1.728 10 5.432 18.272 10 18.272z"
                      fill-rule="evenodd"></path>
            </symbol>
        </svg>

        <form novalidate="novalidate" onsubmit="return false;" class="searchbox sbx-custom">
            <div role="search" class="sbx-custom__wrapper">
                <input name="search" placeholder="Search words" autocomplete="off" required="required"
                       class="sbx-custom__input" type="search">
                <button type="submit" title="Submit your search query." class="sbx-custom__submit">
                    <svg role="img" aria-label="Search">
                        <use xlink:href="#sbx-icon-search-8"></use>
                    </svg>
                </button>
                <button type="reset" title="Clear the search query." class="sbx-custom__reset">
                    <svg role="img" aria-label="Reset">
                        <use xlink:href="#sbx-icon-clear-5"></use>
                    </svg>
                </button>
            </div>
        </form>
    </div>
    <div class="header-right">
        <!-- Icon: https://www.iconfinder.com/iconsets/circle-payment -->
        <a class="amazon-link" title="Amazon: JavaScript Primer 迷わないための入門書"
           href="https://www.amazon.co.jp/dp/4048930737/" target="_blank"><img
                width="22"
                height="22"
                style="margin: 1px;"
                src="../../gitbook/icons/amazon-icon.png" alt=""></a>
        <a class="github-link" title="GitHub: asciidwango/js-primer" href="https://github.com/asciidwango/js-primer"
           target="_blank"><i
                class="fa fa-github fa-fw"></i></a>
    </div>
</div>

<script type="text/javascript">
    document.querySelector(".searchbox [type=\"reset\"]").addEventListener("click", function() {
        this.parentNode.querySelector("input").focus();
    });
</script>
<script>
    var search = docsearch({
        apiKey: "fd28ebaba94be0c39fb9fa1b2fed4f23", // use a SEARCH-ONLY api key here
        indexName: "asciidwango",
        inputSelector: ".sbx-custom__input",
        debug: false // set to `true` if you want to inspect the dropdown menu's CSS
    });
</script>
<script>
    window.addEventListener("DOMContentLoaded", function () {
        gitbook.events.on("page.change", function () {
            setTimeout(() => console.clear(), 1000);
        });
    });
</script>
<script type="text/javascript">
    (function(){var t,e,n,r,a;for(t=function(){var t;return t=[],function(){var e,n,r,a;for(n=["init","start","stop","user","track","action","event","goal","chat","buy","page","view","admin","group","alias","ready","link","form","click","submit","cmd","emit","on","send","css","js","style","option","get","set","collection"],e=function(e){return function(){return t.push([e].concat(Array.prototype.slice.call(arguments,0)))}},r=0,a=[];r<n.length;)t[n[r]]=e(n[r]),a.push(r++);return a}(),t.init=function(e,n){var r,a;return t.api_key=e,t.options=n||{},a=document.createElement("script"),a.type="text/javascript",a.async=!0,a.charset="utf-8",a.src=t.options.tracker_url||"https://static.karte.io/libs/tracker.js",r=document.getElementsByTagName("script")[0],r.parentNode.insertBefore(a,r)},t},r=window.karte_tracker_names||["tracker"],e=0,n=r.length;n>e;e++)a=r[e],window[a]||(window[a]=t());tracker.init("a2d22604ec1d1c6d9d53d9d3eb87961d", { spa_mode: { reset_past_actions: true, close_actions: true }})}).call(this);
    window.addEventListener("DOMContentLoaded", function(){
        gitbook.events.on("page.change", function() {
            tracker.view();
        });
    });
</script>





                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <html><head></head><body><h1 id="class"><a name="class" class="plugin-anchor" href="#class"><i class="fa fa-link" aria-hidden="true"></i></a>クラス </h1>
<p>「クラス」と一言にいってもさまざまであるため、ここでは<strong>構造</strong>、<strong>動作</strong>、<strong>状態</strong>を定義できるものを指すことにします。
また、この章では概念を示す場合は<strong>クラス</strong>と呼び、クラスに関する構文（記述するコード）のことを<code>class</code>構文と呼びます。</p>
<p><strong>クラス</strong>とは<strong>動作</strong>や<strong>状態</strong>を定義した<strong>構造</strong>です。
クラスからはインスタンスと呼ばれるオブジェクトを作成でき、インスタンスはクラスに定義した<strong>動作</strong>を継承し、<strong>状態</strong>は動作によって変化します。
とても抽象的なことに思えますが、これは今までオブジェクトや関数を使って表現してきたものです。
JavaScriptではES2015より前までは<code>class</code>構文はなく、関数を使ってクラスのようなものを表現して扱っていました。</p>
<p>ES2015でクラスを表現するための<code>class</code>構文が導入されましたが、この<code>class</code>構文で定義したクラスは関数オブジェクトの一種です。
<code>class</code>構文ではプロトタイプベースの継承の仕組みを使って関数でクラスを表現しています。
そのため、<code>class</code>構文はクラスを作るための関数定義や継承をパターン化した書き方と言えます。</p>
<p>また、関数の定義方法として関数宣言文と関数式があるように、クラスにもクラス宣言文とクラス式があります。 このように関数とクラスは似ている部分が多いです。</p>
<p>この章では、<code>class</code>構文でのクラスの定義や継承、クラスの性質について学んでいきます。</p>
<h2 id="class-declaration"><a name="class-declaration" class="plugin-anchor" href="#class-declaration"><i class="fa fa-link" aria-hidden="true"></i></a>クラスの定義 </h2>
<p>クラスを定義するには<code>class</code>構文を使います。 クラスの定義方法にはクラス宣言文とクラス式があります。</p>
<p>まずは、クラス宣言文によるクラスの定義方法を見ていきます。</p>
<p>クラス宣言文では<code>class</code>キーワードを使い、<code>class クラス名{ }</code>のようにクラスの<strong>構造</strong>を定義できます。</p>
<p>クラスは必ずコンストラクタを持ち、<code>constructor</code>という名前のメソッドとして定義します。
コンストラクタとは、そのクラスからインスタンスを作成する際にインスタンスに関する<strong>状態</strong>の初期化を行うメソッドです。
<code>constructor</code>メソッドに定義した処理は、クラスをインスタンス化したときに自動的に呼び出されます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-comment">// コンストラクタ関数の処理</span>
        <span class="hljs-comment">// インスタンス化されるときに自動的に呼び出される</span>
    }
}
</code></pre>
<p>もうひとつの定義方法であるクラス式は、クラスを値として定義する方法です。 クラス式ではクラス名を省略できます。これは関数式における匿名関数と同じです。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> MyClass = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {}
};

<span class="hljs-keyword">const</span> AnonymousClass = <span class="hljs-class"><span class="hljs-keyword">class</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {}
};
</code></pre>
<p>コンストラクタ関数内で、何も処理がない場合はコンストラクタの記述を省略できます。
省略した場合でも自動的に空のコンストラクタが定義されるため、クラスにはコンストラクタが必ず存在します。</p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassA</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-comment">// コンストラクタの処理が必要なら書く</span>
    }
}
<span class="hljs-comment">// コンストラクタの処理が不要な場合は省略できる</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassB</span> </span>{
}
</code></pre>
<h2 id="class-instance"><a name="class-instance" class="plugin-anchor" href="#class-instance"><i class="fa fa-link" aria-hidden="true"></i></a>クラスのインスタンス化 </h2>
<p>クラスは<code>new</code>演算子でインスタンスであるオブジェクトを作成できます。
<code>class</code>構文で定義したクラスからインスタンスを作成することを<strong>インスタンス化</strong>と呼びます。
あるインスタンスが指定したクラスから作成されたものかを判定するには<code>instanceof</code>演算子が利用できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
}
<span class="hljs-comment">// `MyClass`をインスタンス化する</span>
<span class="hljs-keyword">const</span> myClass = <span class="hljs-keyword">new</span> MyClass();
<span class="hljs-comment">// 毎回新しいインスタンス(オブジェクト)を作成する</span>
<span class="hljs-keyword">const</span> myClassAnother = <span class="hljs-keyword">new</span> MyClass();
<span class="hljs-comment">// それぞれのインスタンスは異なるオブジェクト</span>
<span class="hljs-built_in">console</span>.log(myClass === myClassAnother); <span class="hljs-comment">// =&gt; false</span>
<span class="hljs-comment">// クラスのインスタンスかどうかは`instanceof`演算子で判定できる</span>
<span class="hljs-built_in">console</span>.log(myClass <span class="hljs-keyword">instanceof</span> MyClass); <span class="hljs-comment">// =&gt; true</span>
<span class="hljs-built_in">console</span>.log(myClassAnother <span class="hljs-keyword">instanceof</span> MyClass); <span class="hljs-comment">// =&gt; true</span>
</code></pre>
<p>このままでは何も処理がない空のクラスなので、値を持ったクラスを定義してみましょう。</p>
<p>クラスではインスタンスの初期化処理をコンストラクタ関数で行います。 コンストラクタ関数は<code>new</code>演算子でインスタンス化する際に自動的に呼び出されます。
コンストラクタ関数内での<code>this</code>はこれから新しく作るインスタンスオブジェクトとなります。</p>
<p>次のコードでは、<code>x</code>座標と<code>y</code>座標の値を持つ<code>Point</code>というクラスを定義しています。
コンストラクタ関数（<code>constructor</code>）の中でインスタンスオブジェクト（<code>this</code>）の<code>x</code>と<code>y</code>プロパティに値を代入して初期化しています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>{
    <span class="hljs-comment">// コンストラクタ関数の仮引数として`x`と`y`を定義</span>
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> {
        <span class="hljs-comment">// コンストラクタ関数における`this`はインスタンスを示すオブジェクト</span>
        <span class="hljs-comment">// インスタンスの`x`と`y`プロパティにそれぞれ値を設定する</span>
        <span class="hljs-built_in">this</span>.x = x;
        <span class="hljs-built_in">this</span>.y = y;
    }
}
</code></pre>
<p>この<code>Point</code>クラスのインスタンスを作成するには<code>new</code>演算子を使います。 <code>new</code>演算子には関数呼び出しと同じように引数を渡すことができます。
<code>new</code>演算子の引数はクラスの<code>constructor</code>メソッド（コンストラクタ関数）の仮引数に渡されます。
そして、コンストラクタの中ではインスタンスオブジェクト（<code>this</code>）の初期化処理を行います。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>{
    <span class="hljs-comment">// 2. コンストラクタ関数の仮引数として`x`には`3`、`y`には`4`が渡る</span>
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> {
        <span class="hljs-comment">// 3. インスタンス(`this`)の`x`と`y`プロパティにそれぞれ値を設定する</span>
        <span class="hljs-built_in">this</span>.x = x;
        <span class="hljs-built_in">this</span>.y = y;
        <span class="hljs-comment">// コンストラクタではreturn文は書かない</span>
    }
}

<span class="hljs-comment">// 1. コンストラクタを`new`演算子で引数とともに呼び出す</span>
<span class="hljs-keyword">const</span> point = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
<span class="hljs-comment">// 4. `Point`のインスタンスである`point`の`x`と`y`プロパティには初期化された値が入る</span>
<span class="hljs-built_in">console</span>.log(point.x); <span class="hljs-comment">// =&gt; 3</span>
<span class="hljs-built_in">console</span>.log(point.y); <span class="hljs-comment">// =&gt; 4</span>
</code></pre>
<p>このようにクラスからインスタンスを作成するには必ず<code>new</code>演算子を使います。</p>
<p>一方、クラスは通常の関数として呼ぶことができません。
これは、クラスのコンストラクタはインスタンス（<code>this</code>）を初期化する場所であり、通常の関数とは役割が異なるためです。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {}
}
<span class="hljs-comment">// クラスは関数として呼び出すことはできない</span>
MyClass(); <span class="hljs-comment">// =&gt; TypeError: class constructors must be invoked with |new|</span>
</code></pre>
<p>また、コンストラクタは初期化処理を書く場所であるため、<code>return</code>文で値を返すべきではありません。
JavaScriptでは、コンストラクタ関数が任意のオブジェクトを返すことが可能ですが、行うべきではありません。
なぜなら、コンストラクタは<code>new</code>演算子で呼び出し、その評価結果はクラスのインスタンスを期待するのが一般的であるためです。</p>
<p>次のコードのようにコンストラクタで返した値が<code>new</code>演算子で呼び出した際の返り値となります。 このような書き方は混乱を生むため避けるべきです。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// 非推奨の例: コンストラクタで値を返すべきではない</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> {
        <span class="hljs-comment">// `this`の代わりにただのオブジェクトを返せる</span>
        <span class="hljs-keyword">return</span> { x, y };
    }
}

<span class="hljs-comment">// `new`演算子の結果はコンストラクタ関数が返したただのオブジェクト</span>
<span class="hljs-keyword">const</span> point = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
<span class="hljs-built_in">console</span>.log(point); <span class="hljs-comment">// =&gt; { x: 3, y: 4 }</span>
<span class="hljs-comment">// Pointクラスのインスタンスではない</span>
<span class="hljs-built_in">console</span>.log(point <span class="hljs-keyword">instanceof</span> Point); <span class="hljs-comment">// =&gt; false</span>
</code></pre>
<h3 id="class-name-start-upper-case"><a name="class-name-start-upper-case" class="plugin-anchor" href="#class-name-start-upper-case"><i class="fa fa-link" aria-hidden="true"></i></a>[Note] クラス名は大文字ではじめる </h3>
<p>JavaScriptでは慣習としてクラス名には大文字ではじまる名前をつけます。
これは、変数名にキャメルケースを使う慣習があるのと同じで、名前自体に特別なルールがあるわけではありません。
クラス名を大文字にしておき、そのインスタンスは小文字で開始すれば名前が被らないという合理的な理由で好まれています。</p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thing</span> </span>{}
<span class="hljs-keyword">const</span> thing = <span class="hljs-keyword">new</span> Thing();
</code></pre>
<h3 id="class-vs-function"><a name="class-vs-function" class="plugin-anchor" href="#class-vs-function"><i class="fa fa-link" aria-hidden="true"></i></a>[コラム] <code>class</code>構文と関数でのクラスの違い </h3>
<p>ES2015より前はこれらのクラスを<code>class</code>構文ではなく、関数で表現していました。
その表現方法は人によってさまざまで、これも<code>class</code>構文という統一した記法が導入された理由の1つです。</p>
<p>次のコードは、関数でクラスを実装した1つの例です。 この関数でのクラス表現は、継承の仕組みなどは省かれていますが、<code>class</code>構文とよく似ています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// コンストラクタ関数</span>
<span class="hljs-keyword">const</span> Point = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PointConstructor</span>(<span class="hljs-params">x, y</span>) </span>{
    <span class="hljs-comment">// インスタンスの初期化処理</span>
    <span class="hljs-built_in">this</span>.x = x;
    <span class="hljs-built_in">this</span>.y = y;
};

<span class="hljs-comment">// `new`演算子でコンストラクタ関数から新しいインスタンスを作成</span>
<span class="hljs-keyword">const</span> point = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
</code></pre>
<p>大きな違いとして、<code>class</code>構文で定義したクラスは関数として呼び出すことができません。
クラスは<code>new</code>演算子でインスタンス化して使うものなので、これはクラスの誤用を防ぐ仕様です。
一方、関数でのクラス表現はただの関数なので、当然関数として呼び出せます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// 関数でのクラス表現</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyClassLike</span>(<span class="hljs-params"></span>) </span>{
}
<span class="hljs-comment">// 関数なので関数として呼び出せる</span>
MyClassLike();

<span class="hljs-comment">// `class`構文でのクラス</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
}
<span class="hljs-comment">// クラスは関数として呼び出すと例外が発生する</span>
MyClass(); <span class="hljs-comment">// =&gt; TypeError: class constructors must be invoked with |new|</span>
</code></pre>
<p>このように、関数でクラスのようなものを実装した場合には、関数として呼び出せてしまう問題があります。
このような問題を避けるためにもクラスは<code>class</code>構文を使って実装します。</p>
<h2 id="class-prototype-method-definition"><a name="class-prototype-method-definition" class="plugin-anchor" href="#class-prototype-method-definition"><i class="fa fa-link" aria-hidden="true"></i></a>クラスのプロトタイプメソッドの定義 </h2>
<p>クラスの<strong>動作</strong>はメソッドによって定義できます。
<code>constructor</code>メソッドは初期化時に呼ばれる特殊なメソッドですが、<code>class</code>構文ではクラスに対して自由にメソッドを定義できます。
このクラスに定義したメソッドは作成したインスタンスが持つ動作となります。</p>
<p>次のように<code>class</code>構文ではクラスに対してメソッドを定義できます。
メソッドの中からクラスのインスタンスを参照するには、<code>constructor</code>メソッドと同じく<code>this</code>を使います。
このクラスのメソッドにおける<code>this</code>は「<a href="../function-this/">関数とthis</a>」の章で学んだメソッドと同じくベースオブジェクトを参照します。</p>
<!-- doctest:disable -->
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> クラス </span>{
    メソッド() {
        <span class="hljs-comment">// ここでの`this`はベースオブジェクトを参照</span>
    }
}

<span class="hljs-keyword">const</span> インスタンス = <span class="hljs-keyword">new</span> クラス();
<span class="hljs-comment">// メソッド呼び出しのベースオブジェクト(`this`)は`インスタンス`となる</span>
インスタンス.メソッド();
</code></pre>
<p>クラスのプロトタイプメソッド定義では、オブジェクトにおけるメソッドとは異なり<code>key : value</code>のように<code>:</code>区切りでメソッドを定義できないことに注意してください。
つまり、次のような書き方は構文エラー（<code>SyntaxError</code>）となります。</p>
<!-- textlint-disable -->
<!-- doctest:disable -->
<pre><code class="lang-js"><span class="hljs-comment">// クラスでは次のようにメソッドを定義できない</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> クラス </span>{
   <span class="hljs-comment">// SyntaxError</span>
   メソッド: <span class="hljs-function">() =&gt;</span> {}
   <span class="hljs-comment">// SyntaxError</span>
   メソッド: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{}
}
</code></pre>
<!-- textlint-enable -->
<p>このメソッド定義の構文でクラスに対して定義したメソッドは、クラスの各インスタンスから<strong>共有されるメソッド</strong>となります。
このインスタンス間で共有されるメソッドのことを<strong>プロトタイプメソッド</strong>と呼びます。</p>
<p>次のコードでは、<code>Counter</code>クラスに<code>increment</code>メソッドを定義しています。
このときの<code>Counter</code>クラスのインスタンスは、それぞれ別々の状態（<code>count</code>プロパティ）を持ちます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">this</span>.count = <span class="hljs-number">0</span>;
    }
    <span class="hljs-comment">// `increment`メソッドをクラスに定義する</span>
    <span class="hljs-function"><span class="hljs-title">increment</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-comment">// `this`は`Counter`のインスタンスを参照する</span>
        <span class="hljs-built_in">this</span>.count++;
    }
}
<span class="hljs-keyword">const</span> counterA = <span class="hljs-keyword">new</span> Counter();
<span class="hljs-keyword">const</span> counterB = <span class="hljs-keyword">new</span> Counter();
<span class="hljs-comment">// `counterA.increment()`のベースオブジェクトは`counterA`インスタンス</span>
counterA.increment();
<span class="hljs-comment">// 各インスタンスの持つプロパティ(状態)は異なる</span>
<span class="hljs-built_in">console</span>.log(counterA.count); <span class="hljs-comment">// =&gt; 1</span>
<span class="hljs-built_in">console</span>.log(counterB.count); <span class="hljs-comment">// =&gt; 0</span>
</code></pre>
<p>このときの<code>increment</code>メソッドはプロトタイプメソッドとして定義されています。
プロトタイプメソッドは各インスタンス間(<code>counterA</code>と<code>counterB</code>)で共有されます。
そのため、次のように各インスタンスの<code>increment</code>メソッドの参照先は同じとなっていることがわかります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">this</span>.count = <span class="hljs-number">0</span>;
    }
    <span class="hljs-function"><span class="hljs-title">increment</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">this</span>.count++;
    }
}
<span class="hljs-keyword">const</span> counterA = <span class="hljs-keyword">new</span> Counter();
<span class="hljs-keyword">const</span> counterB = <span class="hljs-keyword">new</span> Counter();
<span class="hljs-comment">// 各インスタンスオブジェクトのメソッドは共有されている(同じ関数を参照している)</span>
<span class="hljs-built_in">console</span>.log(counterA.increment === counterB.increment); <span class="hljs-comment">// =&gt; true</span>
</code></pre>
<p>プロトタイプメソッドがなぜインスタンス間で共有されているのかは、クラスの継承の仕組みと密接に関係しています。
プロトタイプメソッドの仕組みについては後ほど解説します。</p>
<p>ここでは、次のような構文でクラスにメソッドを定義すると、各インスタンスで共有されるプロトタイプメソッドとして定義されるということが理解できていれば問題ありません。</p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> クラス </span>{
    メソッド() {
        <span class="hljs-comment">// このメソッドはプロトタイプメソッドとして定義される</span>
    }
}
</code></pre>
<h2 id="class-accessor-property"><a name="class-accessor-property" class="plugin-anchor" href="#class-accessor-property"><i class="fa fa-link" aria-hidden="true"></i></a>クラスのアクセッサプロパティの定義 </h2>
<!-- textlint-disable no-js-function-paren -->
<p>クラスに対してメソッドを定義できますが、メソッドは<code>インスタンス名.メソッド名()</code>のように呼び出す必要があります。
クラスでは、プロパティの参照（getter）、プロパティへの代入（setter）時に呼び出される特殊なメソッドを定義できます。
このメソッドはプロパティのように振る舞うため<strong>アクセッサプロパティ</strong>と呼ばれます。</p>
<!-- textlint-enable no-js-function-paren -->
<p>次のコードでは、プロパティの参照（getter）、プロパティへの代入（setter）に対するアクセッサプロパティを定義しています。
アクセッサプロパティはメソッド名（プロパティ名）の前に<code>get</code>または<code>set</code>をつけるだけです。
getter（<code>get</code>）には仮引数はありませんが、必ず値を返す必要があります。
setter（<code>set</code>）の仮引数にはプロパティへ代入する値が入りますが、値を返す必要はありません。</p>
<!-- doctest:disable -->
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> クラス </span>{
    <span class="hljs-comment">// getter</span>
    get プロパティ名() {
        <span class="hljs-keyword">return</span> 値;
    }
    <span class="hljs-comment">// setter</span>
    set プロパティ名(仮引数) {
        <span class="hljs-comment">// setterの処理</span>
    }
}
<span class="hljs-keyword">const</span> インスタンス = <span class="hljs-keyword">new</span> クラス();
インスタンス.プロパティ名; <span class="hljs-comment">// getterが呼び出される</span>
インスタンス.プロパティ名 = 値; <span class="hljs-comment">// setterが呼び出される</span>
</code></pre>
<p>次のコードでは、<code>NumberWrapper</code>クラスの<code>value</code>プロパティをアクセッサプロパティとして定義しています。
<code>value</code>プロパティへアクセスした際にそれぞれ定義したgetterとsetterが呼ばれているのがわかります。
このアクセッサプロパティで実際に読み書きされているのは、<code>NumberWrapper</code>インスタンスの<code>_value</code>プロパティとなります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberWrapper</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">value</span>)</span> {
        <span class="hljs-built_in">this</span>._value = value;
    }
    <span class="hljs-comment">// `_value`プロパティの値を返すgetter</span>
    <span class="hljs-keyword">get</span> <span class="hljs-title">value</span>() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;getter&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._value;
    }
    <span class="hljs-comment">// `_value`プロパティに値を代入するsetter</span>
    <span class="hljs-keyword">set</span> <span class="hljs-title">value</span>(<span class="hljs-params">newValue</span>) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;setter&quot;</span>);
        <span class="hljs-built_in">this</span>._value = newValue;
    }
}

<span class="hljs-keyword">const</span> numberWrapper = <span class="hljs-keyword">new</span> NumberWrapper(<span class="hljs-number">1</span>);
<span class="hljs-comment">// &quot;getter&quot;とコンソールに表示される</span>
<span class="hljs-built_in">console</span>.log(numberWrapper.value); <span class="hljs-comment">// =&gt; 1</span>
<span class="hljs-comment">// &quot;setter&quot;とコンソールに表示される</span>
numberWrapper.value = <span class="hljs-number">42</span>;
<span class="hljs-comment">// &quot;getter&quot;とコンソールに表示される</span>
<span class="hljs-built_in">console</span>.log(numberWrapper.value); <span class="hljs-comment">// =&gt; 42</span>
</code></pre>
<!-- Note: インスタンスオブジェクトのアクセッサプロパティ
インスタンスオブジェクトへも定義できるが、メソッドとは異なり意味の違いがでることはないため省略。
またフィールドとして定義することはできないため対比は意味がない。
-->
<h3 id="underbar-private-property"><a name="underbar-private-property" class="plugin-anchor" href="#underbar-private-property"><i class="fa fa-link" aria-hidden="true"></i></a>[コラム] <code>_</code>（アンダーバー）から始まるプロパティ名 </h3>
<p>NumberWrapperの<code>value</code>のアクセッサプロパティで実際に読み書きしているのは、<code>_value</code>プロパティです。
このように、外から直接読み書きしてほしくないプロパティを<code>_</code>（アンダーバー）から始まる名前にするのはただの習慣であるため、構文としての意味はありません。</p>
<p>ECMAScript 2022から、外から直接読み書きしてほしくないプライベートなプロパティを定義するPrivateクラスフィールド構文が追加されました。
Privateクラスフィールド構文では<code>#</code>（ハッシュ）記号をプロパティ名の前につけます。
そのため、外から直接読み書きしてほしくないプロパティを<code>_</code>からはじめるという慣習は、Privateクラスフィールド構文の利用が進むにつれて使われなくなっていくと考えています。</p>
<p>Privateクラスフィールド構文については、この後に解説します。</p>
<h3 id="array-like-length"><a name="array-like-length" class="plugin-anchor" href="#array-like-length"><i class="fa fa-link" aria-hidden="true"></i></a><code>Array.prototype.length</code>をアクセッサプロパティで再現する </h3>
<p>getterやsetterを利用しないと実現が難しいものとして、<code>Array.prototype.length</code>プロパティがあります。
Arrayの<code>length</code>プロパティへ値を代入すると、そのインデックス以降の要素は自動的に削除される仕様になっています。</p>
<p>次のコードでは、配列の要素数（<code>length</code>プロパティ）を小さくすると配列の要素が削除されています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-comment">// 要素数を減らすと、インデックス以降の要素が削除される</span>
array.length = <span class="hljs-number">2</span>;
<span class="hljs-built_in">console</span>.log(array.join(<span class="hljs-string">&quot;, &quot;</span>)); <span class="hljs-comment">// =&gt; &quot;1, 2&quot;</span>
<span class="hljs-comment">// 要素数だけを増やしても、配列の中身は空要素が増えるだけ</span>
array.length = <span class="hljs-number">5</span>;
<span class="hljs-built_in">console</span>.log(array.join(<span class="hljs-string">&quot;, &quot;</span>)); <span class="hljs-comment">// =&gt; &quot;1, 2, , , &quot;</span>
</code></pre>
<p>この<code>length</code>プロパティの挙動を再現する<code>ArrayLike</code>クラスを実装してみます。
Arrayの<code>length</code>プロパティは、<code>length</code>プロパティへ値を代入した際に次のようなことを行っています。</p>
<ul>
<li>現在要素数より小さな<strong>要素数</strong>が指定された場合、その<strong>要素数</strong>を変更し、配列の末尾の要素を削除する</li>
<li>現在要素数より大きな<strong>要素数</strong>が指定された場合、その<strong>要素数</strong>だけを変更し、配列の実際の要素はそのままにする</li>
</ul>
<!-- Note:

- 仕様的にもIf newLen ≥ oldLenでは`length`だけを変更している
- <https://tc39.es/ecma262/#sec-arraysetlength>

-->
<p>ArrayLikeの<code>length</code>プロパティのsetterで要素の追加や削除を実装することで、配列のような<code>length</code>プロパティを実装できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">/**
 * 配列のようなlengthを持つクラス
 */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayLike</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">items = []</span>)</span> {
        <span class="hljs-built_in">this</span>._items = items;
    }

    <span class="hljs-keyword">get</span> <span class="hljs-title">items</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._items;
    }

    <span class="hljs-keyword">get</span> <span class="hljs-title">length</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._items.length;
    }

    <span class="hljs-keyword">set</span> <span class="hljs-title">length</span>(<span class="hljs-params">newLength</span>) {
        <span class="hljs-keyword">const</span> currentItemLength = <span class="hljs-built_in">this</span>.items.length;
        <span class="hljs-comment">// 現在要素数より小さな`newLength`が指定された場合、指定した要素数となるように末尾を削除する</span>
        <span class="hljs-keyword">if</span> (newLength &lt; currentItemLength) {
            <span class="hljs-built_in">this</span>._items = <span class="hljs-built_in">this</span>.items.slice(<span class="hljs-number">0</span>, newLength);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newLength &gt; currentItemLength) {
            <span class="hljs-comment">// 現在要素数より大きな`newLength`が指定された場合、指定した要素数となるように末尾に空要素を追加する</span>
            <span class="hljs-built_in">this</span>._items = <span class="hljs-built_in">this</span>.items.concat(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(newLength - currentItemLength));
        }
    }
}

<span class="hljs-keyword">const</span> arrayLike = <span class="hljs-keyword">new</span> ArrayLike([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);
<span class="hljs-comment">// 要素数を減らすとインデックス以降の要素が削除される</span>
arrayLike.length = <span class="hljs-number">2</span>;
<span class="hljs-built_in">console</span>.log(arrayLike.items.join(<span class="hljs-string">&quot;, &quot;</span>)); <span class="hljs-comment">// =&gt; &quot;1, 2&quot;</span>
<span class="hljs-comment">// 要素数を増やすと末尾に空要素が追加される</span>
arrayLike.length = <span class="hljs-number">5</span>;
<span class="hljs-built_in">console</span>.log(arrayLike.items.join(<span class="hljs-string">&quot;, &quot;</span>)); <span class="hljs-comment">// =&gt; &quot;1, 2, , , &quot;</span>
</code></pre>
<p>このようにアクセッサプロパティでは、プロパティのようでありながら実際にアクセスした際には他のプロパティと連動する動作を実現できます。</p>
<h2 id="public-class-fields"><a name="public-class-fields" class="plugin-anchor" href="#public-class-fields"><i class="fa fa-link" aria-hidden="true"></i></a>[ES2022] Publicクラスフィールド </h2>
<p>クラスでは、<code>constructor</code>メソッドの中でクラスの状態であるインスタンスのプロパティの初期化することを紹介しました。
先ほども紹介した<code>Counter</code>クラスでは、<code>constructor</code>メソッドの中で<code>count</code>プロパティの初期値を<code>0</code>として定義しています。</p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">this</span>.count = <span class="hljs-number">0</span>;
    }
    <span class="hljs-function"><span class="hljs-title">increment</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">this</span>.count++;
    }
}
</code></pre>
<p>この<code>Counter</code>では<code>new</code>演算子で何も引数を渡すことなく初期化するため、<code>constructor</code>メソッドには仮引数を定義していません。
このような場合でも、<code>construtor</code>メソッドを書かないとプロパティの初期化ができないためわずらわしいという問題がありました。</p>
<p>ES2022で、クラスのインスタンスが持つプロパティの初期化をわかりやすく宣言的にする構文として、<strong>クラスフィールド</strong>構文が追加されました。</p>
<p>クラスフィールドは、クラスのインスタンスが持つプロパティを定義する次のような構文です。</p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> クラス </span>{
    プロパティ名 = プロパティの初期値;
}
</code></pre>
<p>クラスフィールドを使って先ほどの<code>Counter</code>クラスを書き直してみると次のようになります。
<code>count</code>プロパティをクラスフィールドとして定義して、その初期値は<code>0</code>としています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2022" } --></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>{
    count = <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-title">increment</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">this</span>.count++;
    }
}
<span class="hljs-keyword">const</span> counter = <span class="hljs-keyword">new</span> Counter();
counter.increment();
<span class="hljs-built_in">console</span>.log(counter.count); <span class="hljs-comment">// =&gt; 1</span>
</code></pre>
<p>クラスフィールドで定義するのは、クラスのインスタンスが持つプロパティです。
そのため、<code>constructor</code>メソッドの中で<code>this.count = 0</code>のように定義した場合と結果的にはほとんど同じ意味となります。
クラスフィールドで定義したプロパティは、クラス内から他のプロパティと同じように<code>this.プロパティ名</code>で参照できます。</p>
<p>クラスフィールドは<code>constructor</code>メソッドでの初期化と併用が可能です。
次のコードでは、クラスフィールドと<code>constructor</code>メソッドでそれぞれインスタンスのプロパティを定義しています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2022" } --></p>
<pre><code class="lang-js"><span class="hljs-comment">// 別々のプロパティ名はそれぞれ定義される</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
    publicField = <span class="hljs-number">1</span>;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">arg</span>)</span> {
        <span class="hljs-built_in">this</span>.property = arg;
    }
}
<span class="hljs-keyword">const</span> myClass = <span class="hljs-keyword">new</span> MyClass(<span class="hljs-number">2</span>);
<span class="hljs-built_in">console</span>.log(myClass.publicField); <span class="hljs-comment">// =&gt; 1</span>
<span class="hljs-built_in">console</span>.log(myClass.property); <span class="hljs-comment">// =&gt; 2</span>
</code></pre>
<p>また、クラスフィールドでの初期化処理が行われ、そのあと<code>constructor</code>でのプロパティの定義という処理順となります。
そのため、同じプロパティ名への定義がある場合は、<code>constructor</code>メソッド内での定義でプロパティは上書きされます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2022" } --></p>
<pre><code class="lang-js"><span class="hljs-comment">// 同じプロパティ名の場合は、constructorでの代入が後となる</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OwnClass</span> </span>{
    publicField = <span class="hljs-number">1</span>;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">arg</span>)</span> {
        <span class="hljs-built_in">this</span>.publicField = arg;
    }
}
<span class="hljs-keyword">const</span> ownClass = <span class="hljs-keyword">new</span> OwnClass(<span class="hljs-number">2</span>);
<span class="hljs-built_in">console</span>.log(ownClass.publicField); <span class="hljs-comment">// =&gt; 2</span>
</code></pre>
<p>この<code>publicField</code>プロパティのように、クラスの外からアクセスできるプロパティを定義するクラスフィールドを<strong>Publicクラスフィールド</strong>と呼びます。</p>
<h3 id="declare-class-fields"><a name="declare-class-fields" class="plugin-anchor" href="#declare-class-fields"><i class="fa fa-link" aria-hidden="true"></i></a>クラスフィールドを使ってプロパティの存在を宣言する </h3>
<p>クラスフィールドでは、プロパティの初期値は省略可能となっています。
そのため、次のように初期値を省略したPublicクラスフィールドも定義できます。</p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
    <span class="hljs-comment">// myPropertyはundefinedで初期化される</span>
    myProperty;
}
</code></pre>
<p>このときの<code>myProperty</code>は<code>undefined</code>で初期化されます。
この初期値を省略したクラスフィールドの定義は、クラスのインスタンスが持つプロパティを明示するために利用できます。</p>
<p>次の<code>Loader</code>クラスは、<code>load</code>メソッドを呼び出すまでは、<code>loadedContent</code>プロパティの値は<code>undefined</code>です。
クラスフィールドを使えば、<code>Loader</code>クラスのインスタンスは、<code>loadedContent</code>というプロパティを持っていることを宣言的に表現できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2022" } --></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Loader</span> </span>{
    loadedContent;
    <span class="hljs-function"><span class="hljs-title">load</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">this</span>.loadedContent = <span class="hljs-string">&quot;読み込んだコンテンツ内容&quot;</span>;
    }
}
</code></pre>
<p>JavaScriptでは、オブジェクトのプロパティは初期化時に存在していなくても、後から代入すれば作成できてしまいます。
そのため、次のように<code>Loader</code>クラスを実装しても意味は同じです。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Loader</span> </span>{
    <span class="hljs-function"><span class="hljs-title">load</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">this</span>.loadedContent = <span class="hljs-string">&quot;読み込んだコンテンツ内容&quot;</span>;
    }
}
</code></pre>
<p>しかし、このように実装してしまうと<code>Loader</code>クラスを利用する側は、<code>loadedContent</code>プロパティの存在を<code>load</code>メソッドの中まで読まないとわからないという問題があります。
これに対して、クラスフィールドを使って「<code>Loader</code>クラスは<code>loadedContent</code>というプロパティを持っている」ということを宣言的に表現できます。
宣言的にプロパティを定義することで、エディターでのコード補完が可能になったり、コードを読む人に優しいというメリットがあります。</p>
<h3 id="this-in-class-fields"><a name="this-in-class-fields" class="plugin-anchor" href="#this-in-class-fields"><i class="fa fa-link" aria-hidden="true"></i></a>クラスフィールドでの<code>this</code>はクラスのインスタンスを示す </h3>
<p>クラスフィールドの初期値には任意の式が書け、<code>this</code>も利用できます。
クラスフィールドでの<code>this</code>は、そのクラスのインスタンスを参照します。</p>
<p>次のコードでは、<code>up</code>フィールドの初期値に<code>increment</code>メソッドを指定しています。
JavaScriptでは関数も値として扱えるため、<code>up</code>メソッドを呼び出すと<code>increment</code>メソッドが呼び出されます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2022" } --></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>{
    count = <span class="hljs-number">0</span>;
    <span class="hljs-comment">// upはincrementメソッドを参照している</span>
    up = <span class="hljs-built_in">this</span>.increment;
    <span class="hljs-function"><span class="hljs-title">increment</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">this</span>.count++;
    }
}
<span class="hljs-keyword">const</span> counter = <span class="hljs-keyword">new</span> Counter();
counter.up(); <span class="hljs-comment">// 結果的にはincrementメソッドが呼び出される</span>
<span class="hljs-built_in">console</span>.log(counter.count); <span class="hljs-comment">// =&gt; 1</span>
</code></pre>
<p>クラスフィールドでの<code>this</code>は、Arrow Functionと組み合わせると強力です。</p>
<p>次のコードでは、<code>up</code>メソッドに<code>this.increment</code>メソッドを呼び出す関数をArrow Function定義しています。
Arrow Functionで定義した関数における<code>this</code>は、どのような呼び出し方をしても変化しません（「<a href="../function-this/#arrow-function-callback">Arrow Functionでコールバック関数を扱う</a>」を参照）。
そのため、<code>up</code>メソッドはどのような呼び方をした場合でも<code>this</code>がクラスのインスタンスとなるため、確実に<code>increment</code>メソッドを呼び出せます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2022" } --></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>{
    count = <span class="hljs-number">0</span>;
    <span class="hljs-comment">// クラスフィールドでの`this`はクラスのインスタンスとなる</span>
    <span class="hljs-comment">// upメソッドは、クラスのインスタンスに定義される</span>
    up = <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-built_in">this</span>.increment();
    };
    <span class="hljs-function"><span class="hljs-title">increment</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">this</span>.count++;
    }
}
<span class="hljs-keyword">const</span> counter = <span class="hljs-keyword">new</span> Counter();
<span class="hljs-comment">// Arrow Functionなので、thisはクラスのインスタンスに固定されている</span>
<span class="hljs-keyword">const</span> up = counter.up;
up();
<span class="hljs-built_in">console</span>.log(counter.count); <span class="hljs-comment">// =&gt; 1</span>
<span class="hljs-comment">// 通常のメソッド定義では、`this`が`undefined`となってしまうため例外が発生する</span>
<span class="hljs-keyword">const</span> increment = counter.increment;
increment(); <span class="hljs-comment">// Error: Uncaught TypeError: this is undefined</span>
</code></pre>
<h3 id="difference-between-class-fields-and-instance-property"><a name="difference-between-class-fields-and-instance-property" class="plugin-anchor" href="#difference-between-class-fields-and-instance-property"><i class="fa fa-link" aria-hidden="true"></i></a>[コラム] クラスフィールドとインスタンスのプロパティの違い </h3>
<p>クラスフィールドで定義したプロパティやメソッドは、クラスのインスタンスにプロパティとして定義されます。
そのため、クラスフィールドは、<code>constructor</code>の中で<code>this</code>に対してプロパティを追加するのと意味的にはほぼ同じで、見た目がわかりやすくなった構文と捉えることができます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2022" } --></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleClass</span> </span>{
    fieldMethod = <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;クラスフィールドで定義されたメソッド&quot;</span>);
    };
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">this</span>.propertyMethod = <span class="hljs-function">() =&gt;</span> {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;インスタンスにプロパティとして定義されたメソッド&quot;</span>);
        };
    }
}
</code></pre>
<p>しかし、厳密にはこのふたつのプロパティ定義には異なる点はあります。
次のように、クラスフィールドと<code>constructor</code>の中で<code>this</code>に追加するプロパティ名に対するsetterを定義してみるとこの違いがわかります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2022" } --></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleClass</span> </span>{
    field = <span class="hljs-string">&quot;フィールド&quot;</span>;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">this</span>.property = <span class="hljs-string">&quot;コンストラクタ&quot;</span>;
    }
    <span class="hljs-comment">// クラスフィールド名に対応するsetter</span>
    <span class="hljs-keyword">set</span> <span class="hljs-title">field</span>(<span class="hljs-params">value</span>) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;fieldで定義された値&quot;</span>, value);
    }
    <span class="hljs-comment">// thisのプロパティ名に対応するsetter</span>
    <span class="hljs-keyword">set</span> <span class="hljs-title">property</span>(<span class="hljs-params">value</span>) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;consctrutorで代入された値&quot;</span>, value);
    }
}
<span class="hljs-comment">// set fieldは呼び出されない</span>
<span class="hljs-comment">// 一方で、set propertyは呼び出される</span>
<span class="hljs-keyword">const</span> example = <span class="hljs-keyword">new</span> ExampleClass();
</code></pre>
<p>クラスフィールド名に対するsetterは呼び出されないのに対して、<code>this.property</code>への代入に対するsetterは呼び出されています。
これは、クラスフィールドは<code>=</code>を使った代入で定義されるのではなく、<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank">Object.defineProperty</a>メソッドを使ってプロパティが定義されるという違いがあります。
<code>Object.defineProperty</code>を使ったプロパティの定義では、setterは無視してプロパティが定義されます。
setterは<code>=</code>での代入に反応します。そのため、<code>constructor</code>の中での<code>this.property</code>への代入に対してはsetterが呼び出されます。</p>
<!-- Note: https://tc39.es/ecma262/#sec-createdataproperty PublicはdefinePropertyを使う -->
<p>同じプロパティの定義であっても、プロパティの定義の仕組みが微妙に異なる点から、このような挙動の違いが存在しています。
しかし、この違いを意識するようなコードを書くことは避けたほうが安全です。
実際に見た目からこの違いを意識するのは難しく、それを意識させるようなコードは複雑性が高いためです。</p>
<h2 id="private-class-fields"><a name="private-class-fields" class="plugin-anchor" href="#private-class-fields"><i class="fa fa-link" aria-hidden="true"></i></a>[ES2022] Privateクラスフィールド </h2>
<p>クラスフィールド構文で次のように書くと、定義したプロパティはクラスのインスタンス化した後に外からも参照できます。
そのため、Publicクラスフィールドと呼ばれます。</p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> クラス </span>{
    プロパティ名 = プロパティの初期値;
}
</code></pre>
<p>一方で外からアクセスされたくないインスタンスのプロパティも存在します。
そのようなプライベートなプロパティを定義する構文もES2022で追加されています。</p>
<p>Privateクラスフィールドは、次のように<code>#</code>をフィールド名の前につけたクラスフィールドを定義します。</p>
<pre><code class="lang-js">class クラス {
    // プライベートなプロパティは#をつける
    #フィールド名 = プロパティの初期値;
}
</code></pre>
<!-- Note: Publicはプロパティ名 https://tc39.es/ecma262/#prod-LiteralPropertyName
PrivateはただのIdentifier。実体的にはプロパティじゃないのでフィールド名としている -->
<p>定義したPrivateクラスフィールドは、<code>this.#フィールド名</code>で参照できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2022" } --></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrivateExampleClass</span> </span>{
    #privateField = <span class="hljs-number">42</span>;
    <span class="hljs-function"><span class="hljs-title">dump</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-comment">// Privateクラスフィールドはクラス内からのみ参照できる</span>
        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.#privateField); <span class="hljs-comment">// =&gt; 42</span>
    }
}
<span class="hljs-keyword">const</span> privateExample = <span class="hljs-keyword">new</span> PrivateExampleClass();
privateExample.dump();
</code></pre>
<p>もう少し具体的なPrivateクラスフィールドの使い方を見ていきます。</p>
<p>アクセサプロパティの例でも登場した<code>NumberWrapper</code>をPrivateクラスフィールドを使って書き直してみます。
元々の<code>NumberWrapper</code>クラスでは、<code>_value</code>プロパティに実際の値を読み書きしていました。
この場合、<code>_value</code>プロパティは、外からもアクセスできてしまうため、定義したgetterとsetterが無視できてしまいます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberWrapper</span> </span>{
    <span class="hljs-comment">// Publicクラスフィールドなのでクラスの外からアクセスができる</span>
    _value;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">value</span>)</span> {
        <span class="hljs-built_in">this</span>._value = value;
    }
    <span class="hljs-comment">// `_value`プロパティの値を返すgetter</span>
    <span class="hljs-keyword">get</span> <span class="hljs-title">value</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._value;
    }
    <span class="hljs-comment">// `_value`プロパティに値を代入するsetter</span>
    <span class="hljs-keyword">set</span> <span class="hljs-title">value</span>(<span class="hljs-params">newValue</span>) {
        <span class="hljs-built_in">this</span>._value = newValue;
    }
}
<span class="hljs-keyword">const</span> numberWrapper = <span class="hljs-keyword">new</span> NumberWrapper(<span class="hljs-number">1</span>);
<span class="hljs-comment">// _valueプロパティは外からもアクセスできる</span>
<span class="hljs-built_in">console</span>.log(numberWrapper._value); <span class="hljs-comment">// =&gt; 1</span>
</code></pre>
<p>Privateクラスフィールドでは、外からアクセスされたくないプロパティを<code>#</code>をつけてクラスフィールドとして定義します。
次のコードでは、<code>#value</code>はプライベートプロパティとなっているため、構文エラーが発生し外からアクセスできなくなることが確認できます。
Privateクラスフィールドを使うことで、クラスを利用する際はgetterとsetterを経由しないと<code>#value</code>を参照できなくなりました。</p>
<!-- textlint-disable eslint -->
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest: SyntaxError --></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberWrapper</span> </span>{
    <span class="hljs-comment">// valueはPrivateクラスフィールドとして定義</span>
    #value;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">value</span>)</span> {
        <span class="hljs-built_in">this</span>.#value = value;
    }
    <span class="hljs-comment">// `#value`フィールドの値を返すgetter</span>
    <span class="hljs-keyword">get</span> <span class="hljs-title">value</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.#value;
    }
    <span class="hljs-comment">// `#value`フィールドに値を代入するsetter</span>
    <span class="hljs-keyword">set</span> <span class="hljs-title">value</span>(<span class="hljs-params">newValue</span>) {
        <span class="hljs-built_in">this</span>.#value = newValue;
    }
}

<span class="hljs-keyword">const</span> numberWrapper = <span class="hljs-keyword">new</span> NumberWrapper(<span class="hljs-number">1</span>);
<span class="hljs-comment">// クラスの外からPrivateクラスフィールドには直接はアクセスできない</span>
<span class="hljs-built_in">console</span>.log(numberWrapper.#value); <span class="hljs-comment">// =&gt; SyntaxError: reference to undeclared private field or method #value</span>
</code></pre>
<!-- textlint-enable eslint -->
<p>Privateクラスフィールドを使うことで、クラスの外からアクセスさせたくないプロパティを宣言できます。
これは、実装したクラスの意図しない使われ方を防いだり、クラスの外からプロパティの状態を直接書き換えるといった行為を防げます。</p>
<p>また、Privateクラスフィールドでは、途中から値が入る場合でもフィールドの宣言が必須となっています。
次のコードでは、<code>#loadedContent</code>に実際に値が入るのは<code>load</code>メソッドが呼び出されたときです。
Publicクラスフィールドではフィールドの定義は省略可能でしたが、Privateクラスフィールドでは<code>#loadedContent</code>フィールドの定義が必須となっています。
言い換えると、Privateクラスフィールドでは、クラスを定義した段階でクラスに存在するすべてのPrivateクラスフィールドを明示する必要があります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2022" } --></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrivateLoader</span> </span>{
    <span class="hljs-comment">// 途中で値が入る場合でも最初に`undefined`で初期化されるフィールドの定義が必須</span>
    #loadedContent;
    <span class="hljs-function"><span class="hljs-title">load</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">this</span>.#loadedContent = <span class="hljs-string">&quot;読み込んだコンテンツ内容&quot;</span>;
    }
}
</code></pre>
<h2 id="static-method"><a name="static-method" class="plugin-anchor" href="#static-method"><i class="fa fa-link" aria-hidden="true"></i></a>静的メソッド </h2>
<p>インスタンスメソッドは、クラスをインスタンス化して利用します。
一方、クラスをインスタンス化せずに利用できる静的メソッド（クラスメソッド）もあります。</p>
<p>静的メソッドの定義方法はメソッド名の前に、<code>static</code>をつけるだけです。</p>
<!-- doctest:disable -->
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> クラス </span>{
    <span class="hljs-keyword">static</span> メソッド() {
        <span class="hljs-comment">// 静的メソッドの処理</span>
    }
}
<span class="hljs-comment">// 静的メソッドの呼び出し</span>
クラス.メソッド();
</code></pre>
<p>次のコードでは、配列をラップする<code>ArrayWrapper</code>というクラスを定義しています。
<code>ArrayWrapper</code>はコンストラクタの引数として配列を受け取って初期化しています。
このクラスに配列ではなく要素そのものを引数に受け取ってインスタンス化できる<code>ArrayWrapper.of</code>という静的メソッドを定義します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayWrapper</span> </span>{
    <span class="hljs-comment">// new演算子で引数が渡されたなかった場合の初期値は空配列</span>
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">array = []</span>)</span> {
        <span class="hljs-built_in">this</span>.array = array;
    }

    <span class="hljs-comment">// rest parametersとして要素を受けつける</span>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">of</span>(<span class="hljs-params">...items</span>)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayWrapper(items);
    }

    <span class="hljs-keyword">get</span> <span class="hljs-title">length</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.array.length;
    }
}

<span class="hljs-comment">// 配列を引数として渡している</span>
<span class="hljs-keyword">const</span> arrayWrapperA = <span class="hljs-keyword">new</span> ArrayWrapper([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);
<span class="hljs-comment">// 要素を引数として渡している</span>
<span class="hljs-keyword">const</span> arrayWrapperB = ArrayWrapper.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
<span class="hljs-built_in">console</span>.log(arrayWrapperA.length); <span class="hljs-comment">// =&gt; 3</span>
<span class="hljs-built_in">console</span>.log(arrayWrapperB.length); <span class="hljs-comment">// =&gt; 3</span>
</code></pre>
<p>クラスの静的メソッドにおける<code>this</code>は、そのクラス自身を参照します。
そのため、先ほどのコードは<code>new ArrayWrapper</code>の代わりに<code>new this</code>と書くこともできます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayWrapper</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">array = []</span>)</span> {
        <span class="hljs-built_in">this</span>.array = array;
    }

    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">of</span>(<span class="hljs-params">...items</span>)</span> {
        <span class="hljs-comment">// `this`は`ArrayWrapper`を参照する</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">this</span>(items);
    }

    <span class="hljs-keyword">get</span> <span class="hljs-title">length</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.array.length;
    }
}

<span class="hljs-keyword">const</span> arrayWrapper = ArrayWrapper.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
<span class="hljs-built_in">console</span>.log(arrayWrapper.length); <span class="hljs-comment">// =&gt; 3</span>
</code></pre>
<p>このように静的メソッドでの<code>this</code>はクラス自身を参照するため、クラスのインスタンスは参照できません。
そのため静的メソッドは、クラスのインスタンスを作成する処理やクラスに関係する処理を書くために利用されます。</p>
<h3 id="static-class-fields"><a name="static-class-fields" class="plugin-anchor" href="#static-class-fields"><i class="fa fa-link" aria-hidden="true"></i></a>[ES2022] 静的クラスフィールド </h3>
<p>ES2022で追加されたクラスフィールドも、インスタンスではなくクラス自体に定義する静的クラスフィールドが利用できます。</p>
<p>静的クラスフィールドはフィールドの前に、<code>static</code>をつけるだけです。
静的クラスフィールドで定義したプロパティは、クラス自体のプロパティとして定義されます。
次のコードでは、Public静的クラスフィールドを使って<code>Colors</code>クラス自体にプロパティを定義しています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2022" } --></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Colors</span> </span>{
    <span class="hljs-keyword">static</span> GREEN = <span class="hljs-string">&quot;緑&quot;</span>;
    <span class="hljs-keyword">static</span> RED = <span class="hljs-string">&quot;赤&quot;</span>;
    <span class="hljs-keyword">static</span> BLUE = <span class="hljs-string">&quot;青&quot;</span>;
}
<span class="hljs-comment">// クラスのプロパティとして参照できる</span>
<span class="hljs-built_in">console</span>.log(Colors.GREEN); <span class="hljs-comment">// =&gt; &quot;緑&quot;</span>
</code></pre>
<p>また、Privateクラスフィールドも静的に利用できます。
Private静的クラスフィールドは、クラス自体にプロパティを定義したいが、そのプロパティを外から参照されたくない場合に利用します。
Private静的クラスフィールドはフィールドの前に、<code>static</code>をつけるだけです。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2022" } --></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
    <span class="hljs-keyword">static</span> #privateClassProp = <span class="hljs-string">&quot;This is private&quot;</span>;
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">outputPrivate</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-comment">// クラス内からはPrivate静的クラスフィールドで定義したプロパティを参照できる</span>
        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.#privateClassProp);
    }
}
MyClass.outputPrivate();
</code></pre>
<!-- Note: static class blocksはユースケースが難しいため省かれている -->
<h2 id="two-instance-method-definition"><a name="two-instance-method-definition" class="plugin-anchor" href="#two-instance-method-definition"><i class="fa fa-link" aria-hidden="true"></i></a>プロトタイプに定義したメソッドとインスタンスに定義したメソッドの違い </h2>
<!-- 目的: プロトタイプの評価が違うことを知る -->
<p>ここまでで、プロトタイプメソッドの定義とクラスフィールドを使ったインスタンスに対するメソッドの定義の2種類を見てきました。
プロトタイプメソッドの定義方法は、メソッドをプロトタイプオブジェクトという特殊なオブジェクトに定義します。
一方で、クラスフィールドで定義したメソッドは、クラスのインスタンスに対してメソッドを定義します。</p>
<p>どちらのメソッド定義方法でも、<code>new</code>演算子でインスタンス化したオブジェクトからメソッドを呼び出すことができる点は同じです。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2022" } --></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleClass</span> </span>{
    <span class="hljs-comment">// クラスフィールドを使い、インスタンスにメソッドを定義</span>
    instanceMethod = <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;インスタンスメソッド&quot;</span>);
    };
    <span class="hljs-comment">// メソッド構文を使い、プロトタイプオブジェクトにメソッドを定義</span>
    <span class="hljs-function"><span class="hljs-title">prototypeMethod</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;プロトタイプメソッド&quot;</span>);
    }
}
<span class="hljs-keyword">const</span> example = <span class="hljs-keyword">new</span> ExampleClass();
<span class="hljs-comment">// どちらのメソッドもインスタンスから呼び出せる</span>
example.instanceMethod();
example.prototypeMethod();
</code></pre>
<p>しかしこの2つのメソッドの定義方法は、メソッドを定義先となるオブジェクトが実際に異なります。</p>
<p>まず、この2種類のメソッドがそれぞれ別の場所へと定義されていることを見ていきます。
次のコードでは、<code>ConflictClass</code>クラスに<code>method</code>という同じ名前のメソッドをプロトタイプメソッドとインスタンスに対してそれぞれ定義しています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConflictClass</span> </span>{
    <span class="hljs-comment">// インスタンスオブジェクトに`method`を定義</span>
    method = <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;インスタンスオブジェクトのメソッド&quot;</span>);
    };

    <span class="hljs-comment">// クラスのプロトタイプメソッドとして`method`を定義</span>
    <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;プロトタイプのメソッド&quot;</span>);
    }
}

<span class="hljs-keyword">const</span> conflict = <span class="hljs-keyword">new</span> ConflictClass();
conflict.method(); <span class="hljs-comment">// どちらの`method`が呼び出される？</span>
</code></pre>
<p>結論から述べると、この場合はインスタンスオブジェクトに定義した<code>method</code>が呼び出されます。
このとき、インスタンスの<code>method</code>プロパティを<code>delete</code>演算子で削除すると、今度はプロトタイプメソッドの<code>method</code>が呼び出されます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConflictClass</span> </span>{
    <span class="hljs-comment">// インスタンスオブジェクトに`method`を定義</span>
    method = <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;インスタンスオブジェクトのメソッド&quot;</span>);
    };

    <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;プロトタイプメソッド&quot;</span>);
    }
}

<span class="hljs-keyword">const</span> conflict = <span class="hljs-keyword">new</span> ConflictClass();
conflict.method(); <span class="hljs-comment">// &quot;インスタンスオブジェクトのメソッド&quot;</span>
<span class="hljs-comment">// インスタンスの`method`プロパティを削除</span>
<span class="hljs-keyword">delete</span> conflict.method;
conflict.method(); <span class="hljs-comment">// &quot;プロトタイプメソッド&quot;</span>
</code></pre>
<p>この実行結果から次のことがわかります。</p>
<ul>
<li>プロトタイプメソッドとインスタンスオブジェクトのメソッドは上書きされずにどちらも定義されている</li>
<li>インスタンスオブジェクトのメソッドがプロトタイプオブジェクトのメソッドよりも優先して呼ばれている</li>
</ul>
<p>どちらも注意深く意識しないと気づきにくいですが、この挙動はJavaScriptの重要な仕組みであるため理解することは重要です。</p>
<p>この挙動は<strong>プロトタイプオブジェクト</strong>と呼ばれる特殊なオブジェクトと<strong>プロトタイプチェーン</strong>と呼ばれる仕組みで成り立っています。
どちらも<strong>プロトタイプ</strong>とついていることからわかるように、2つで1組のような仕組みです。</p>
<p>次のセクションでは、<strong>プロトタイプオブジェクト</strong>と<strong>プロトタイプチェーン</strong>とはどのような仕組みなのかを見ていきます。</p>
<h2 id="prototype"><a name="prototype" class="plugin-anchor" href="#prototype"><i class="fa fa-link" aria-hidden="true"></i></a>プロトタイプオブジェクト </h2>
<p><strong>プロトタイプメソッド</strong>と<strong>インスタンスオブジェクトのメソッド</strong>を同時に定義しても、互いのメソッドは上書きされるわけでありません。
なぜなら、プロトタイプメソッドは<strong>プロトタイプオブジェクト</strong>へ、インスタンスオブジェクトのメソッドは<strong>インスタンスオブジェクト</strong>へそれぞれ定義されるためです。</p>
<p>プロトタイプオブジェクトについては「<a href="../prototype-object/">プロトタイプオブジェクト</a>」の章で簡単に紹介していましたが、改めて解説していきます。</p>
<p><strong>プロトタイプオブジェクト</strong>とは、JavaScriptの関数オブジェクトの<code>prototype</code>プロパティに自動的に作成される特殊なオブジェクトです。
クラスも一種の関数オブジェクトであるため、自動的に<code>prototype</code>プロパティにプロトタイプオブジェクトが作成されています。</p>
<p>次のコードでは、関数やクラス自身の<code>prototype</code>プロパティに、プロトタイプオブジェクトが自動的に作成されていることがわかります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>{
}
<span class="hljs-comment">// `prototype`プロパティにプロトタイプオブジェクトが存在する</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> fn.prototype === <span class="hljs-string">&quot;object&quot;</span>); <span class="hljs-comment">// =&gt; true</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
}
<span class="hljs-comment">// `prototype`プロパティにプロトタイプオブジェクトが存在する</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> MyClass.prototype === <span class="hljs-string">&quot;object&quot;</span>); <span class="hljs-comment">// =&gt; true</span>
</code></pre>
<p><code>class</code>構文のメソッド定義は、このプロトタイプオブジェクトのプロパティとして定義されます。</p>
<p>次のコードでは、クラスのメソッドがプロトタイプオブジェクトに定義されていることを確認できます。
また、クラスには<code>constructor</code>メソッド（コンストラクタ）が必ず定義されます。
この<code>constructor</code>メソッドもプロトタイプオブジェクトに定義されており、この<code>constructor</code>プロパティはクラス自身を参照します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
    <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> {}
}

<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> MyClass.prototype.method === <span class="hljs-string">&quot;function&quot;</span>); <span class="hljs-comment">// =&gt; true</span>
<span class="hljs-comment">// クラスのconstructorはクラス自身を参照する</span>
<span class="hljs-built_in">console</span>.log(MyClass.prototype.constructor === MyClass); <span class="hljs-comment">// =&gt; true</span>
</code></pre>
<p>このように、プロトタイプメソッドはプロトタイプオブジェクトに定義され、インスタンスオブジェクトのメソッドとは異なるオブジェクトに定義されています。そのため、それぞれの方法でメソッドを定義しても、上書きされることはありません。</p>
<h2 id="prototype-chain"><a name="prototype-chain" class="plugin-anchor" href="#prototype-chain"><i class="fa fa-link" aria-hidden="true"></i></a>プロトタイプチェーン </h2>
<p><code>class</code>構文で定義したプロトタイプメソッドはプロトタイプオブジェクトに定義されます。
しかし、インスタンス（オブジェクト）にはメソッドが定義されていないのに、インスタンスからクラスのプロトタイプメソッドを呼び出せます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
    <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;プロトタイプのメソッド&quot;</span>);
    }
}
<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> MyClass();
instance.method(); <span class="hljs-comment">// &quot;プロトタイプのメソッド&quot;</span>
</code></pre>
<p>インスタンスからプロトタイプメソッドを呼び出せるのは<strong>プロトタイプチェーン</strong>と呼ばれる仕組みによるものです。
プロトタイプチェーンは2つの処理から成り立ちます。</p>
<ul>
<li>インスタンス作成時に、インスタンスの<code>[[Prototype]]</code>内部プロパティへプロトタイプオブジェクトの参照を保存する処理</li>
<li>インスタンスからプロパティ（またはメソッド）を参照するときに、<code>[[Prototype]]</code>内部プロパティまで探索する処理</li>
</ul>
<h3 id="write-prototype-chain"><a name="write-prototype-chain" class="plugin-anchor" href="#write-prototype-chain"><i class="fa fa-link" aria-hidden="true"></i></a>インスタンス作成とプロトタイプチェーン </h3>
<p>クラスから<code>new</code>演算子によってインスタンスを作成する際に、インスタンスにはクラスのプロトタイプオブジェクトへの参照が保存されます。
このとき、インスタンスからクラスのプロトタイプオブジェクトへの参照は、インスタンスオブジェクトの<code>[[Prototype]]</code>という内部プロパティに保存されます。</p>
<p><code>[[Prototype]]</code>内部プロパティはECMAScriptの仕様で定められた内部的な表現であるため、通常のプロパティのようにはアクセスできません。
ここでは説明のために、<code>[[プロパティ名]]</code>という書式でECMAScriptの仕様上に存在する内部プロパティを表現しています。</p>
<!-- textlint-disable ja-technical-writing/sentence-length -->
<p><code>[[Prototype]]</code>内部プロパティへプロパティのようにはアクセスできませんが、<code>Object.getPrototypeOf</code>メソッドで<code>[[Prototype]]</code>内部プロパティを参照できます。</p>
<!-- textlint-enable ja-technical-writing/sentence-length -->
<p>次のコードでは、<code>instance</code>オブジェクトの<code>[[Prototype]]</code>内部プロパティを取得しています。
その取得した結果がクラスのプロトタイプオブジェクトを参照していることを確認できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
    <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;プロトタイプのメソッド&quot;</span>);
    }
}
<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> MyClass();
<span class="hljs-comment">// `instance`の`[[Prototype]]`内部プロパティは`MyClass.prototype`と一致する</span>
<span class="hljs-keyword">const</span> MyClassPrototype = <span class="hljs-built_in">Object</span>.getPrototypeOf(instance);
<span class="hljs-built_in">console</span>.log(MyClassPrototype === MyClass.prototype); <span class="hljs-comment">// =&gt; true</span>
</code></pre>
<p>ここで重要なのは、インスタンスはどのクラスから作られたかやそのクラスのプロトタイプオブジェクトを知っているということです。</p>
<h4 id="inner-property"><a name="inner-property" class="plugin-anchor" href="#inner-property"><i class="fa fa-link" aria-hidden="true"></i></a>[Note] <code>[[Prototype]]</code>内部プロパティを読み書きする </h4>
<p><code>Object.getPrototypeOf(オブジェクト)</code>で<code>オブジェクト</code>の<code>[[Prototype]]</code>を読み取ることができます。
一方、<code>Object.setPrototypeOf(オブジェクト, プロトタイプオブジェクト)</code>で<code>オブジェクト</code>の<code>[[Prototype]]</code>に<code>プロトタイプオブジェクト</code>を設定できます。
また、<code>[[Prototype]]</code>内部プロパティを通常のプロパティのように扱える<code>__proto__</code>という特殊なアクセッサプロパティが存在します。</p>
<p>しかし、これらの<code>[[Prototype]]</code>内部プロパティを直接読み書きすることは通常の用途では行いません。
また、既存のビルトインオブジェクトの動作なども変更できるため、不用意に扱うべきではないでしょう。</p>
<h3 id="read-prototype-chain"><a name="read-prototype-chain" class="plugin-anchor" href="#read-prototype-chain"><i class="fa fa-link" aria-hidden="true"></i></a>プロパティの参照とプロトタイプチェーン </h3>
<p>プロトタイプオブジェクトのプロパティがどのようにインスタンスから参照されるかを見ていきます。</p>
<p>オブジェクトのプロパティを参照するときに、オブジェクト自身がプロパティを持っていない場合でも、そこで探索が終わるわけではありません。
オブジェクトの<code>[[Prototype]]</code>内部プロパティ（仕様上の内部的なプロパティ）の参照先であるプロトタイプオブジェクトに対しても探索を続けます。
これは、スコープに指定した識別子の変数がなかった場合に外側のスコープへと探索するスコープチェーンと良く似た仕組みです。</p>
<p>つまり、オブジェクトがプロパティを探索するときは次のような順番で、それぞれのオブジェクトを調べます。
すべてのオブジェクトにおいて見つからなかった場合の結果は<code>undefined</code>を返します。</p>
<ol>
<li><code>instance</code>オブジェクト自身</li>
<li><code>instance</code>オブジェクトの<code>[[Prototype]]</code>の参照先（プロトタイプオブジェクト）</li>
<li>どこにもなかった場合は<code>undefined</code></li>
</ol>
<p>次のコードでは、インスタンスオブジェクト自身は<code>method</code>プロパティを持っていません。
そのため、実際に参照しているのはクラスのプロトタイプオブジェクトの<code>method</code>プロパティです。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
    <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;プロトタイプのメソッド&quot;</span>);
    }
}
<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> MyClass();
<span class="hljs-comment">// インスタンスには`method`プロパティがないため、プロトタイプオブジェクトの`method`が参照される</span>
instance.method(); <span class="hljs-comment">// &quot;プロトタイプのメソッド&quot;</span>
<span class="hljs-comment">// `instance.method`の参照はプロトタイプオブジェクトの`method`と一致する</span>
<span class="hljs-keyword">const</span> Prototype = <span class="hljs-built_in">Object</span>.getPrototypeOf(instance);
<span class="hljs-built_in">console</span>.log(instance.method === Prototype.method); <span class="hljs-comment">// =&gt; true</span>
</code></pre>
<p>このように、インスタンスオブジェクトに<code>method</code>が定義されていなくても、クラスのプロトタイプオブジェクトの<code>method</code>を呼び出すことができます。
このプロパティを参照する際に、オブジェクト自身から<code>[[Prototype]]</code>内部プロパティへと順番に探す仕組みのことを<strong>プロトタイプチェーン</strong>と呼びます。</p>
<p>プロトタイプチェーンの仕組みを疑似的なコードとして表現すると次のような動きをしています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2022" } --></p>
<pre><code class="lang-js"><span class="hljs-comment">// プロトタイプチェーンの動作の疑似的なコード</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
    <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;プロトタイプのメソッド&quot;</span>);
    }
}
<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> MyClass();
<span class="hljs-comment">// `instance.method()`を実行する場合</span>
<span class="hljs-comment">// 次のような呼び出し処理が行われている</span>
<span class="hljs-comment">// インスタンスが`method`プロパティを持っている場合</span>
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.hasOwn(instance, <span class="hljs-string">&quot;method&quot;</span>)) {
    instance.method();
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// インスタンスの`[[Prototype]]`の参照先（`MyClass`のプロトタイプオブジェクト）を取り出す</span>
    <span class="hljs-keyword">const</span> prototypeObject = <span class="hljs-built_in">Object</span>.getPrototypeOf(instance);
    <span class="hljs-comment">// プロトタイプオブジェクトが`method`プロパティを持っている場合</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.hasOwn(prototypeObject, <span class="hljs-string">&quot;method&quot;</span>)) {
        <span class="hljs-comment">// `this`はインスタンス自身を指定して呼び出す</span>
        prototypeObject.method.call(instance);
    }
}
</code></pre>
<p>プロトタイプチェーンの仕組みによって、プロトタイプオブジェクトに定義したプロトタイプメソッドをインスタンスから呼び出せます。</p>
<p>普段は、プロトタイプオブジェクトやプロトタイプチェーンといった仕組みを意識する必要はありません。
<code>class</code>構文はこのようなプロトタイプを意識せずにクラスを利用できるように導入された構文です。
しかし、プロトタイプベースである言語のJavaScriptではクラスをこのようなプロトタイプを使って表現していることは知っておくとよいでしょう。</p>
<!-- Note

インスタンスオブジェクトのメソッドがプロトタイプのメソッドの呼び出しの仕組みについてを見ていきます。

- プロトタイプチェーンという仕組み
- インスタンス化されるときに自動的にインスタンスはプロトタイプオブジェクトを参照する（継承）
- これは`[[Prototype]]`という内部プロパティに保存されますが、`__proto__`というアクセッサプロパティで参照できます
- しかし、`class`構文を利用する場合にはこれを意識して触ることはありません

-->
<h2 id="extends"><a name="extends" class="plugin-anchor" href="#extends"><i class="fa fa-link" aria-hidden="true"></i></a>継承 </h2>
<p><code>extends</code>キーワードを使うことで既存のクラスを継承できます。 継承とは、クラスの<strong>構造</strong>や<strong>機能</strong>を引き継いだ新しいクラスを定義することです。</p>
<h3 id="class-extends"><a name="class-extends" class="plugin-anchor" href="#class-extends"><i class="fa fa-link" aria-hidden="true"></i></a>継承したクラスの定義 </h3>
<p><code>extends</code>キーワードを使って既存のクラスを継承した新しいクラスを定義してみます。
<code>class</code>構文の右辺に<code>extends</code>キーワードで継承元となる<strong>親クラス</strong>（基底クラス）を指定することで、
親クラスを継承した<strong>子クラス</strong>（派生クラス）を定義できます。</p>
<!-- doctest:disable -->
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> 子クラス <span class="hljs-keyword">extends</span> 親クラス </span>{
}
</code></pre>
<p>次のコードでは、<code>Parent</code>クラスを継承した<code>Child</code>クラスを定義しています。
子クラスである<code>Child</code>クラスのインスタンス化は通常のクラスと同じく<code>new</code>演算子を使って行います。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>{
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>{
}
<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> Child();
</code></pre>
<h3 id="class-super"><a name="class-super" class="plugin-anchor" href="#class-super"><i class="fa fa-link" aria-hidden="true"></i></a><code>super</code> </h3>
<p><code>extends</code>を使って定義した子クラスから親クラスを参照するには<code>super</code>というキーワードを利用します。
もっともシンプルな<code>super</code>を使う例としてコンストラクタの処理を見ていきます。</p>
<p><code>class</code>構文でも紹介しましたが、クラスは必ず<code>constructor</code>メソッド（コンストラクタ）を持ちます。 これは、継承した子クラスでも同じです。</p>
<!-- textlint-disable no-js-function-paren -->
<p>次のコードでは、<code>Parent</code>クラスを継承した<code>Child</code>クラスのコンストラクタで、<code>super()</code>を呼び出しています。
<code>super()</code>は子クラスから親クラスの<code>constructor</code>メソッドを呼び出します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// 親クラス</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">...args</span>)</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Parentコンストラクタの処理&quot;</span>, ...args);
    }
}
<span class="hljs-comment">// Parentを継承したChildクラスの定義</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">...args</span>)</span> {
        <span class="hljs-comment">// Parentのコンストラクタ処理を呼び出す</span>
        <span class="hljs-built_in">super</span>(...args);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Childコンストラクタの処理&quot;</span>, ...args);
    }
}
<span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">&quot;引数1&quot;</span>, <span class="hljs-string">&quot;引数2&quot;</span>);
<span class="hljs-comment">// &quot;Parentコンストラクタの処理&quot;, &quot;引数1&quot;, &quot;引数2&quot;</span>
<span class="hljs-comment">// &quot;Childコンストラクタの処理&quot;, &quot;引数1&quot;, &quot;引数2&quot;</span>
</code></pre>
<p><code>class</code>構文でのクラス定義では、<code>constructor</code>メソッド（コンストラクタ）で何も処理しない場合は省略できることを紹介しました。
これは、継承した子クラスでも同じです。</p>
<p>次のコードの<code>Child</code>クラスのコンストラクタでは、何も処理を行っていません。
そのため、<code>Child</code>クラスの<code>constructor</code>メソッドの定義を省略できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>{}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>{}
</code></pre>
<p>このように子クラスで<code>constructor</code>を省略した場合は次のように書いた場合と同じ意味になります。
<code>constructor</code>メソッドの引数をすべて受け取り、そのまま<code>super</code>へ引数の順番を維持して渡します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>{}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">...args</span>)</span> {
        <span class="hljs-built_in">super</span>(...args); <span class="hljs-comment">// 親クラスに引数をそのまま渡す</span>
    }
}
</code></pre>
<h3 id="constructor-order"><a name="constructor-order" class="plugin-anchor" href="#constructor-order"><i class="fa fa-link" aria-hidden="true"></i></a>コンストラクタの処理順は親クラスから子クラスへ </h3>
<p>コンストラクタの処理順は、親クラスから子クラスへと順番が決まっています。</p>
<p><code>class</code>構文では必ず親クラスのコンストラクタ処理（<code>super()</code>の呼び出し）を先に行い、その次に子クラスのコンストラクタ処理を行います。
子クラスのコンストラクタでは、<code>this</code>を触る前に<code>super()</code>で親クラスのコンストラクタ処理を呼び出さないと<code>ReferenceError</code>となるためです。</p>
<p>次のコードでは、<code>Parent</code>と<code>Child</code>でそれぞれインスタンス（<code>this</code>）の<code>name</code>プロパティに値を書き込んでいます。
子クラスでは先に<code>super()</code>を呼び出してからでないと<code>this</code>を参照できません。
そのため、コンストラクタの処理順は<code>Parent</code>から<code>Child</code>という順番に限定されます。</p>
<!-- textlint-enable no-js-function-paren -->
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;Parent&quot;</span>;
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-comment">// 子クラスでは`super()`を`this`に触る前に呼び出さなければならない</span>
        <span class="hljs-built_in">super</span>();
        <span class="hljs-comment">// 子クラスのコンストラクタ処理</span>
        <span class="hljs-comment">// 親クラスで書き込まれた`name`は上書きされる</span>
        <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;Child&quot;</span>;
    }
}
<span class="hljs-keyword">const</span> parent = <span class="hljs-keyword">new</span> Parent();
<span class="hljs-built_in">console</span>.log(parent.name); <span class="hljs-comment">// =&gt; &quot;Parent&quot;</span>
<span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> Child();
<span class="hljs-built_in">console</span>.log(child.name); <span class="hljs-comment">// =&gt; &quot;Child&quot;</span>
</code></pre>
<h3 id="class-fields-inheritance"><a name="class-fields-inheritance" class="plugin-anchor" href="#class-fields-inheritance"><i class="fa fa-link" aria-hidden="true"></i></a>クラスフィールドの継承 </h3>
<p>Publicクラスフィールドもコンストラクタの処理順と同じく親クラスのフィールドが初期化された後に子クラスのフィールドが初期化されます。
Publicクラスフィールドは、インスタンスオブジェクトに対してプロパティを定義する構文でした。
そのため、親クラスで定義されていたフィールドも、実際にインスタンス化したオブジェクトのプロパティとして定義されます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2022" } --></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>{
    parentField = <span class="hljs-string">&quot;親クラスで定義したフィールド&quot;</span>;
}
<span class="hljs-comment">// `Parent`を継承した`Child`を定義</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>{
    childField = <span class="hljs-string">&quot;子クラスで定義したフィールド&quot;</span>;
}
<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> Child();
<span class="hljs-built_in">console</span>.log(instance.parentField); <span class="hljs-comment">// =&gt; &quot;親クラスで定義したフィールド&quot;</span>
<span class="hljs-built_in">console</span>.log(instance.childField); <span class="hljs-comment">// =&gt; &quot;子クラスで定義したフィールド&quot;</span>
</code></pre>
<p>同じ名前のフィールドが定義されている場合は、子クラスのフィールド定義で上書きされます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2022" } --></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>{
    field = <span class="hljs-string">&quot;親クラスで定義したフィールド&quot;</span>;
}
<span class="hljs-comment">// `Parent`を継承した`Child`を定義</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>{
    field = <span class="hljs-string">&quot;子クラスで定義したフィールド&quot;</span>;
}
<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> Child();
<span class="hljs-built_in">console</span>.log(instance.field); <span class="hljs-comment">// =&gt; &quot;子クラスで定義したフィールド&quot;</span>
</code></pre>
<p>Publicクラスフィールドは、このように親クラスで定義したフィールドも子クラスに定義されます。
一方で、Privateクラスフィールドは、このように親クラスで定義したフィールドは子クラスに定義されません。</p>
<p>次のコードでは、親クラスで定義したPrivateクラスフィールドを子クラスから参照してようとしています。
しかし、<code>#parentField</code>は参照できずに構文エラーとなることがわかります。</p>
<!-- textlint-disable eslint -->
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest: SyntaxError --></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>{
    #parentField = <span class="hljs-string">&quot;親クラスで定義したPrivateフィールド&quot;</span>;
}
<span class="hljs-comment">// `Parent`を継承した`Child`を定義</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>{
    <span class="hljs-function"><span class="hljs-title">dump</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.#parentField); <span class="hljs-comment">// =&gt; SyntaxError: reference to undeclared private field or method #parentFeild</span>
    }
}
<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> Child();
instance.dump();
</code></pre>
<!-- textlint-enable eslint -->
<p>これは、PrivateクラスフィールドのPrivateとは各クラスごとのPrivateを守る目的であるためです。
継承したクラスからPrivateクラスフィールドが利用できてしまうと、Privateな情報が子クラスに漏れてしまうためです。
JavaScriptでは、クラスの外に公開したくないが、子クラスからは利用できるようにしたいというような中間の制限を持ったプロパティを定義する構文はありません。</p>
<p>このように子クラスも含むクラスの外からアクセスを厳密に拒否するPrivateをhard privateと呼びます。
JavaScriptでのPrivateクラスフィールドはhard privateとなっています。</p>
<p>一方で、子クラスからのアクセスは許可したり、クラス外からのアクセスが可能となるような特例を持つようなPrivateをsoft privateと呼びます。
JavaScriptでのsoft privateは、WeakMapやWeakSetを使ってユーザー自身で実装する必要があります（「<a href="../map-and-set/">Map/Set</a>」の章を参照）。</p>
<h3 id="prototype-inheritance"><a name="prototype-inheritance" class="plugin-anchor" href="#prototype-inheritance"><i class="fa fa-link" aria-hidden="true"></i></a>プロトタイプ継承 </h3>
<p>次のコードでは<code>extends</code>キーワードを使って<code>Parent</code>クラスを継承した<code>Child</code>クラスを定義しています。
<code>Parent</code>クラスでは<code>method</code>を定義しているため、これを継承している<code>Child</code>クラスのインスタンスからも呼び出せます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>{
    <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Parent.prototype.method&quot;</span>);
    }
}
<span class="hljs-comment">// `Parent`を継承した`Child`を定義</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>{
    <span class="hljs-comment">// methodの定義はない</span>
}
<span class="hljs-comment">// `Child`のインスタンスは`Parent`のプロトタイプメソッドを継承している</span>
<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> Child();
instance.method(); <span class="hljs-comment">// &quot;Parent.prototype.method&quot;</span>
</code></pre>
<p>このように、子クラスのインスタンスから親クラスのプロトタイプメソッドもプロトタイプチェーンの仕組みによって呼び出せます。</p>
<p><code>extends</code>によって継承した場合、子クラスのプロトタイプオブジェクトの<code>[[Prototype]]</code>内部プロパティには親クラスのプロトタイプオブジェクトが設定されます。
このコードでは、<code>Child.prototype</code>オブジェクトの<code>[[Prototype]]</code>内部プロパティには<code>Parent.prototype</code>が設定されます。</p>
<p>これにより、プロパティを参照する場合には次のような順番でオブジェクトを探索しています。</p>
<ol>
<li><code>instance</code>オブジェクト自身</li>
<li><code>Child.prototype</code>（<code>instance</code>オブジェクトの<code>[[Prototype]]</code>の参照先）</li>
<li><code>Parent.prototype</code>（<code>Child.prototype</code>オブジェクトの<code>[[Prototype]]</code>の参照先）</li>
</ol>
<p>このプロトタイプチェーンの仕組みにより、<code>method</code>プロパティは<code>Parent.prototype</code>オブジェクトに定義されたものを参照します。</p>
<p>このようにJavaScriptでは<code>class</code>構文と<code>extends</code>キーワードを使うことでクラスの<strong>機能</strong>を継承できます。
<code>class</code>構文ではプロトタイプオブジェクトを参照する仕組みによって継承が行われています。 そのため、この継承の仕組みを<strong>プロトタイプ継承</strong>と呼びます。</p>
<h3 id="static-inheritance"><a name="static-inheritance" class="plugin-anchor" href="#static-inheritance"><i class="fa fa-link" aria-hidden="true"></i></a>静的メソッドの継承 </h3>
<p>インスタンスとクラスのプロトタイプオブジェクトとの間にはプロトタイプチェーンがあります。
クラス自身（クラスのコンストラクタ）も親クラス自身（親クラスのコンストラクタ）との間にプロトタイプチェーンがあります。</p>
<p>簡単に言えば、静的メソッドも継承されるということです。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span>;
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>{}
<span class="hljs-built_in">console</span>.log(Child.hello()); <span class="hljs-comment">// =&gt; &quot;Hello&quot;</span>
</code></pre>
<p><code>extends</code>によって継承した場合、子クラスのコンストラクタの<code>[[Prototype]]</code>内部プロパティには親クラスのコンストラクタが設定されます。
このコードでは、<code>Child</code>コンストラクタの<code>[[Prototype]]</code>内部プロパティに<code>Parent</code>コンストラクタが設定されます。</p>
<p>つまり、先ほどのコードでは<code>Child.hello</code>プロパティを参照した場合には、次のような順番でオブジェクトを探索しています。</p>
<ol>
<li><code>Child</code>コンストラクタ</li>
<li><code>Parent</code>コンストラクタ（<code>Child</code>コンストラクタの<code>[[Prototype]]</code>の参照先）</li>
</ol>
<p>クラスのコンストラクタ同士にもプロトタイプチェーンの仕組みがあるため、子クラスは親クラスの静的メソッドを呼び出せます。</p>
<h3 id="super-property"><a name="super-property" class="plugin-anchor" href="#super-property"><i class="fa fa-link" aria-hidden="true"></i></a><code>super</code>プロパティ </h3>
<!-- textlint-disable no-js-function-paren -->
<p>子クラスから親クラスのコンストラクタ処理を呼び出すには<code>super()</code>を使います。
同じように、子クラスのプロトタイプメソッドからは、<code>super.プロパティ名</code>で親クラスのプロトタイプメソッドを参照できます。</p>
<p>次のコードでは、<code>Child.prototype.method</code>の中で<code>super.method()</code>と書くことで<code>Parent.prototype.method</code>を呼び出しています。
このように、子クラスから継承元の親クラスのプロトタイプメソッドは<code>super.プロパティ名</code>で参照できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>{
    <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Parent.prototype.method&quot;</span>);
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>{
    <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Child.prototype.method&quot;</span>);
        <span class="hljs-comment">// `this.method()`だと自分(`this`)のmethodを呼び出して無限ループする</span>
        <span class="hljs-comment">// そのため明示的に`super.method()`を呼ぶことで、Parent.prototype.methodを呼び出す</span>
        <span class="hljs-built_in">super</span>.method();
    }
}
<span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> Child();
child.method();
<span class="hljs-comment">// コンソールには次のように出力される</span>
<span class="hljs-comment">// &quot;Child.prototype.method&quot;</span>
<span class="hljs-comment">// &quot;Parent.prototype.method&quot;</span>
</code></pre>
<p>プロトタイプチェーンでは、インスタンスからクラス、さらに親のクラスと継承関係をさかのぼるようにメソッドを探索すると紹介しました。
このコードでは<code>Child.prototype.method</code>が定義されているため、<code>child.method</code>は<code>Child.prototype.method</code>を呼び出します。
そして<code>Child.prototype.method</code>は<code>super.method</code>を呼び出しているため、<code>Parent.prototype.method</code>が呼び出されます。</p>
<p>クラスの静的メソッド同士も同じように<code>super.method()</code>と書くことで呼び出せます。
次のコードでは、<code>Parent</code>を継承した<code>Child</code>から親クラスの静的メソッドを呼び出しています。</p>
<!-- textlint-enable no-js-function-paren -->
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Parent.method&quot;</span>);
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Child.method&quot;</span>);
        <span class="hljs-comment">// `super.method()`で`Parent.method`を呼びだす</span>
        <span class="hljs-built_in">super</span>.method();
    }
}
Child.method();
<span class="hljs-comment">// コンソールには次のように出力される</span>
<span class="hljs-comment">// &quot;Child.method&quot;</span>
<span class="hljs-comment">// &quot;Parent.method&quot;</span>
</code></pre>
<h3 id="instanceof"><a name="instanceof" class="plugin-anchor" href="#instanceof"><i class="fa fa-link" aria-hidden="true"></i></a>継承の判定 </h3>
<p>あるクラスが指定したクラスをプロトタイプ継承しているかは<code>instanceof</code>演算子を使って判定できます。</p>
<p>次のコードでは、<code>Child</code>のインスタンスは<code>Child</code>クラスと<code>Parent</code>クラスを継承したオブジェクトであることを確認しています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>{}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>{}

<span class="hljs-keyword">const</span> parent = <span class="hljs-keyword">new</span> Parent();
<span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> Child();
<span class="hljs-comment">// `Parent`のインスタンスは`Parent`のみを継承したインスタンス</span>
<span class="hljs-built_in">console</span>.log(parent <span class="hljs-keyword">instanceof</span> Parent); <span class="hljs-comment">// =&gt; true</span>
<span class="hljs-built_in">console</span>.log(parent <span class="hljs-keyword">instanceof</span> Child); <span class="hljs-comment">// =&gt; false</span>
<span class="hljs-comment">// `Child`のインスタンスは`Child`と`Parent`を継承したインスタンス</span>
<span class="hljs-built_in">console</span>.log(child <span class="hljs-keyword">instanceof</span> Parent); <span class="hljs-comment">// =&gt; true</span>
<span class="hljs-built_in">console</span>.log(child <span class="hljs-keyword">instanceof</span> Child); <span class="hljs-comment">// =&gt; true</span>
</code></pre>
<!-- Note: instanceof演算子とは`[[Prototype]]`プロパティ

- `instanceof`演算子は`[[Prototype]]`プロパティを見ている
- <https://tc39.es/ecma262/#sec-ordinaryhasinstance>
- `Symbol.hasInstance`によって詳細は変わるため絶対とは言い切れない
- <https://tc39.es/ecma262/#sec-symbol.hasinstance>

-->
<p>より具体的な継承の使い方については「<a href="../../use-case/todoapp/">ユースケース:Todoアプリ</a>」の章で見ていきます。</p>
<h2 id="extends-built-in"><a name="extends-built-in" class="plugin-anchor" href="#extends-built-in"><i class="fa fa-link" aria-hidden="true"></i></a>ビルトインオブジェクトの継承 </h2>
<p>ここまで自身が定義したクラスを継承してきましたが、ビルトインオブジェクトのコンストラクタも継承できます。
ビルトインオブジェクトには<code>Array</code>、<code>String</code>、<code>Object</code>、<code>Number</code>、<code>Error</code>、<code>Date</code>などのコンストラクタがあります。
<code>class</code>構文ではこれらのビルトインオブジェクトを継承できます。</p>
<p>次のコードでは、ビルトインオブジェクトである<code>Array</code>を継承して独自のメソッドを加えた<code>MyArray</code>クラスを定義しています。
継承した<code>MyArray</code>は<code>Array</code>の性質であるメソッドや状態管理についての仕組みを継承しています。
継承した性質に加えて、MyArrayクラスへ<code>first</code>や<code>last</code>といったアクセッサプロパティを追加しています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2022" } --></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Array</span> </span>{
    <span class="hljs-keyword">get</span> <span class="hljs-title">first</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.at(<span class="hljs-number">0</span>);
    }

    <span class="hljs-keyword">get</span> <span class="hljs-title">last</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.at(-<span class="hljs-number">1</span>);
    }
}

<span class="hljs-comment">// Arrayを継承しているのでArray.fromも継承している</span>
<span class="hljs-comment">// Array.fromはIterableなオブジェクトから配列インスタンスを作成する</span>
<span class="hljs-keyword">const</span> array = MyArray.from([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);
<span class="hljs-built_in">console</span>.log(array.length); <span class="hljs-comment">// =&gt; 5</span>
<span class="hljs-built_in">console</span>.log(array.first); <span class="hljs-comment">// =&gt; 1</span>
<span class="hljs-built_in">console</span>.log(array.last); <span class="hljs-comment">// =&gt; 5</span>
</code></pre>
<p><code>Array</code>を継承した<code>MyArray</code>は、<code>Array</code>が元々持つ<code>length</code>プロパティや<code>Array.from</code>メソッドなどを継承しているので利用できます。</p>
<h2 id="conclusion"><a name="conclusion" class="plugin-anchor" href="#conclusion"><i class="fa fa-link" aria-hidden="true"></i></a>まとめ </h2>
<p>この章ではクラスについて学びました。</p>
<ul>
<li>JavaScriptのクラスはプロトタイプベース</li>
<li>クラスは<code>class</code>構文で定義できる</li>
<li>クラスで定義したメソッドはプロトタイプオブジェクトとプロトタイプチェーンの仕組みで呼び出せる</li>
<li>クラスのインスタンスに対するプロパティの定義にはクラスフィールドが利用できる</li>
<li>クラスの外からアクセスさせたくないプロパティの定義にはPrivateクラスフィールドを使う</li>
<li>アクセッサプロパティはgetterとsetterのメソッドを定義することでプロパティのように振る舞う</li>
<li>クラスは<code>extends</code>で継承できる</li>
<li>クラスのプロトタイプメソッドと静的メソッドはどちらも継承される</li>
</ul>
</body></html>
                                
                                </section>
                            
                        </div>
                    </div>
                
<footer class="book_footer">
    <p>Copyright (c) 2016-present <a href="https://github.com/asciidwango/js-primer">jsprimer project</a></p>
</footer>

            </div>

            
                
                <a href="../function-this/" class="navigation navigation-prev " aria-label="Previous page: 関数とthis">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="../error-try-catch/" class="navigation navigation-next " aria-label="Next page: 例外処理">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"author":"azu","description":"JavaScriptにおけるクラスの定義方法や継承方法を紹介します。プロトタイプベースの言語であるJavaScriptがどのように継承などを実現しているのかを紹介します。","title":"クラス","level":"1.3.20","depth":2,"next":{"title":"例外処理","level":"1.3.21","depth":2,"path":"basic/error-try-catch/README.md","ref":"./basic/error-try-catch/README.md","articles":[]},"previous":{"title":"関数とthis","level":"1.3.19","depth":2,"path":"basic/function-this/README.md","ref":"./basic/function-this/README.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-lunr","page-toc-button","include-codeblock","anchors","canonical-link","ga","js-console","github-issue-feedback","sandpack"],"root":"./source/","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"docSearch":{"index":"83I8JIFICQ","apiKey":"9169ce4cd84fcf2376f29d9585c89254"},"github-issue-feedback":{"repo":"asciidwango/js-primer","label":"問題を報告する"},"fontsettings":{"theme":"white","family":"sans","size":2},"js-console":{},"canonical-link":{"baseURL":"https://jsprimer.net"},"highlight":{},"page-toc-button":{"maxTocDepth":2,"minTocSize":2},"ga":{"configuration":"auto","token":"UA-2184335-18"},"include-codeblock":{"check":false,"edit":false,"lang":"","fixlang":false,"template":"./resources/gitbook-plugin-include-codeblock.hbs","theme":"chrome","unindent":false},"sandpack":{},"edit-link":{"base":"https://github.com/asciidwango/js-primer/edit/master/source/","label":"Edit"},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"anchors":{}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"IPAexMincho","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"index.md","glossary":"GLOSSARY.md","summary":"README.md"},"variables":{"esversion":"2022","nodeversion":"18.12.0","npmversion":"8.19.2","triplebackticks":"```","console":"<a class=\"gitbook-plugin-js-console\" aria-hidden=\"true\"></a>"},"title":"JavaScript Primer #jsprimer","gitbook":">=3.0.0","description":"JavaScriptの基本的な書き方からアプリケーションの作成などのユースケースを学ぶための入門書です"},"file":{"path":"basic/class/README.md","mtime":"2023-02-03T12:36:05.215Z","type":"markdown"},"gitbook":{"version":"4.0.4","time":"2023-02-03T12:36:30.367Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-page-toc-button/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-ga/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-js-console/console-ui.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-github-issue-feedback/plugin.js"></script>
        
    
        
        <script src="../../gitbook/honkit-plugin-sandpack/honkit-plugin-sandpack.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

