
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>非同期処理:Promise/Async Function · JavaScript Primer #jsprimer</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="JavaScriptにおける非同期処理についてを紹介します。同期処理と非同期処理の違いやなぜ非同期処理が重要になるかを紹介します。非同期処理を扱うPromise、Async Functionについて紹介します。">
        <meta name="generator" content="HonKit 4.0.4">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-page-toc-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-anchors/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

         
    
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="../map-and-set/" />
    
    
    <link rel="prev" href="../error-try-catch/" />
    

    <link rel="canonical" href="https://jsprimer.net/basic/async/">

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-DWY0DLHWB6"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-DWY0DLHWB6');
</script>
<meta name="google-site-verification" content="bMotEbgYwkzA3k4PkuyK_NUdz0bKh-Phz0oUwNmRSVo" />
<style>
    /*
     * Disable antialias
     */
    * {
        -webkit-font-smoothing: initial !important
    }

    body {
        text-rendering: initial !important;
        font-smoothing: initial !important;
    }

    /* deny access chapter */
    .summary li.chapter>span {
        cursor: not-allowed;
        opacity: .3;
    }

    /* console ui */

    .mirror-console-attach-button-wrapper {
        margin-top: -1.275em;
        margin-bottom: 1.275em
    }

    .mirror-console-wrapper {
        margin-top: 1.275em;
        margin-bottom: 1.275em
    }

    /* file name for codeblock */
    .code-filename {
        background-color: #eee;
        display: inline-block;
        padding: 2px 8px;
        line-height: inherit;
        margin-bottom: 0px !important;
    }

    /* Markdown */
    .markdown-section sup,
    .markdown-section sub {
        font-size: 75%;
    }

    .book_footer {
        text-align: center;
        color: #000000;
        background: #ddd;
        font-size: 16px;
        margin-top: 16px;
        padding: 16px;
    }

    /* github-issue-feedback */
    .gitbook-plugin-github-issue-feedback {
        background-color: #333;
        color: #fff;
        opacity: 0.8;
        padding: 4px;
        margin-right: 24px;
        margin-bottom: 4px;
        border-radius: 6px;
    }

    .gitbook-plugin-github-issue-feedback:hover {
        opacity: 1;
    }

    /* Hide footer on mobile */
    /* Use navigation width */
    @media (max-width: 1240px) {
        .book_footer {
            display: none;
        }
    }

    .navigation {
        min-width: 50px;
    }

    @media (min-width: 1240px) {
        .honkit-plugin-sandpack {
            width: calc(100% + 180px);
            margin: 0 0 1em -90px;
        }
    }

    .honkit-plugin-sandpack, .honkit-plugin-sandpack--buttonContainer {
        margin-bottom: 1em;
    }

</style>
<meta name="theme-color" content="#ffffff">
<link rel="manifest" href="../../manifest.json">
<script>
    if ("serviceWorker" in navigator) {
        const isLocalhost = Boolean(
            // preview
            /netlify.com/.test(window.location.hostname) ||
            // local
            window.location.hostname === "localhost" ||
            // [::1] is the IPv6 localhost address.
            window.location.hostname === "[::1]" ||
            // 127.0.0.1/8 is considered localhost for IPv4.
            window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)
        );
        if (!isLocalhost) {
            window.addEventListener("load", () => {
                navigator.serviceWorker.register("../../sw.js");
            });
        }
    }
</script>

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                    この書籍について
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../../intro/">
            
                <a href="../../intro/">
            
                    
                    はじめに
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../../intro/authors/">
            
                <a href="../../intro/authors/">
            
                    
                    著者紹介
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../../intro/preparation/">
            
                <a href="../../intro/preparation/">
            
                    
                    読み始める前の事前準備
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../../intro/feedback/">
            
                <a href="../../intro/feedback/">
            
                    
                    文章の間違いに気づいたら
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../">
            
                <a href="../">
            
                    
                    第一部: 基本文法
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../introduction/">
            
                <a href="../introduction/">
            
                    
                    JavaScriptとは
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../comments/">
            
                <a href="../comments/">
            
                    
                    コメント
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../variables/">
            
                <a href="../variables/">
            
                    
                    変数と宣言
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../read-eval-print/">
            
                <a href="../read-eval-print/">
            
                    
                    値の評価と表示
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="../data-type/">
            
                <a href="../data-type/">
            
                    
                    データ型とリテラル
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="../operator/">
            
                <a href="../operator/">
            
                    
                    演算子
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="../implicit-coercion/">
            
                <a href="../implicit-coercion/">
            
                    
                    暗黙的な型変換
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="../function-declaration/">
            
                <a href="../function-declaration/">
            
                    
                    関数と宣言
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.9" data-path="../statement-expression/">
            
                <a href="../statement-expression/">
            
                    
                    文と式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.10" data-path="../condition/">
            
                <a href="../condition/">
            
                    
                    条件分岐
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.11" data-path="../loop/">
            
                <a href="../loop/">
            
                    
                    ループと反復処理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.12" data-path="../object/">
            
                <a href="../object/">
            
                    
                    オブジェクト
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.13" data-path="../prototype-object/">
            
                <a href="../prototype-object/">
            
                    
                    プロトタイプオブジェクト
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.14" data-path="../array/">
            
                <a href="../array/">
            
                    
                    配列
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.15" data-path="../string/">
            
                <a href="../string/">
            
                    
                    文字列
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.16" data-path="../string-unicode/">
            
                <a href="../string-unicode/">
            
                    
                    文字列とUnicode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.17" data-path="../wrapper-object/">
            
                <a href="../wrapper-object/">
            
                    
                    ラッパーオブジェクト
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.18" data-path="../function-scope/">
            
                <a href="../function-scope/">
            
                    
                    関数とスコープ
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.19" data-path="../function-this/">
            
                <a href="../function-this/">
            
                    
                    関数とthis
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.20" data-path="../class/">
            
                <a href="../class/">
            
                    
                    クラス
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.21" data-path="../error-try-catch/">
            
                <a href="../error-try-catch/">
            
                    
                    例外処理
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.3.22" data-path="./">
            
                <a href="./">
            
                    
                    非同期処理:Promise/Async Function
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.23" data-path="../map-and-set/">
            
                <a href="../map-and-set/">
            
                    
                    Map/Set
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.24" data-path="../json/">
            
                <a href="../json/">
            
                    
                    JSON
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.25" data-path="../date/">
            
                <a href="../date/">
            
                    
                    Date
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.26" data-path="../math/">
            
                <a href="../math/">
            
                    
                    Math
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.27" data-path="../module/">
            
                <a href="../module/">
            
                    
                    ECMAScriptモジュール
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.28" data-path="../ecmascript/">
            
                <a href="../ecmascript/">
            
                    
                    ECMAScript
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.29" data-path="../other-parts/">
            
                <a href="../other-parts/">
            
                    
                    第一部: おわりに
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../../use-case/">
            
                <a href="../../use-case/">
            
                    
                    第二部: 応用編（ユースケース）
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../../use-case/setup-local-env/">
            
                <a href="../../use-case/setup-local-env/">
            
                    
                    アプリケーション開発の準備
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../../use-case/ajaxapp/">
            
                <a href="../../use-case/ajaxapp/">
            
                    
                    Ajax通信
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.2.1" data-path="../../use-case/ajaxapp/entrypoint/">
            
                <a href="../../use-case/ajaxapp/entrypoint/">
            
                    
                    エントリーポイント
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.2" data-path="../../use-case/ajaxapp/http/">
            
                <a href="../../use-case/ajaxapp/http/">
            
                    
                    HTTP通信
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.3" data-path="../../use-case/ajaxapp/display/">
            
                <a href="../../use-case/ajaxapp/display/">
            
                    
                    データを表示する
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.4" data-path="../../use-case/ajaxapp/promise/">
            
                <a href="../../use-case/ajaxapp/promise/">
            
                    
                    Promiseを活用する
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../../use-case/nodecli/">
            
                <a href="../../use-case/nodecli/">
            
                    
                    Node.jsでCLIアプリ
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.3.1" data-path="../../use-case/nodecli/helloworld/">
            
                <a href="../../use-case/nodecli/helloworld/">
            
                    
                    Node.jsでHello World
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3.2" data-path="../../use-case/nodecli/argument-parse/">
            
                <a href="../../use-case/nodecli/argument-parse/">
            
                    
                    コマンドライン引数を処理する
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3.3" data-path="../../use-case/nodecli/read-file/">
            
                <a href="../../use-case/nodecli/read-file/">
            
                    
                    ファイルを読み込む
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3.4" data-path="../../use-case/nodecli/md-to-html/">
            
                <a href="../../use-case/nodecli/md-to-html/">
            
                    
                    MarkdownをHTMLに変換する
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3.5" data-path="../../use-case/nodecli/refactor-and-unittest/">
            
                <a href="../../use-case/nodecli/refactor-and-unittest/">
            
                    
                    ユニットテストを記述する
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="../../use-case/todoapp/">
            
                <a href="../../use-case/todoapp/">
            
                    
                    Todoアプリ
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.4.1" data-path="../../use-case/todoapp/entrypoint/">
            
                <a href="../../use-case/todoapp/entrypoint/">
            
                    
                    エントリーポイント
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.2" data-path="../../use-case/todoapp/app-structure/">
            
                <a href="../../use-case/todoapp/app-structure/">
            
                    
                    アプリの構成要素
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.3" data-path="../../use-case/todoapp/form-event/">
            
                <a href="../../use-case/todoapp/form-event/">
            
                    
                    Todoアイテムの追加を実装する
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.4" data-path="../../use-case/todoapp/event-model/">
            
                <a href="../../use-case/todoapp/event-model/">
            
                    
                    イベントとモデル
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.5" data-path="../../use-case/todoapp/update-delete/">
            
                <a href="../../use-case/todoapp/update-delete/">
            
                    
                    Todoアイテムの更新と削除を実装する
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.6" data-path="../../use-case/todoapp/final/">
            
                <a href="../../use-case/todoapp/final/">
            
                    
                    Todoアプリのリファクタリング
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../../appendix/links/">
            
                <a href="../../appendix/links/">
            
                    
                    付録: 参考リンク集
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../../cheatsheet/">
            
                <a href="../../cheatsheet/">
            
                    
                    付録: JavaScriptチートシート
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../../outro/">
            
                <a href="../../outro/">
            
                    
                    おわりに
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                 
                    

<!-- Header -->
<meta name="keywords" content="JavaScript,入門,入門書,チュートリアル,書籍,本,無料,Node.js,ブラウザ"/>
<link rel="author" href="https://www.hatena.ne.jp/efcl/"/>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css"/>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<style>
    .book-header {
        display: flex;
        flex-direction: row;
        background-color: #333;
    }

    /* link color */
    .book-header a {
        color: #fff;
    }

    /* hover color */
    .book-header .btn:hover, .book-header .btn:focus, .book-header a:focus, .book-header a:hover {
        color: hsla(0, 0%, 100%, 0.75) !important;
    }

    /* Mobile header fixed */
    @media (max-width: 768px) {
        /* Headerを固定する */
        .book-header {
            position: fixed;
            width: 100%;
        }

        /* Icon only */
        .book-header-title-img {
            margin: auto 18px auto 0 !important;
        }

        .book-header-title-h {
            display: none;
        }

        /* Header分のズレを入れる */
        .page-wrapper {
            padding-top: 60px;
        }

        /* github-issue-feedbackを非表示にする */
        .gitbook-plugin-github-issue-feedback {
            display: none;
        }
    }

    /* Dynamic created by GitBook*/
    .btn.pull-left.js-toolbar-action {
        order: 1;
    }

    .book-header-title {
        order: 2;
        display: inline-flex;
        flex-direction: row;
        color: #fff;
    }

    .book-header-title:hover {
        color: hsla(0, 0%, 100%, 0.75);
    }

    .book-header-title-img {
        width: 32px;
        height: 32px;
        padding: 0;
        margin: auto 10px auto 0;
    }

    .book-header-title-h {
        font-size: 20px;
        margin: auto;
        padding: 0;
    }

    .header-center {
        order: 3;
        display: inline-flex;
        flex-direction: column;
        justify-content: center;
        /* self */
        flex-grow: 1;
        flex-shrink: 0;
        flex-basis: auto;
    }

    .header-right {
        order: 4;
        display: inline-flex;
        flex-direction: row;
        justify-content: center;
        align-items: center;
        /* icon size */
        font-size: 24px;
    }

    .amazon-link, .github-link {
        color: #fff;
        /* Padding and make Vertical */
        display: inline-flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding-left: 4px;
        padding-right: 4px;
    }

    /* Desktop */
    @media (min-width: 768px) {
        .header-center {
            align-items: center;
        }

        .header-right {
            margin-right: 24px;
        }
    }

    /* DocSearch */
    @media (max-width: 768px) {
        .algolia-autocomplete .ds-dropdown-menu {
            max-width: calc(100vw - 32px) !important;
            min-width: calc(100vw - 32px) !important;
            width: calc(100vw - 32px) !important;
            /* negative margin
              This is absolute element
              */
            margin-left: -32px !important;
        }

        .algolia-autocomplete .algolia-docsearch-suggestion--content {
            width: 100% !important;
            padding-left: 0 !important;
        }

        .algolia-autocomplete .algolia-docsearch-suggestion--content:before {
            display: none !important;
        }

        .algolia-autocomplete .algolia-docsearch-suggestion--subcategory-column {
            display: none !important;
        }

        .algolia-autocomplete.algolia-autocomplete-right .ds-dropdown-menu {
            right: inherit !important
        }

        .algolia-autocomplete.algolia-autocomplete-right .ds-dropdown-menu::before {
            right: 50%;
        }

        .sbx-custom {
            width: 92px !important;
            padding: initial !important;
        }

        .amazon-link {
            display: none;
        }
    }

    /* SearchBox */
    .searchbarWrapper {
        height: 50px;
    }


    .sbx-custom {
        display: inline-block;
        position: relative;
        min-width: 150px;
        width: 300px;
        max-width: 300px;
        height: 33px;
        white-space: nowrap;
        box-sizing: border-box;
        font-size: 14px;
    }

    .sbx-custom__wrapper {
        width: 100%;
        height: 100%;
    }

    .sbx-custom__input {
        display: inline-block;
        -webkit-transition: box-shadow .4s ease, background .4s ease;
        transition: box-shadow .4s ease, background .4s ease;
        border: 0;
        border-radius: 5px;
        box-shadow: inset 0 0 0 2px #CCCCCC;
        background: #FFFFFF;
        padding: 0 27px 0 33px;
        width: 100%;
        height: 100%;
        vertical-align: middle;
        white-space: normal;
        font-size: inherit;
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
    }

    .sbx-custom__input::-webkit-search-decoration, .sbx-custom__input::-webkit-search-cancel-button, .sbx-custom__input::-webkit-search-results-button, .sbx-custom__input::-webkit-search-results-decoration {
        display: none;
    }

    .sbx-custom__input:hover {
        box-shadow: inset 0 0 0 2px #b3b3b3;
    }

    .sbx-custom__input:focus, .sbx-custom__input:active {
        outline: 0;
        box-shadow: inset 0 0 0 2px #4B54DE;
        background: #FFFFFF;
    }

    .sbx-custom__input::-webkit-input-placeholder {
        color: #BBBBBB;
    }

    .sbx-custom__input::-moz-placeholder {
        color: #BBBBBB;
    }

    .sbx-custom__input:-ms-input-placeholder {
        color: #BBBBBB;
    }

    .sbx-custom__input::placeholder {
        color: #BBBBBB;
    }

    .sbx-custom__submit {
        position: absolute;
        top: 0;
        right: inherit;
        left: 0;
        margin: 0;
        border: 0;
        border-radius: 4px 0 0 4px;
        background-color: rgba(255, 255, 255, 0);
        padding: 0;
        width: 33px;
        height: 100%;
        vertical-align: middle;
        text-align: center;
        font-size: inherit;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }

    .sbx-custom__submit::before {
        display: inline-block;
        margin-right: -4px;
        height: 100%;
        vertical-align: middle;
        content: '';
    }

    .sbx-custom__submit:hover, .sbx-custom__submit:active {
        cursor: pointer;
    }

    .sbx-custom__submit:focus {
        outline: 0;
    }

    .sbx-custom__submit svg {
        width: 17px;
        height: 17px;
        vertical-align: middle;
        fill: #3A33D1;
    }

    .sbx-custom__reset {
        display: none;
        position: absolute;
        top: 4px;
        right: 4px;
        margin: 0;
        border: 0;
        background: none;
        cursor: pointer;
        padding: 0;
        font-size: inherit;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        fill: rgba(0, 0, 0, 0.5);
    }

    .sbx-custom__reset:focus {
        outline: 0;
    }

    .sbx-custom__reset svg {
        display: block;
        margin: 4px;
        width: 17px;
        height: 17px;
    }

    .sbx-custom__input:valid ~ .sbx-custom__reset {
        display: block;
        -webkit-animation-name: sbx-reset-in;
        animation-name: sbx-reset-in;
        -webkit-animation-duration: .15s;
        animation-duration: .15s;
    }

    @-webkit-keyframes sbx-reset-in {
        0% {
            -webkit-transform: translate3d(-20%, 0, 0);
            transform: translate3d(-20%, 0, 0);
            opacity: 0;
        }
        100% {
            -webkit-transform: none;
            transform: none;
            opacity: 1;
        }
    }

    @keyframes sbx-reset-in {
        0% {
            -webkit-transform: translate3d(-20%, 0, 0);
            transform: translate3d(-20%, 0, 0);
            opacity: 0;
        }
        100% {
            -webkit-transform: none;
            transform: none;
            opacity: 1;
        }
    }
</style>
<div class="book-header" role="navigation">
    
    <a class="book-header-title" href="../..">
        <img class="book-header-title-img" alt="JavaScript Primer"
             src="../../gitbook/icons/icon-128x128.png"/>
        <h2 class="book-header-title-h" title="JavaScript Primer - 迷わないための入門書">JavaScript Primer</h2>
    </a>
    <div class="searchbarWrapper header-center">
        <svg xmlns="http://www.w3.org/2000/svg" style="display:none">
            <symbol xmlns="http://www.w3.org/2000/svg" id="sbx-icon-search-8" viewBox="0 0 40 40">
                <path d="M16 32c8.835 0 16-7.165 16-16 0-8.837-7.165-16-16-16C7.162 0 0 7.163 0 16c0 8.835 7.163 16 16 16zm0-5.76c5.654 0 10.24-4.586 10.24-10.24 0-5.656-4.586-10.24-10.24-10.24-5.656 0-10.24 4.584-10.24 10.24 0 5.654 4.584 10.24 10.24 10.24zM28.156 32.8c-1.282-1.282-1.278-3.363.002-4.643 1.282-1.284 3.365-1.28 4.642-.003l6.238 6.238c1.282 1.282 1.278 3.363-.002 4.643-1.283 1.283-3.366 1.28-4.643.002l-6.238-6.238z"
                      fill-rule="evenodd"></path>
            </symbol>
            <symbol xmlns="http://www.w3.org/2000/svg" id="sbx-icon-clear-5" viewBox="0 0 20 20">
                <path d="M10 20c5.523 0 10-4.477 10-10S15.523 0 10 0 0 4.477 0 10s4.477 10 10 10zm1.35-10.123l3.567 3.568-1.225 1.226-3.57-3.568-3.567 3.57-1.226-1.227 3.568-3.568-3.57-3.57 1.227-1.224 3.568 3.568 3.57-3.567 1.224 1.225-3.568 3.57zM10 18.272c4.568 0 8.272-3.704 8.272-8.272S14.568 1.728 10 1.728 1.728 5.432 1.728 10 5.432 18.272 10 18.272z"
                      fill-rule="evenodd"></path>
            </symbol>
        </svg>

        <form novalidate="novalidate" onsubmit="return false;" class="searchbox sbx-custom">
            <div role="search" class="sbx-custom__wrapper">
                <input name="search" placeholder="Search words" autocomplete="off" required="required"
                       class="sbx-custom__input" type="search">
                <button type="submit" title="Submit your search query." class="sbx-custom__submit">
                    <svg role="img" aria-label="Search">
                        <use xlink:href="#sbx-icon-search-8"></use>
                    </svg>
                </button>
                <button type="reset" title="Clear the search query." class="sbx-custom__reset">
                    <svg role="img" aria-label="Reset">
                        <use xlink:href="#sbx-icon-clear-5"></use>
                    </svg>
                </button>
            </div>
        </form>
    </div>
    <div class="header-right">
        <!-- Icon: https://www.iconfinder.com/iconsets/circle-payment -->
        <a class="amazon-link" title="Amazon: JavaScript Primer 迷わないための入門書"
           href="https://www.amazon.co.jp/dp/4048930737/" target="_blank"><img
                width="22"
                height="22"
                style="margin: 1px;"
                src="../../gitbook/icons/amazon-icon.png" alt=""></a>
        <a class="github-link" title="GitHub: asciidwango/js-primer" href="https://github.com/asciidwango/js-primer"
           target="_blank"><i
                class="fa fa-github fa-fw"></i></a>
    </div>
</div>

<script type="text/javascript">
    document.querySelector(".searchbox [type=\"reset\"]").addEventListener("click", function() {
        this.parentNode.querySelector("input").focus();
    });
</script>
<script defer>
    var search = docsearch({
        apiKey: "fd28ebaba94be0c39fb9fa1b2fed4f23", // use a SEARCH-ONLY api key here
        indexName: "asciidwango",
        inputSelector: ".sbx-custom__input",
        debug: false // set to `true` if you want to inspect the dropdown menu's CSS
    });
</script>
<script>
    window.addEventListener("DOMContentLoaded", function () {
        gitbook.events.on("page.change", function () {
            setTimeout(() => console.clear(), 1000);
        });
    });
</script>
<script type="text/javascript">
    (function(){var t,e,n,r,a;for(t=function(){var t;return t=[],function(){var e,n,r,a;for(n=["init","start","stop","user","track","action","event","goal","chat","buy","page","view","admin","group","alias","ready","link","form","click","submit","cmd","emit","on","send","css","js","style","option","get","set","collection"],e=function(e){return function(){return t.push([e].concat(Array.prototype.slice.call(arguments,0)))}},r=0,a=[];r<n.length;)t[n[r]]=e(n[r]),a.push(r++);return a}(),t.init=function(e,n){var r,a;return t.api_key=e,t.options=n||{},a=document.createElement("script"),a.type="text/javascript",a.async=!0,a.charset="utf-8",a.src=t.options.tracker_url||"https://static.karte.io/libs/tracker.js",r=document.getElementsByTagName("script")[0],r.parentNode.insertBefore(a,r)},t},r=window.karte_tracker_names||["tracker"],e=0,n=r.length;n>e;e++)a=r[e],window[a]||(window[a]=t());tracker.init("a2d22604ec1d1c6d9d53d9d3eb87961d", { spa_mode: { reset_past_actions: true, close_actions: true }})}).call(this);
    window.addEventListener("DOMContentLoaded", function(){
        gitbook.events.on("page.change", function() {
            tracker.view();
        });
    });
</script>





                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <html><head></head><body><h1 id="async-handling"><a name="async-handling" class="plugin-anchor" href="#async-handling"><i class="fa fa-link" aria-hidden="true"></i></a>非同期処理:Promise/Async Function </h1>
<p>この章ではJavaScriptの非同期処理について学んでいきます。
非同期処理はJavaScriptにおけるとても重要な概念です。
また、ブラウザやNode.jsなどのAPIには非同期処理でしか扱えないものもあるため、非同期処理を避けることはできません。
JavaScriptには非同期処理を扱うためのPromiseというビルトインオブジェクト、さらにはAsync Functionと呼ばれる構文的なサポートがあります。</p>
<p>この章では非同期処理とはどのようなものかという話から、非同期処理での例外処理、非同期処理の扱い方を見ていきます。</p>
<h2 id="sync-processing"><a name="sync-processing" class="plugin-anchor" href="#sync-processing"><i class="fa fa-link" aria-hidden="true"></i></a>同期処理 </h2>
<p>多くのプログラミング言語にはコードの評価の仕方として、<strong>同期処理</strong>（sync）と<strong>非同期処理</strong>（async）という大きな分類があります。</p>
<p>今まで書いていたコードは<strong>同期処理</strong>と呼ばれているものです。
同期処理ではコードを順番に処理していき、ひとつの処理が終わるまで次の処理は行いません。
同期処理では実行している処理はひとつだけとなるため、とても直感的な動作となります。</p>
<p>一方、同期的にブロックする処理が行われていた場合には問題があります。
同期処理ではひとつの処理が終わるまで、次の処理へ進むことができないためです。</p>
<p>次のコードの<code>blockTime</code>関数は指定した<code>timeout</code>ミリ秒だけ無限ループを実行し、同期的にブロックする処理です。
<code>timeout</code>ミリ秒経過したかの判定には、無限ループの中でUnix時間（1970年1月1日午前0時0分0秒から経過した時間）のミリ秒を返す<code>Date.now</code>メソッドを利用しています。
この<code>blockTime</code>関数を呼び出すと、指定時間が経過するまで次の処理（タスクB）は呼ばれません。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">taskA</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;タスクAを実行 at &quot;</span> + <span class="hljs-built_in">Date</span>.now());
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">taskB</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;タスクBを実行 at &quot;</span> + <span class="hljs-built_in">Date</span>.now());
}
<span class="hljs-comment">// 指定した`timeout`ミリ秒経過するまで同期的にブロックする関数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">blockTime</span>(<span class="hljs-params">timeout</span>) </span>{
    <span class="hljs-comment">// Date.now()は現在の時間をUnix時間（1970年1月1日午前0時0分0秒から経過した時間）のミリ秒を返す</span>
    <span class="hljs-keyword">const</span> startTime = <span class="hljs-built_in">Date</span>.now();
    <span class="hljs-comment">// `timeout`ミリ秒経過するまで無限ループをする</span>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">const</span> diffTime = <span class="hljs-built_in">Date</span>.now() - startTime;
        <span class="hljs-keyword">if</span> (diffTime &gt;= timeout) {
            <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 指定時間経過したら関数の実行を終了</span>
        }
    }
}
taskA();
blockTime(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 他の処理を1000ミリ秒（1秒間）ブロックする</span>
taskB();
</code></pre>
<p>同期的にブロックする処理があると、ブラウザでは大きな問題となります。
なぜなら、JavaScriptは基本的にブラウザのメインスレッド（UIスレッドとも呼ばれる）で実行されるためです。
メインスレッドは表示の更新といったUIに関する処理も行っています。
そのため、メインスレッドがJavaScriptの処理で専有されると、表示が更新されなくなりフリーズしたようになります。</p>
<p><img src="img/single-thread-tasks.png" alt="single-thread-tasks"></p>
<p>先ほどの例では1秒間も処理をブロックしているため、1秒間スクロールなどの操作が効かないといった悪影響がでます。</p>
<h2 id="async-processing"><a name="async-processing" class="plugin-anchor" href="#async-processing"><i class="fa fa-link" aria-hidden="true"></i></a>非同期処理 </h2>
<p>非同期処理はコードを順番に処理していきますが、ひとつの非同期処理が終わるのを待たずに次の処理を評価します。
つまり、非同期処理では同時に実行している処理が複数あります。</p>
<p>JavaScriptにおいて非同期処理の代表的な関数として<code>setTimeout</code>関数があります。
<code>setTimeout</code>関数は<code>delay</code>ミリ秒後に、<code>コールバック関数</code>を呼び出すようにタイマーへ登録する非同期処理です。</p>
<!-- doctest:disable -->
<pre><code class="lang-js"><span class="hljs-built_in">setTimeout</span>(コールバック関数, delay);
</code></pre>
<p>次のコードでは、見た目上はタスクA → 非同期のタスク → タスクBという流れになっています。
しかし、<code>setTimeout</code>関数を使い、非同期のタスクは1000ミリ秒（1秒）後に実行するようにタイマーへ登録しています。
そのため、実際にはタスクA → タスクB → 非同期のタスクという順番で実行されます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">taskA</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;タスクAを実行 at &quot;</span> + <span class="hljs-built_in">Date</span>.now());
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">taskB</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;タスクBを実行 at &quot;</span> + <span class="hljs-built_in">Date</span>.now());
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">taskAsync</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;非同期のタスクを実行 at &quot;</span> + <span class="hljs-built_in">Date</span>.now());
}

taskA();
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    taskAsync();
}, <span class="hljs-number">1000</span>);
taskB();
</code></pre>
<p>このように、非同期処理（<code>setTimeout</code>のコールバック関数）は、コードの見た目上の並びとは異なる順番で実行されることがわかります。</p>
<p><img src="img/async-single-thread-tasks.png" alt="非同期処理とタイマー"></p>
<h2 id="async-and-main-thread"><a name="async-and-main-thread" class="plugin-anchor" href="#async-and-main-thread"><i class="fa fa-link" aria-hidden="true"></i></a>非同期処理はメインスレッドで実行される </h2>
<p>メインスレッドはUIスレッドとも呼ばれ、重たいJavaScriptの同期処理はメインスレッドで実行する他の処理（画面の更新など）をブロックする問題について紹介しました。
これは非同期処理においても同様の問題があります。なぜならJavaScriptにおける非同期の大部分はメインスレッドで実行されるためです。</p>
<p>非同期処理は名前から考えるとメインスレッド以外で実行されるように見えますが、
基本的には非同期処理も同期処理と同じようにメインスレッドで実行されます。
このセクションでは非同期処理がどのようにメインスレッドで実行されているかを簡潔に見ていきます。</p>
<p>次のコードは、<code>setTimeout</code>関数でタイマーに登録したコールバック関数が呼ばれるまで、実際にどの程度の時間がかかったかを計測しています。
<code>setTimeout</code>関数で10ミリ秒後に非同期のタスクを実行するように登録し、その直後に1秒間を同期的にブロックする処理を呼び出しています。
このコードを実行してみると、同期的にブロックする処理により、非同期のタスクはタイマーに登録した時間（10ミリ秒後）よりも大きく遅れて呼び出されます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">taskA</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;タスクAを実行 at &quot;</span> + <span class="hljs-built_in">Date</span>.now());
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">taskB</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;タスクBを実行 at &quot;</span> + <span class="hljs-built_in">Date</span>.now());
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">taskAsync</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;非同期のタスクを実行 at &quot;</span> + <span class="hljs-built_in">Date</span>.now());
}
<span class="hljs-comment">// 指定した`timeout`ミリ秒経過するまで同期的にブロックする関数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">blockTime</span>(<span class="hljs-params">timeout</span>) </span>{
    <span class="hljs-keyword">const</span> startTime = <span class="hljs-built_in">Date</span>.now();
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">const</span> diffTime = <span class="hljs-built_in">Date</span>.now() - startTime;
        <span class="hljs-keyword">if</span> (diffTime &gt;= timeout) {
            <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 指定時間経過したら関数の実行を終了</span>
        }
    }
}

<span class="hljs-keyword">const</span> startTime = <span class="hljs-built_in">Date</span>.now();
taskA();
<span class="hljs-comment">// 10ミリ秒後にコールバック関数を呼び出すようにタイマーに登録する</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> endTime = <span class="hljs-built_in">Date</span>.now();
    taskAsync();
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`非同期処理のコールバックが呼ばれるまで<span class="hljs-subst">${endTime - startTime}</span>ミリ秒かかりました`</span>);
}, <span class="hljs-number">10</span>);
blockTime(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 1秒間処理をブロックする</span>
taskB();
</code></pre>
<p>非同期処理（<code>setTimeout</code>のコールバック関数）がメインスレッド以外のスレッドで実行されるならば、
この非同期処理はメインスレッドで同期的にブロックする処理の影響を受けないはずです。
しかし、実際にはこの非同期処理もメインスレッドで実行された同期的にブロックする処理の影響を受けます。</p>
<p>多くの環境では、このときの非同期処理のコールバック関数が呼ばれるまでは1秒以上かかります。
これは、10ミリ秒後に非同期のコールバック関数を実行するようにタイマーへ登録自体はできていますが、同期的なブロックする処理によって非同期のタスクの実行も後ろにずれてしまうためです。
このように<strong>非同期処理</strong>も<strong>同期処理</strong>の影響を受けることから、同じメインスレッドで実行されていることがわかります。</p>
<p><img src="img/block--async-single-thread-tasks.png" alt="非同期処理とブロックする同期処理"></p>
<p>JavaScriptでは一部の例外を除き非同期処理が<strong>並行処理（concurrent）</strong>として扱われます。
並行処理とは、処理を一定の単位ごとに分けて処理を切り替えながら実行することです。
そのため非同期処理の実行前にとても重たい処理があると、非同期処理の実行が遅れるという現象を引き起こします。</p>
<p>ただし、非同期処理の中にもメインスレッドとは別のスレッドで実行できるAPIが実行環境によっては存在します。
たとえばブラウザでは<a href="https://developer.mozilla.org/ja/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank">Web Worker</a> APIを使い、メインスレッド以外でJavaScriptを実行できます。
このWeb Workerにおける非同期処理は<strong>並列処理（Parallel）</strong>です。
並列処理とは、排他的に複数の処理を同時に実行することです。</p>
<p>Web Workerではメインスレッドとは異なるWorkerスレッドで実行されるため、Workerスレッド内で同期的にブロックする処理を実行してもメインスレッドは影響を受けにくくなります。
ただし、Web Workerとメインスレッドでのデータのやり取りには<code>postMessage</code>というメソッドを利用する必要があります。
そのため、重たい処理をWorkerに移動できるというメリットはありますが、メインスレッドとWorkerスレッドのデータのやり取りに制限があるというトレードオフの関係になります。</p>
<p>このように、非同期処理のすべてをひとくくりにはできませんが、基本的な非同期処理（タイマーなど）はメインスレッドで実行されているという性質を知ることは大切です。JavaScriptの大部分の<strong>非同期処理</strong>は<strong>非同期的なタイミングで実行される処理</strong>であると理解しておく必要があります。
この書籍で紹介する非同期処理のほとんどは、メインスレッドで処理を切り替えながら実行する<strong>並行処理（concurrent）</strong>となっています。</p>
<h2 id="async-processing-and-error-handling"><a name="async-processing-and-error-handling" class="plugin-anchor" href="#async-processing-and-error-handling"><i class="fa fa-link" aria-hidden="true"></i></a>非同期処理と例外処理 </h2>
<p>非同期処理は処理の流れが同期処理とは異なることについて紹介しました。
これは非同期処理における<strong>例外処理</strong>においても大きな影響を与えます。</p>
<!-- textlint-disable -->
<p>同期処理では、<code>try...catch</code>構文を使うことで同期的に発生した例外がキャッチできます（詳細は「<a href="../error-try-catch/">例外処理</a>」の章を参照）。
<!-- textlint-enable --></p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;同期的なエラー&quot;</span>);
} <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;同期的なエラーをキャッチできる&quot;</span>);
}
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;この行は実行されます&quot;</span>);
</code></pre>
<p>非同期処理では、<code>try...catch</code>構文を使っても非同期的に発生した例外をキャッチできません。
次のコードでは、10ミリ秒後に非同期的なエラーを発生させています。
しかし、<code>try...catch</code>構文では次のような非同期エラーをキャッチできません。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:disable --></p>
<pre><code class="lang-js"><span class="hljs-keyword">try</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;非同期的なエラー&quot;</span>);
    }, <span class="hljs-number">10</span>);
} <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// 非同期エラーはキャッチできないため、この行は実行されません</span>
}
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;この行は実行されます&quot;</span>);
</code></pre>
<p><code>try</code>ブロックはそのブロック内で発生した例外をキャッチする構文です。
しかし、<code>setTimeout</code>関数で登録されたコールバック関数が実際に実行されて例外を投げるのは、すべての同期処理が終わった後となります。
つまり、<code>try</code>ブロックで例外が発生しうるとマークした<strong>範囲外</strong>で例外が発生します。</p>
<p>そのため、<code>setTimeout</code>関数のコールバック関数における例外は、次のようにコールバック関数内で同期的なエラーとしてキャッチする必要があります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:disable --></p>
<pre><code class="lang-js"><span class="hljs-comment">// 非同期処理の外</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 非同期処理の中</span>
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;エラー&quot;</span>);
    } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;エラーをキャッチできる&quot;</span>);
    }
}, <span class="hljs-number">10</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;この行は実行されます&quot;</span>);
</code></pre>
<p>このようにコールバック関数内でエラーをキャッチできますが、<strong>非同期処理の外</strong>からは<strong>非同期処理の中</strong>で例外が発生したかがわかりません。
非同期処理の外から例外が起きたことを知るためには、非同期処理の中で例外が発生したことを非同期処理の外へ伝える方法が必要です。</p>
<p>また、JavaScriptでのHTTPリクエストやファイルの読み書きといった処理も非同期処理のAPIとして提供されています。
これらの非同期処理はネットワークにつながっていない場合やファイルが存在しない場合などには失敗します。
そのため、非同期処理における例外の扱い方（エラーハンドリング）は、極めて重要になります。</p>
<p>非同期処理で発生した例外の扱い方についてはさまざまなパターンがあります。
この章では主要な非同期処理と例外の扱い方として、主にPromise、Async Functionの2つを見ていきます。</p>
<p>Async FunctionはPromiseの上に成り立っている構文です。
そのため、どちらか片方ではなく両方とも理解することが重要です。</p>
<h2 id="promise"><a name="promise" class="plugin-anchor" href="#promise"><i class="fa fa-link" aria-hidden="true"></i></a>[ES2015] Promise </h2>
<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank">Promise</a>はES2015で導入された非同期処理の状態や結果を表現するビルトインオブジェクトです。
非同期処理はPromiseのインスタンスを返し、そのPromiseインスタンスには状態変化をした際に呼び出されるコールバック関数を登録できます。</p>
<p>次のコードは、Promiseを扱う非同期処理を行う例です。
このコードは、大きく分けて2つの部分からなっています。</p>
<ul>
<li>非同期処理をする部分（<code>asyncPromiseTask</code>関数）: Promiseのインスタンスを返す</li>
<li>非同期処理の結果を扱う部分: Promiseのインスタンスを受け取り、成功時の処理と失敗時の処理をコールバック関数で登録する</li>
</ul>
<pre><code class="lang-js"><span class="hljs-comment">// asyncPromiseTask関数は、Promiseインスタンスを返す</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncPromiseTask</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-comment">// さまざまな非同期処理を行う</span>
        <span class="hljs-comment">// 非同期処理に成功した場合は、resolveを呼ぶ</span>
        <span class="hljs-comment">// 非同期処理に失敗した場合は、rejectを呼ぶ</span>
    });
}
<span class="hljs-comment">// asyncPromiseTask関数の非同期処理が成功した時、失敗した時に呼ばれる処理をコールバック関数として登録する</span>
asyncPromiseTask().then(<span class="hljs-function">()=&gt;</span> {
    <span class="hljs-comment">// 非同期処理が成功したときの処理</span>
}).catch(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 非同期処理が失敗したときの処理</span>
});
</code></pre>
<p><code>asyncPromiseTask</code>関数は、<code>Promise</code>というビルトインオブジェクトのインスタンスを返しています。
<code>Promise</code>インスタンスは、<code>asyncPromiseTask</code>関数内で行った非同期処理が成功したか失敗したかの状態を表すオブジェクトです。
 また、この<code>Promise</code>インスタンスに対して、<code>then</code>や<code>catch</code>メソッドで成功時や失敗時に呼び出される処理をコールバック関数として登録することで、非同期処理の結果を扱えます。</p>
<p>Promiseに慣れるまで少しややこしいように見えますが、Promiseは非同期処理の状態や結果をラップしたようなオブジェクトです。
同期的な関数では関数を実行するとすぐ結果がわかりますが、非同期な関数では関数を実行してもすぐには結果がわかりません。
そのため、非同期な関数はPromiseという非同期処理の状態をラップしたオブジェクトを返し、その結果が決まったら登録しておいたコールバック関数へ結果を渡すという仕組みになっています。</p>
<p>実際に<code>Promise</code>の使い方をみていきます。</p>
<h3 id="promise-instance"><a name="promise-instance" class="plugin-anchor" href="#promise-instance"><i class="fa fa-link" aria-hidden="true"></i></a><code>Promise</code>インスタンスの作成 </h3>
<p>Promiseは<code>new</code>演算子で<code>Promise</code>のインスタンスを作成して利用します。
このときのコンストラクタには<code>resolve</code>と<code>reject</code>の2つの引数を取る<code>executor</code>と呼ばれる関数を渡します。
<code>executor</code>関数の中で非同期処理を行い、非同期処理が成功した場合は<code>resolve</code>関数を呼び、失敗した場合は<code>reject</code>関数を呼び出します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> executor = <span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-comment">// 非同期の処理が成功したときはresolveを呼ぶ</span>
    <span class="hljs-comment">// 非同期の処理が失敗したときはrejectを呼ぶ</span>
};
<span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(executor);
</code></pre>
<p>この<code>Promise</code>インスタンスの<code>then</code>メソッドで、Promiseが<code>resolve</code>（成功）、<code>reject</code>（失敗）したときに呼ばれるコールバック関数を登録します。
<code>then</code>メソッドの第一引数には<code>resolve</code>（成功）時に呼ばれるコールバック関数、第二引数には<code>reject</code>（失敗）時に呼ばれるコールバック関数を渡します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// `Promise`インスタンスを作成</span>
<span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-comment">// 非同期の処理が成功したときはresolve()を呼ぶ</span>
    <span class="hljs-comment">// 非同期の処理が失敗したときにはreject()を呼ぶ</span>
});
<span class="hljs-keyword">const</span> onFulfilled = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;resolveされたときに呼ばれる&quot;</span>);
};
<span class="hljs-keyword">const</span> onRejected = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;rejectされたときに呼ばれる&quot;</span>);
};
<span class="hljs-comment">// `then`メソッドで成功時と失敗時に呼ばれるコールバック関数を登録</span>
promise.then(onFulfilled, onRejected);
</code></pre>
<p><code>Promise</code>コンストラクタの<code>resolve</code>と<code>reject</code>、<code>then</code>メソッドの<code>onFulfilled</code>と<code>onRejected</code>は次のような関係となります。</p>
<ul>
<li><code>resolve</code>（成功）したとき<ul>
<li><code>onFulfilled</code>が呼ばれる</li>
</ul>
</li>
<li><code>reject</code>（失敗）したとき<ul>
<li><code>onRejected</code> が呼ばれる</li>
</ul>
</li>
</ul>
<h3 id="promise-then-and-catch"><a name="promise-then-and-catch" class="plugin-anchor" href="#promise-then-and-catch"><i class="fa fa-link" aria-hidden="true"></i></a><code>Promise.prototype.then</code>と<code>Promise.prototype.catch</code> </h3>
<p><code>Promise</code>のようにコンストラクタに関数を渡すパターンは今までなかったので、<code>then</code>メソッドの使い方について具体的な例を紹介します。
また、<code>then</code>メソッドのエイリアスでもある<code>catch</code>メソッドについても見ていきます。</p>
<p>次のコードの<code>dummyFetch</code>関数は<code>Promise</code>のインスタンスを作成して返します。
<code>dummyFetch</code>関数はリソースの取得に成功した場合は<code>resolve</code>関数を呼び、失敗した場合は<code>reject</code>関数を呼びます。</p>
<p><code>resolve</code>に渡した値は、<code>then</code>メソッドの1番目のコールバック関数（<code>onFulfilled</code>）に渡されます。
<code>reject</code>に渡したエラーオブジェクトは、<code>then</code>メソッドの2番目のコールバック関数（<code>onRejected</code>）に渡されます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">/**
 * 1000ミリ秒未満のランダムなタイミングでレスポンスを疑似的にデータ取得する関数
 * 指定した`path`にデータがある場合、成功として**Resolved**状態のPromiseオブジェクトを返す
 * 指定した`path`にデータがない場合、失敗として**Rejected**状態のPromiseオブジェクトを返す
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dummyFetch</span>(<span class="hljs-params">path</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-keyword">if</span> (path.startsWith(<span class="hljs-string">&quot;/success&quot;</span>)) {
                resolve({ <span class="hljs-attr">body</span>: <span class="hljs-string">`Response body of <span class="hljs-subst">${path}</span>`</span> });
            } <span class="hljs-keyword">else</span> {
                reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;NOT FOUND&quot;</span>));
            }
        }, <span class="hljs-number">1000</span> * <span class="hljs-built_in">Math</span>.random());
    });
}
<span class="hljs-comment">// `then`メソッドで成功時と失敗時に呼ばれるコールバック関数を登録</span>
<span class="hljs-comment">// /success/data のリソースは存在するので成功しonFulfilledが呼ばれる</span>
dummyFetch(<span class="hljs-string">&quot;/success/data&quot;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onFulfilled</span>(<span class="hljs-params">response</span>) </span>{
    <span class="hljs-built_in">console</span>.log(response); <span class="hljs-comment">// =&gt; { body: &quot;Response body of /success/data&quot; }</span>
}, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onRejected</span>(<span class="hljs-params">error</span>) </span>{
    <span class="hljs-comment">// この行は実行されません</span>
});
<span class="hljs-comment">// /failure/data のリソースは存在しないのでonRejectedが呼ばれる</span>
dummyFetch(<span class="hljs-string">&quot;/failure/data&quot;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onFulfilled</span>(<span class="hljs-params">response</span>) </span>{
    <span class="hljs-comment">// この行は実行されません</span>
}, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onRejected</span>(<span class="hljs-params">error</span>) </span>{
    <span class="hljs-built_in">console</span>.error(error); <span class="hljs-comment">// Error: &quot;NOT FOUND&quot;</span>
});
</code></pre>
<p>Promiseの<code>then</code>メソッドは成功（<code>onFulfilled</code>）と失敗（<code>onRejected</code>）のコールバック関数の2つを受け取りますが、どちらの引数も省略できます。</p>
<p>次のコードの<code>delay</code>関数は一定時間後に解決（<code>resolve</code>）される<code>Promise</code>インスタンスを返します。
この<code>Promise</code>インスタンスに対して<code>then</code>メソッドで<strong>成功時のコールバック関数だけ</strong>を登録しています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delay</span>(<span class="hljs-params">timeoutMs</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            resolve();
        }, timeoutMs);
    });
}
<span class="hljs-comment">// `then`メソッドで成功時のコールバック関数だけを登録</span>
delay(<span class="hljs-number">10</span>).then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;10ミリ秒後に呼ばれる&quot;</span>);
});
</code></pre>
<p>一方、<code>then</code>メソッドでは失敗時のコールバック関数だけの登録もできます。
このとき<code>then(undefined, onRejected)</code>のように第1引数には<code>undefined</code>を渡す必要があります。
<code>then(undefined, onRejected)</code>と同様のことを行う方法としてPromiseの<code>catch</code>メソッドが用意されています。</p>
<p>次のコードでは<code>then</code>メソッドと<code>catch</code>メソッドで失敗時のエラー処理をしていますが、どちらも同じ意味となります。
<code>then</code>メソッドに<code>undefined</code>を渡すのはわかりにくいため、失敗時の処理だけを登録する場合は<code>catch</code>メソッドの利用を推奨しています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">errorPromise</span>(<span class="hljs-params">message</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(message));
    });
}
<span class="hljs-comment">// 非推奨: `then`メソッドで失敗時のコールバック関数だけを登録</span>
errorPromise(<span class="hljs-string">&quot;thenでエラーハンドリング&quot;</span>).then(<span class="hljs-literal">undefined</span>, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(error.message); <span class="hljs-comment">// =&gt; &quot;thenでエラーハンドリング&quot;</span>
});
<span class="hljs-comment">// 推奨: `catch`メソッドで失敗時のコールバック関数を登録</span>
errorPromise(<span class="hljs-string">&quot;catchでエラーハンドリング&quot;</span>).catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(error.message); <span class="hljs-comment">// =&gt; &quot;catchでエラーハンドリング&quot;</span>
});
</code></pre>
<h3 id="promise-exception"><a name="promise-exception" class="plugin-anchor" href="#promise-exception"><i class="fa fa-link" aria-hidden="true"></i></a>Promiseと例外 </h3>
<p>Promiseではコンストラクタの処理で例外が発生した場合に自動的に例外がキャッチされます。
例外が発生した<code>Promise</code>インスタンスは<code>reject</code>関数を呼び出したのと同じように失敗したものとして扱われます。
そのため、Promise内で例外が発生すると<code>then</code>メソッドの第二引数や<code>catch</code>メソッドで登録したエラー時のコールバック関数が呼び出されます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throwPromise</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-comment">// Promiseコンストラクタの中で例外は自動的にキャッチされrejectを呼ぶ</span>
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;例外が発生&quot;</span>);
        <span class="hljs-comment">// 例外が発生すると、これ以降のコンストラクタの処理は実行されません</span>
    });
}

throwPromise().catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(error.message); <span class="hljs-comment">// =&gt; &quot;例外が発生&quot;</span>
});
</code></pre>
<p>このようにPromiseにおける処理では<code>try...catch</code>構文を使わなくても、自動的に例外がキャッチされます。</p>
<h3 id="promise-status"><a name="promise-status" class="plugin-anchor" href="#promise-status"><i class="fa fa-link" aria-hidden="true"></i></a>Promiseの状態 </h3>
<p>Promiseの<code>then</code>メソッドや<code>catch</code>メソッドによる処理がわかったところで、<code>Promise</code>インスタンスの状態について整理していきます。</p>
<p><code>Promise</code>インスタンスには、内部的に次の3つの状態が存在します。</p>
<ul>
<li><strong>Fulfilled</strong><ul>
<li><code>resolve</code>（成功）したときの状態。このとき<code>onFulfilled</code>が呼ばれる</li>
</ul>
</li>
<li><strong>Rejected</strong><ul>
<li><code>reject</code>（失敗）または例外が発生したときの状態。このとき<code>onRejected</code>が呼ばれる</li>
</ul>
</li>
<li><strong>Pending</strong><ul>
<li>FulfilledまたはRejectedではない状態</li>
<li><code>new Promise</code>でインスタンスを作成したときの初期状態</li>
</ul>
</li>
</ul>
<p>これらの状態はECMAScriptの仕様として決められている内部的な状態です。
しかし、この状態をPromiseのインスタンスから取り出す方法はありません。
そのためAPIとしてこの状態を直接扱うことはできませんが、Promiseについて理解するのに役立ちます。</p>
<!-- textlint-disable preset-ja-technical-writing/no-doubled-conjunction -->
<p><code>Promise</code>インスタンスの状態は作成時に<strong>Pending</strong>となり、一度でも<strong>Fulfilled</strong>または<strong>Rejected</strong>へ変化すると、それ以降状態は変化しなくなります。
そのため、<strong>Fulfilled</strong>または<strong>Rejected</strong>の状態であることを<strong>Settled</strong>（不変）と呼びます。</p>
<!-- textlint-enable preset-ja-technical-writing/no-doubled-conjunction -->
<p>一度でも<strong>Settled</strong>（<strong>Fulfilled</strong>または<strong>Rejected</strong>）となった<code>Promise</code>インスタンスは、それ以降別の状態には変化しません。
そのため、<code>resolve</code>を呼び出した後に<code>reject</code>を呼び出しても、その<code>Promise</code>インスタンスは最初に呼び出した<code>resolve</code>によって<strong>Fulfilled</strong>のままとなります。</p>
<p>次のコードでは、<code>reject</code>を呼び出しても状態が変化しないため、<code>then</code>で登録したonRejectedのコールバック関数は呼び出されません。
<code>then</code>メソッドで登録したコールバック関数は、状態が変化した場合に一度だけ呼び出されます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-comment">// 非同期でresolveする</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        resolve();
        <span class="hljs-comment">// すでにresolveされているため無視される</span>
        reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;エラー&quot;</span>));
    }, <span class="hljs-number">16</span>);
});
promise.then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Fulfilledとなった&quot;</span>);
}, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
    <span class="hljs-comment">// この行は呼び出されない</span>
});
</code></pre>
<p>同じように、<code>Promise</code>コンストラクタ内で<code>resolve</code>を何度呼び出しても、その<code>Promise</code>インスタンスの状態は一度しか変化しません。
そのため、次のように<code>resolve</code>を何度呼び出しても、<code>then</code>で登録したコールバック関数は一度しか呼び出されません。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        resolve();
        resolve(); <span class="hljs-comment">// 二度目以降のresolveやrejectは無視される</span>
    }, <span class="hljs-number">16</span>);
});
promise.then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;最初のresolve時に一度だけ呼ばれる&quot;</span>);
}, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
    <span class="hljs-comment">// この行は呼び出されない</span>
});
</code></pre>
<p>このように<code>Promise</code>インスタンスの状態が変化したときに、一度だけ呼ばれるコールバック関数を登録するのが<code>then</code>や<code>catch</code>メソッドとなります。</p>
<p>また<code>then</code>や<code>catch</code>メソッドはすでにSettledへと状態が変化済みの<code>Promise</code>インスタンスに対してもコールバック関数を後から登録できます。
状態が変化済みの<code>Promise</code>インスタンスに<code>then</code>や<code>catch</code>メソッドで登録したコールバック関数も同じように非同期処理として呼び出されます。</p>
<p>具体的にどうなるかを、状態が変化済みの<code>Promise</code>インスタンスを作成できる<code>Promise.resolve</code>と<code>Promise.reject</code>メソッドと一緒に見ていきます。</p>
<h3 id="promise-resolve"><a name="promise-resolve" class="plugin-anchor" href="#promise-resolve"><i class="fa fa-link" aria-hidden="true"></i></a><code>Promise.resolve</code> </h3>
<p><code>Promise.resolve</code>メソッドは<strong>Fulfilled</strong>の状態となった<code>Promise</code>インスタンスを作成します。</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> fulfilledPromise = <span class="hljs-built_in">Promise</span>.resolve();
</code></pre>
<p><code>Promise.resolve</code>メソッドは<code>new Promise</code>の糖衣構文（シンタックスシュガー）です。
糖衣構文とは、同じ意味の処理を元の構文よりシンプルに書ける別の書き方のことです。
<code>Promise.resolve</code>メソッドは次のコードの糖衣構文です。</p>
<pre><code class="lang-js"><span class="hljs-comment">// const fulfilledPromise = Promise.resolve(); と同じ意味</span>
<span class="hljs-keyword">const</span> fulfilledPromise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
    resolve();
});
</code></pre>
<p><code>Promise.resolve</code>メソッドは引数に<code>resolve</code>される値を渡すこともできます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// `resolve(42)`された`Promise`インスタンスを作成する</span>
<span class="hljs-keyword">const</span> fulfilledPromise = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">42</span>);
fulfilledPromise.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// =&gt; 42</span>
});
</code></pre>
<p><code>Promise.resolve</code>メソッドで作成した<strong>Fulfilled</strong>の状態となった<code>Promise</code>インスタンスに対しても<code>then</code>メソッドでコールバック関数を登録できます。
状態が変化済みの<code>Promise</code>インスタンスに<code>then</code>メソッドで登録したコールバック関数は、常に非同期なタイミングで実行されます。</p>
<p>次のコードを実行すると、すべての同期的な処理が実行された後に、<code>then</code>メソッドのコールバック関数が非同期なタイミングで実行されることがわかります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> promise = <span class="hljs-built_in">Promise</span>.resolve();
promise.then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2. コールバック関数が実行されました&quot;</span>);
});
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1. 同期的な処理が実行されました&quot;</span>);
</code></pre>
<p><code>Promise.resolve</code>メソッドは<code>new Promise</code>の糖衣構文であるため、この実行順序は<code>new Promise</code>を使った場合も同じです。
次のコードは、先ほどの<code>Promise.resolve</code>メソッドを使ったものと同じ動作になります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1. resolveします&quot;</span>);
    resolve();
});
promise.then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;3. コールバック関数が実行されました&quot;</span>);
});
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2. 同期的な処理が実行されました&quot;</span>);
</code></pre>
<p>このコードを実行すると、まず<code>Promise</code>のコンストラクタ関数が実行され、続いて同期的な処理が実行されます。最後に<code>then</code>メソッドで登録していたコールバック関数が非同期的に呼ばれることがわかります。</p>
<h3 id="promise-reject"><a name="promise-reject" class="plugin-anchor" href="#promise-reject"><i class="fa fa-link" aria-hidden="true"></i></a><code>Promise.reject</code> </h3>
<p><code>Promise.reject</code>メソッドは <strong>Rejected</strong>の状態となった<code>Promise</code>インスタンスを作成します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:disable --></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> rejectedPromise = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;エラー&quot;</span>));
</code></pre>
<p><code>Promise.reject</code>メソッドは<code>new Promise</code>の糖衣構文（シンタックスシュガー）です。
そのため、<code>Promise.reject</code>メソッドは次のコードと同じ意味になります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:disable --></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> rejectedPromise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;エラー&quot;</span>));
});
</code></pre>
<p><code>Promise.reject</code>メソッドで作成した<strong>Rejected</strong>状態の<code>Promise</code>インスタンスに対しても<code>then</code>や<code>catch</code>メソッドでコールバック関数を登録できます。
 <strong>Rejected</strong>状態へ変化済みの<code>Promise</code>インスタンスに登録したコールバック関数は、常に非同期なタイミングで実行されます。これは<strong>Fulfilled</strong>の場合と同様です。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;エラー&quot;</span>)).catch(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2. コールバック関数が実行されました&quot;</span>);
});
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1. 同期的な処理が実行されました&quot;</span>);
</code></pre>
<p><code>Promise.resolve</code>や<code>Promise.reject</code>は短く書けるため、テストコードなどで利用されることがあります。
また、<code>Promise.reject</code>は次に解説するPromiseチェーンにおいて、Promiseの状態を操作するのに利用できます。</p>
<h3 id="promise-chain"><a name="promise-chain" class="plugin-anchor" href="#promise-chain"><i class="fa fa-link" aria-hidden="true"></i></a>Promiseチェーン </h3>
<p>Promiseは非同期処理における統一的なインターフェースを提供するビルトインオブジェクトです。
Promiseによる統一的な処理方法は複数の非同期処理を扱う場合に特に効力を発揮します。
これまでは、1つの<code>Promise</code>インスタンスに対して<code>then</code>や<code>catch</code>メソッドで1組のコールバック処理を登録するだけでした。</p>
<p>非同期処理が終わったら次の非同期処理というように、複数の非同期処理を順番に扱いたい場合もあります。
Promiseではこのような複数の非同期処理からなる一連の非同期処理を簡単に書く方法が用意されています。</p>
<p>この仕組みのキーとなるのが<code>then</code>や<code>catch</code>メソッドは常に新しい<code>Promise</code>インスタンスを作成して返すという仕様です。
そのため<code>then</code>メソッドの返り値である<code>Promise</code>インスタンスにさらに<code>then</code>メソッドで処理を登録できます。
これはメソッドチェーンと呼ばれる仕組みですが、この書籍ではPromiseをメソッドチェーンでつなぐことを<strong>Promiseチェーン</strong>と呼びます（メソッドチェーンは「<a href="../array/#method-chain-and-high-order-function">配列</a>」の章を参照）。</p>
<p>次のコードでは、<code>then</code>メソッドでPromiseチェーンをしています。
Promiseチェーンでは、Promiseが失敗（<strong>Rejected</strong>な状態）しない限り、順番に<code>then</code>メソッドで登録した成功時のコールバック関数を呼び出します。
そのため、次のコードでは、<code>1</code>、<code>2</code>と順番にコンソールへログが出力されます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// Promiseインスタンスでメソッドチェーン</span>
<span class="hljs-built_in">Promise</span>.resolve()
    <span class="hljs-comment">// thenメソッドは新しい`Promise`インスタンスを返す</span>
    .then(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);
    })
    .then(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);
    });
</code></pre>
<p>このPromiseチェーンは、次のコードのように毎回新しい変数に入れて処理をつなげるのと結果的には同じ意味となります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// Promiseチェーンを変数に入れた場合</span>
<span class="hljs-keyword">const</span> firstPromise = <span class="hljs-built_in">Promise</span>.resolve();
<span class="hljs-keyword">const</span> secondPromise = firstPromise.then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);
});
<span class="hljs-keyword">const</span> thirdPromise = secondPromise.then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);
});
<span class="hljs-comment">// それぞれ新しいPromiseインスタンスが作成される</span>
<span class="hljs-built_in">console</span>.log(firstPromise === secondPromise); <span class="hljs-comment">// =&gt; false</span>
<span class="hljs-built_in">console</span>.log(secondPromise === thirdPromise); <span class="hljs-comment">// =&gt; false</span>
</code></pre>
<p>もう少し具体的なPromiseチェーンの例を見ていきましょう。</p>
<p>次のコードの<code>asyncTask</code>関数はランダムでFulfilledまたはRejected状態の<code>Promise</code>インスタンスを返します。
この関数が返す<code>Promise</code>インスタンスに対して、<code>then</code>メソッドで成功時の処理を書いています。
<code>then</code>メソッドの返り値は新しい<code>Promise</code>インスタンスであるため、続けて<code>catch</code>メソッドで失敗時の処理を書けます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:options:{ "runMode": "any" } --></p>
<pre><code class="lang-js"><span class="hljs-comment">// ランダムでFulfilledまたはRejectedの`Promise`インスタンスを返す関数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncTask</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span>
        ? <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&quot;成功&quot;</span>)
        : <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;失敗&quot;</span>));
}

<span class="hljs-comment">// asyncTask関数は新しい`Promise`インスタンスを返す</span>
asyncTask()
    <span class="hljs-comment">// thenメソッドは新しい`Promise`インスタンスを返す</span>
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onFulfilled</span>(<span class="hljs-params">value</span>) </span>{　
        <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// =&gt; &quot;成功&quot;</span>
    })
    <span class="hljs-comment">// catchメソッドは新しい`Promise`インスタンスを返す</span>
    .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onRejected</span>(<span class="hljs-params">error</span>) </span>{
        <span class="hljs-built_in">console</span>.log(error.message); <span class="hljs-comment">// =&gt; &quot;失敗&quot;</span>
    });
</code></pre>
<p><code>asyncTask</code>関数が成功（resolve）した場合は<code>then</code>メソッドで登録した成功時の処理だけが呼び出され、<code>catch</code>メソッドで登録した失敗時の処理は呼び出されません。
一方、<code>asyncTask</code>関数が失敗（reject）した場合は<code>then</code>メソッドで登録した成功時の処理は呼び出されずに、<code>catch</code>メソッドで登録した失敗時の処理だけが呼び出されます。</p>
<p>先ほどのコードにおけるPromiseの状態とコールバック関数は次のような処理の流れとなります。</p>
<p><img src="img/promise-chain.png" alt="promise-chain"></p>
<p>Promiseの状態が<strong>Rejected</strong>となった場合は、もっとも近い失敗時の処理（<code>catch</code>または<code>then</code>の第二引数）が呼び出されます。
このとき間にある成功時の処理（<code>then</code>の第一引数）はスキップされます。</p>
<p>次のコードでは、<strong>Rejected</strong>のPromiseに対して<code>then</code> → <code>then</code> → <code>catch</code>とPromiseチェーンで処理を記述しています。
このときもっとも近い失敗時の処理（<code>catch</code>）が呼び出されますが、間にある2つの成功時の処理（<code>then</code>）は実行されません。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// RejectedなPromiseは次の失敗時の処理までスキップする</span>
<span class="hljs-keyword">const</span> rejectedPromise = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;失敗&quot;</span>));
rejectedPromise.then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// このthenのコールバック関数は呼び出されません</span>
}).then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// このthenのコールバック関数は呼び出されません</span>
}).catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(error.message); <span class="hljs-comment">// =&gt; &quot;失敗&quot;</span>
});
</code></pre>
<p>Promiseのコンストラクタの処理の場合と同様に、<code>then</code>や<code>catch</code>のコールバック関数内で発生した例外は自動的にキャッチされます。
例外が発生したとき、<code>then</code>や<code>catch</code>メソッドは<strong>Rejected</strong>な<code>Promise</code>インスタンスを返します。
そのため、例外が発生するともっとも近くの失敗時の処理（<code>catch</code>または<code>then</code>の第二引数）が呼び出されます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 例外が発生すると、thenメソッドはRejectedなPromiseを返す</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;例外&quot;</span>);
}).then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// このthenのコールバック関数は呼び出されません</span>
}).catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(error.message); <span class="hljs-comment">// =&gt; &quot;例外&quot;</span>
});
</code></pre>
<p>また、Promiseチェーンで失敗を<code>catch</code>メソッドなどで一度キャッチすると、次に呼ばれるのは成功時の処理です。
これは、<code>then</code>や<code>catch</code>メソッドは<strong>Fulfilled</strong>状態のPromiseインスタンスを作成して返すためです。
そのため、一度キャッチするとそこからは次の<code>then</code>で登録した処理が呼ばれるPromiseチェーンに戻ります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;エラー&quot;</span>)).catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.error(error); <span class="hljs-comment">// Error: エラー</span>
}).then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;thenのコールバック関数が呼び出される&quot;</span>);
});
</code></pre>
<p>このようにPromiseの<code>then</code>メソッドや<code>catch</code>メソッドをつないで、成功時や失敗時の処理を書いていくことをPromiseチェーンと呼びます。</p>
<h4 id="promise-chain-value"><a name="promise-chain-value" class="plugin-anchor" href="#promise-chain-value"><i class="fa fa-link" aria-hidden="true"></i></a>Promiseチェーンで値を返す </h4>
<p>Promiseチェーンではコールバックで返した値を次のコールバックへ引数として渡せます。</p>
<p><code>then</code>や<code>catch</code>メソッドのコールバック関数は数値、文字列、オブジェクトなどの任意の値を返せます。
このコールバック関数が返した値は、次の<code>then</code>のコールバック関数へ引数として渡されます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>).then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// =&gt; 1</span>
    <span class="hljs-keyword">return</span> value * <span class="hljs-number">2</span>;
}).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// =&gt; 2</span>
    <span class="hljs-keyword">return</span> value * <span class="hljs-number">2</span>;
}).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// =&gt; 4</span>
    <span class="hljs-comment">// 値を返さない場合は undefined を返すのと同じ</span>
}).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// =&gt; undefined</span>
});
</code></pre>
<p>ここでは<code>then</code>メソッドを元に解説しますが、<code>catch</code>メソッドは<code>then</code>メソッドの糖衣構文であるため同じ動作となります。
Promiseチェーンで一度キャッチすると、次に呼ばれるのは成功時の処理となります。
そのため、<code>catch</code>メソッドで返した値は次の<code>then</code>メソッドのコールバック関数に引数として渡されます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;失敗&quot;</span>)).catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-comment">// 一度catchすれば、次に呼ばれるのは成功時のコールバック</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// =&gt; 1</span>
    <span class="hljs-keyword">return</span> value * <span class="hljs-number">2</span>;
}).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// =&gt; 2</span>
});
</code></pre>
<h4 id="promise-then-return-promise"><a name="promise-then-return-promise" class="plugin-anchor" href="#promise-then-return-promise"><i class="fa fa-link" aria-hidden="true"></i></a>コールバック関数で<code>Promise</code>インスタンスを返す </h4>
<p>Promiseチェーンで一度キャッチすると、次に呼ばれるのは成功時の処理（<code>then</code>メソッド）でした。
これは、コールバック関数で任意の値を返すと、その値で<code>resolve</code>された<strong>Fulfilled</strong>状態の<code>Promise</code>インスタンスを作成するためです。
しかし、コールバック関数で<code>Promise</code>インスタンスを返した場合は例外的に異なります。</p>
<p>コールバック関数で<code>Promise</code>インスタンスを返した場合は、同じ状態を持つ<code>Promise</code>インスタンスが<code>then</code>や<code>catch</code>メソッドの返り値となります。
つまり<code>then</code>メソッドで<strong>Rejected</strong>状態の<code>Promise</code>インスタンスを返した場合は、次に呼ばれるのは失敗時の処理です。</p>
<p>次のコードでは、<code>then</code>メソッドのコールバック関数で<code>Promise.reject</code>メソッドを使って<strong>Rejected</strong>な<code>Promise</code>インスタンスを返しています。
<strong>Rejected</strong>な<code>Promise</code>インスタンスは、次の<code>catch</code>メソッドで登録した失敗時の処理を呼び出すまで、<code>then</code>メソッドの成功時の処理をスキップします。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onFulfilledA</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;失敗&quot;</span>));
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onFulfilledB</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// onFulfilledBは呼び出されません</span>
}).catch(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onRejected</span>(<span class="hljs-params">error</span>) </span>{
    <span class="hljs-built_in">console</span>.log(error.message); <span class="hljs-comment">// =&gt; &quot;失敗&quot;</span>
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onFulfilledC</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;onFulfilledCは呼び出されます&quot;</span>);
});
</code></pre>
<p>このコードにおけるPromiseの状態とコールバック関数は次のような処理の流れとなります。</p>
<p><img src="img/then-rejected-promise.png" alt="then-rejected-promise.png"></p>
<p>通常は一度<code>catch</code>すると次に呼び出されるのは成功時の処理でした。
この<code>Promise</code>インスタンスを返す仕組みを使うことで、<code>catch</code>してもそのまま<strong>Rejected</strong>な状態を継続できます。</p>
<p>次のコードでは<code>catch</code>メソッドでログを出力しつつ<code>Promise.reject</code>メソッドを使って<strong>Rejected</strong>な<code>Promise</code>インスタンスを返しています。
これによって、<code>main</code>で発生したエラーのログを取りながら、Promiseチェーンはエラーのまま処理を継続できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;エラー&quot;</span>));
}
<span class="hljs-comment">// mainはRejectedなPromiseを返す</span>
main().catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-comment">// mainで発生したエラーのログを出力する</span>
    <span class="hljs-built_in">console</span>.error(error);
    <span class="hljs-comment">// Promiseチェーンはそのままエラーを継続させる</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);
}).then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 前のcatchでRejectedなPromiseが返されたため、この行は実行されません</span>
}).catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;メインの処理が失敗した&quot;</span>);
});
</code></pre>
<h4 id="promise-finally"><a name="promise-finally" class="plugin-anchor" href="#promise-finally"><i class="fa fa-link" aria-hidden="true"></i></a>[ES2018] Promiseチェーンの最後に処理を書く </h4>
<p>Promiseの<code>finally</code>メソッドは成功時、失敗時どちらの場合でも呼び出されるコールバック関数を登録できます。
<code>try...catch...finally</code>構文の<code>finally</code>節と同様の役割を持つメソッドです。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2018" } --></p>
<pre><code class="lang-js"><span class="hljs-comment">// `promise`にはResolvedまたはRejectedなPromiseインスタンスがランダムで入る</span>
<span class="hljs-keyword">const</span> promise = <span class="hljs-built_in">Math</span>.random() &lt; <span class="hljs-number">0.5</span> ? <span class="hljs-built_in">Promise</span>.resolve() : <span class="hljs-built_in">Promise</span>.reject();
promise.then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Promiseのthenメソッド&quot;</span>);
}).catch(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Promiseのcatchメソッド&quot;</span>);
}).finally(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 成功、失敗どちらの場合でも呼び出される</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Promiseのfinallyメソッド&quot;</span>);
});
</code></pre>
<p>次のコードでは、リソースを取得して<code>then</code>で成功時の処理、<code>catch</code>で失敗時の処理を登録しています。
また、リソースを取得中かどうかを判定するためのフラグを<code>isLoading</code>という変数で管理しています。
成功失敗どちらにもかかわらず、取得が終わったら<code>isLoading</code>は<code>false</code>にします。
<code>then</code>と<code>catch</code>の両方で<code>isLoading</code>へ<code>false</code>を代入できますが、<code>finally</code>メソッドを使うことで代入を一箇所にまとめられます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:meta:{ "ECMAScript": "2018" } --></p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dummyFetch</span>(<span class="hljs-params">path</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-keyword">if</span> (path.startsWith(<span class="hljs-string">&quot;/resource&quot;</span>)) {
                resolve({ <span class="hljs-attr">body</span>: <span class="hljs-string">`Response body of <span class="hljs-subst">${path}</span>`</span> });
            } <span class="hljs-keyword">else</span> {
                reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;NOT FOUND&quot;</span>));
            }
        }, <span class="hljs-number">1000</span> * <span class="hljs-built_in">Math</span>.random());
    });
}
<span class="hljs-comment">// リソースを取得中かどうかのフラグ</span>
<span class="hljs-keyword">let</span> isLoading = <span class="hljs-literal">true</span>;
dummyFetch(<span class="hljs-string">&quot;/resource/A&quot;</span>).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(response);
}).catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.error(error);
}).finally(<span class="hljs-function">() =&gt;</span> {
    isLoading = <span class="hljs-literal">false</span>;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Promiseのfinallyメソッド&quot;</span>);
});
</code></pre>
<h3 id="promise-sequential"><a name="promise-sequential" class="plugin-anchor" href="#promise-sequential"><i class="fa fa-link" aria-hidden="true"></i></a>Promiseチェーンで逐次処理 </h3>
<p>Promiseチェーンで非同期処理の流れを書く大きなメリットは、非同期処理のさまざまなパターンに対応できることです。</p>
<p>ここでは、典型的な例として複数の非同期処理を順番に処理していく逐次処理を考えていきましょう。
Promiseで逐次的な処理といっても難しいことはなく、単純に<code>then</code>で非同期処理をつないでいくだけです。</p>
<p>次のコードでは、Resource AとResource Bを順番に取得しています。
それぞれ取得したリソースを変数<code>results</code>に追加し、すべて取得し終わったらコンソールに出力します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dummyFetch</span>(<span class="hljs-params">path</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-keyword">if</span> (path.startsWith(<span class="hljs-string">&quot;/resource&quot;</span>)) {
                resolve({ <span class="hljs-attr">body</span>: <span class="hljs-string">`Response body of <span class="hljs-subst">${path}</span>`</span> });
            } <span class="hljs-keyword">else</span> {
                reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;NOT FOUND&quot;</span>));
            }
        }, <span class="hljs-number">1000</span> * <span class="hljs-built_in">Math</span>.random());
    });
}

<span class="hljs-keyword">const</span> results = [];
<span class="hljs-comment">// Resource Aを取得する</span>
dummyFetch(<span class="hljs-string">&quot;/resource/A&quot;</span>).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
    results.push(response.body);
    <span class="hljs-comment">// Resource Bを取得する</span>
    <span class="hljs-keyword">return</span> dummyFetch(<span class="hljs-string">&quot;/resource/B&quot;</span>);
}).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
    results.push(response.body);
}).then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(results); <span class="hljs-comment">// =&gt; [&quot;Response body of /resource/A&quot;, &quot;Response body of /resource/B&quot;]</span>
});
</code></pre>
<h3 id="promise-all"><a name="promise-all" class="plugin-anchor" href="#promise-all"><i class="fa fa-link" aria-hidden="true"></i></a><code>Promise.all</code>で複数のPromiseをまとめる </h3>
<p><code>Promise.all</code>を使うことで複数のPromiseを使った非同期処理をひとつのPromiseとして扱えます。</p>
<p><code>Promise.all</code>メソッドは <code>Promise</code>インスタンスの配列を受け取り、新しい<code>Promise</code>インスタンスを返します。
その配列のすべての<code>Promise</code>インスタンスが<strong>Fulfilled</strong>となった場合は、返り値の<code>Promise</code>インスタンスも<strong>Fulfilled</strong>となります。
一方で、ひとつでも<strong>Rejected</strong>となった場合は、返り値の<code>Promise</code>インスタンスも<strong>Rejected</strong>となります。</p>
<p>返り値の<code>Promise</code>インスタンスに<code>then</code>メソッドで登録したコールバック関数には、Promiseの結果をまとめた配列が渡されます。
このときの配列の要素の順番は<code>Promise.all</code>メソッドに渡した配列のPromiseの要素の順番と同じになります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// `timeoutMs`ミリ秒後にresolveする</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delay</span>(<span class="hljs-params">timeoutMs</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            resolve(timeoutMs);
        }, timeoutMs);
    });
}
<span class="hljs-keyword">const</span> promise1 = delay(<span class="hljs-number">1</span>);
<span class="hljs-keyword">const</span> promise2 = delay(<span class="hljs-number">2</span>);
<span class="hljs-keyword">const</span> promise3 = delay(<span class="hljs-number">3</span>);

<span class="hljs-built_in">Promise</span>.all([promise1, promise2, promise3]).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">values</span>) </span>{
    <span class="hljs-built_in">console</span>.log(values); <span class="hljs-comment">// =&gt; [1, 2, 3]</span>
});
</code></pre>
<p>先ほどのPromiseチェーンでリソースを取得する例では、Resource Aを取得し終わってからResource Bを取得というように逐次的でした。
しかし、Resource AとBどちらを先に取得しても問題ない場合は、<code>Promise.all</code>メソッドを使って複数のPromiseを1つのPromiseとしてまとめられます。
また、Resource AとBを同時に取得すればより早い時間で処理が完了します。</p>
<p>次のコードでは、Resource AとBを同時に取得開始しています。
両方のリソースの取得が完了すると、<code>then</code>のコールバック関数にはAとBの結果が配列として渡されます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dummyFetch</span>(<span class="hljs-params">path</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-keyword">if</span> (path.startsWith(<span class="hljs-string">&quot;/resource&quot;</span>)) {
                resolve({ <span class="hljs-attr">body</span>: <span class="hljs-string">`Response body of <span class="hljs-subst">${path}</span>`</span> });
            } <span class="hljs-keyword">else</span> {
                reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;NOT FOUND&quot;</span>));
            }
        }, <span class="hljs-number">1000</span> * <span class="hljs-built_in">Math</span>.random());
    });
}

<span class="hljs-keyword">const</span> fetchedPromise = <span class="hljs-built_in">Promise</span>.all([
    dummyFetch(<span class="hljs-string">&quot;/resource/A&quot;</span>),
    dummyFetch(<span class="hljs-string">&quot;/resource/B&quot;</span>)
]);
<span class="hljs-comment">// fetchedPromiseの結果をDestructuringでresponseA, responseBに代入している</span>
fetchedPromise.then(<span class="hljs-function">(<span class="hljs-params">[responseA, responseB]</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(responseA.body); <span class="hljs-comment">// =&gt; &quot;Response body of /resource/A&quot;</span>
    <span class="hljs-built_in">console</span>.log(responseB.body); <span class="hljs-comment">// =&gt; &quot;Response body of /resource/B&quot;</span>
});
</code></pre>
<p>渡したPromiseがひとつでも<strong>Rejected</strong>となった場合は、失敗時の処理が呼び出されます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dummyFetch</span>(<span class="hljs-params">path</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-keyword">if</span> (path.startsWith(<span class="hljs-string">&quot;/resource&quot;</span>)) {
                resolve({ <span class="hljs-attr">body</span>: <span class="hljs-string">`Response body of <span class="hljs-subst">${path}</span>`</span> });
            } <span class="hljs-keyword">else</span> {
                reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;NOT FOUND&quot;</span>));
            }
        }, <span class="hljs-number">1000</span> * <span class="hljs-built_in">Math</span>.random());
    });
}

<span class="hljs-keyword">const</span> fetchedPromise = <span class="hljs-built_in">Promise</span>.all([
    dummyFetch(<span class="hljs-string">&quot;/resource/A&quot;</span>),
    dummyFetch(<span class="hljs-string">&quot;/not_found/B&quot;</span>) <span class="hljs-comment">// Bは存在しないため失敗する</span>
]);
fetchedPromise.then(<span class="hljs-function">(<span class="hljs-params">[responseA, responseB]</span>) =&gt;</span> {
    <span class="hljs-comment">// この行は実行されません</span>
}).catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.error(error); <span class="hljs-comment">// Error: NOT FOUND</span>
});
</code></pre>
<h3 id="promise-race"><a name="promise-race" class="plugin-anchor" href="#promise-race"><i class="fa fa-link" aria-hidden="true"></i></a><code>Promise.race</code> </h3>
<p><code>Promise.all</code>メソッドは複数のPromiseがすべて完了するまで待つ処理でした。
<code>Promise.race</code>メソッドでは複数のPromiseを受け取りますが、Promiseが1つでも完了した（Settled状態となった）時点で次の処理を実行します。</p>
<p><code>Promise.race</code>メソッドは<code>Promise</code>インスタンスの配列を受け取り、新しい<code>Promise</code>インスタンスを返します。
<!-- textlint-disable -->
この新しい<code>Promise</code>インスタンスは、配列の中で一番最初に<strong>Settled</strong>状態となった<code>Promise</code>インスタンスと同じ状態になります。
<!-- textlint-enable --></p>
<ul>
<li>配列の中で一番最初に<strong>Settled</strong>となったPromiseが<strong>Fulfilled</strong>の場合は、新しい<code>Promise</code>インスタンスも<strong>Fulfilled</strong>になる</li>
<li>配列の中で一番最初に<strong>Settled</strong>となったPromiseが<strong>Rejected</strong>の場合は、新しい<code>Promise</code>インスタンスも <strong>Rejected</strong>になる</li>
</ul>
<p>つまり、複数のPromiseによる非同期処理を同時に実行して競争（race）させて、一番最初に完了した<code>Promise</code>インスタンスに対する次の処理を呼び出します。</p>
<p>次のコードでは、<code>delay</code>関数という<code>timeoutMs</code>ミリ秒後に<strong>Fulfilled</strong>となる<code>Promise</code>インスタンスを返す関数を定義しています。
<code>Promise.race</code>メソッドは1ミリ秒、32ミリ秒、64ミリ秒、128ミリ秒後に完了する<code>Promise</code>インスタンスの配列を受け取っています。
この配列の中で一番最初に完了するのは、1ミリ秒後に<strong>Fulfilled</strong>となる<code>Promise</code>インスタンスです。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// `timeoutMs`ミリ秒後にresolveする</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delay</span>(<span class="hljs-params">timeoutMs</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            resolve(timeoutMs);
        }, timeoutMs);
    });
}
<span class="hljs-comment">// 1つでもresolveまたはrejectした時点で次の処理を呼び出す</span>
<span class="hljs-keyword">const</span> racePromise = <span class="hljs-built_in">Promise</span>.race([
    delay(<span class="hljs-number">1</span>),
    delay(<span class="hljs-number">32</span>),
    delay(<span class="hljs-number">64</span>),
    delay(<span class="hljs-number">128</span>)
]);
racePromise.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-comment">// もっとも早く完了するのは1ミリ秒後</span>
    <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// =&gt; 1</span>
});
</code></pre>
<p>このときに、一番最初に<code>resolve</code>された値で<code>racePromise</code>も<code>resolve</code>されます。
そのため、<code>then</code>メソッドのコールバック関数に<code>1</code>という値が渡されます。</p>
<p>他の<code>delay</code>関数が作成した<code>Promise</code>インスタンスも32ミリ秒、64ミリ秒、128ミリ秒後に<code>resolve</code>されます。
しかし、<code>Promise</code>インスタンスは一度<strong>Settled</strong>（<strong>Fulfilled</strong>または<strong>Rejected</strong>）となると、それ以降は状態も変化せず<code>then</code>のコールバック関数も呼び出しません。
そのため、<code>racePromise</code>は何度も<code>resolve</code>されますが、初回以外は無視されるため<code>then</code>のコールバック関数は一度しか呼び出されません。</p>
<p><code>Promise.race</code>メソッドを使うことでPromiseを使った非同期処理のタイムアウトが実装できます。
ここでのタイムアウトとは、一定時間経過しても処理が終わっていないならエラーとして扱う処理のことです。</p>
<p>次のコードでは<code>timeout</code>関数と<code>dummyFetch</code>関数が返す<code>Promise</code>インスタンスを<code>Promise.race</code>メソッドで競争させています。
<code>dummyFetch</code>関数ではランダムな時間をかけてリソースを取得し<code>resolve</code>する<code>Promise</code>インスタンスを返します。
<code>timeout</code>関数は指定ミリ秒経過すると<code>reject</code>する<code>Promise</code>インスタンスを返します。</p>
<p>この2つの<code>Promise</code>インスタンスを競争させて、<code>dummyFetch</code>が先に完了すれば処理は成功、<code>timeout</code>が先に完了すれば処理は失敗というタイムアウト処理が実現できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest:options:{ "runMode": "any" } --></p>
<pre><code class="lang-js"><span class="hljs-comment">// `timeoutMs`ミリ秒後にrejectする</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timeout</span>(<span class="hljs-params">timeoutMs</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Timeout: <span class="hljs-subst">${timeoutMs}</span>ミリ秒経過`</span>));
        }, timeoutMs);
    });
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dummyFetch</span>(<span class="hljs-params">path</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-keyword">if</span> (path.startsWith(<span class="hljs-string">&quot;/resource&quot;</span>)) {
                resolve({ <span class="hljs-attr">body</span>: <span class="hljs-string">`Response body of <span class="hljs-subst">${path}</span>`</span> });
            } <span class="hljs-keyword">else</span> {
                reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;NOT FOUND&quot;</span>));
            }
        }, <span class="hljs-number">1000</span> * <span class="hljs-built_in">Math</span>.random());
    });
}
<span class="hljs-comment">// 500ミリ秒以内に取得できなければ失敗時の処理が呼ばれる</span>
<span class="hljs-built_in">Promise</span>.race([
    dummyFetch(<span class="hljs-string">&quot;/resource/data&quot;</span>),
    timeout(<span class="hljs-number">500</span>),
]).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(response.body); <span class="hljs-comment">// =&gt; &quot;Response body of /resource/data&quot;</span>
}).catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(error.message); <span class="hljs-comment">// =&gt; &quot;Timeout: 500ミリ秒経過&quot;</span>
});
</code></pre>
<p>このようにPromiseを使うことで非同期処理のさまざまなパターンが形成できます。
より詳しいPromiseの使い方については「<a href="https://azu.github.io/promises-book/" target="_blank">JavaScript Promiseの本</a>」というオンラインで公開されている文書にまとめられています。</p>
<p>一方で、Promiseはただのビルトインオブジェクトであるため、非同期処理間の連携をするにはPromiseチェーンのように少し特殊な書き方や見た目になります。
また、エラーハンドリングについてもPromiseの<code>catch</code>メソッドや<code>finally</code>メソッドなど<code>try...catch</code>構文とよく似た名前を使います。
しかし、Promiseは構文ではなくただのオブジェクトであるため、それらをメソッドチェーンとして実現しないといけないといった制限があります。</p>
<p>ES2017では、このPromiseチェーンの不格好な見た目を解決するためにAsync Functionと呼ばれる構文が導入されました。</p>
<h2 id="async-function"><a name="async-function" class="plugin-anchor" href="#async-function"><i class="fa fa-link" aria-hidden="true"></i></a>[ES2017] Async Function </h2>
<p>ES2017では、Async Functionという非同期処理を行う関数を定義する構文が導入されました。
Async Functionは通常の関数とは異なり、必ず<code>Promise</code>インスタンスを返す関数を定義する構文です。</p>
<p>Async Functionは次のように関数の前に<code>async</code>をつけることで定義できます。
この<code>doAsync</code>関数は常に<code>Promise</code>インスタンスを返します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doAsync</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;値&quot;</span>;
}
<span class="hljs-comment">// doAsync関数はPromiseを返す</span>
doAsync().then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// =&gt; &quot;値&quot;</span>
});
</code></pre>
<p>このAsync Functionは次のように書いた場合と同じ意味になります。
Async Functionでは<code>return</code>した値の代わりに、<code>Promise.resolve(返り値)</code>のように返り値をラップした<code>Promise</code>インスタンスを返します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// 通常の関数でPromiseインスタンスを返している</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doAsync</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&quot;値&quot;</span>);
}
doAsync().then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// =&gt; &quot;値&quot;</span>
});
</code></pre>
<p>重要なこととしてAsync FunctionはPromiseの上に作られた構文です。
そのためAsync Functionを理解するには、Promiseを理解する必要があることに注意してください。</p>
<p>またAsync Function内では<code>await</code>式というPromiseの非同期処理が完了するまで待つ構文が利用できます。
<code>await</code>式を使うことで非同期処理を同期処理のように扱えるため、Promiseチェーンで実現していた処理の流れを読みやすく書けます。</p>
<p>このセクションではAsync Functionと<code>await</code>式について見ていきます。</p>
<h2 id="declare-async-function"><a name="declare-async-function" class="plugin-anchor" href="#declare-async-function"><i class="fa fa-link" aria-hidden="true"></i></a>Async Functionの定義 </h2>
<p>Async Functionは関数の定義に<code>async</code>キーワードをつけることで定義できます。
JavaScriptの関数定義には関数宣言や関数式、Arrow Function、メソッドの短縮記法などがあります。
どの定義方法でも<code>async</code>キーワードを前につけるだけでAsync Functionとして定義できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// 関数宣言のAsync Function版</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>{}
<span class="hljs-comment">// 関数式のAsync Function版</span>
<span class="hljs-keyword">const</span> fn2 = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{};
<span class="hljs-comment">// Arrow FunctionのAsync Function版</span>
<span class="hljs-keyword">const</span> fn3 = <span class="hljs-keyword">async</span>() =&gt; {};
<span class="hljs-comment">// メソッドの短縮記法のAsync Function版</span>
<span class="hljs-keyword">const</span> obj = { <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> {} };
</code></pre>
<p>これらのAsync Functionは、次の点以外は通常の関数と同じ性質を持ちます。</p>
<ul>
<li>Async Functionは必ず<code>Promise</code>インスタンスを返す</li>
<li>Async Function内では<code>await</code>式が利用できる</li>
</ul>
<h2 id="async-function-return-promise"><a name="async-function-return-promise" class="plugin-anchor" href="#async-function-return-promise"><i class="fa fa-link" aria-hidden="true"></i></a>Async FunctionはPromiseを返す </h2>
<p>Async Functionとして定義した関数は必ず<code>Promise</code>インスタンスを返します。
具体的にはAsync Functionが返す値は次の3つのケースが考えられます。</p>
<ol>
<li>Async Functionが値をreturnした場合、その返り値を持つ<strong>Fulfilled</strong>なPromiseを返す</li>
<li>Async FunctionがPromiseをreturnした場合、その返り値のPromiseをそのまま返す</li>
<li>Async Function内で例外が発生した場合は、そのエラーを持つ<strong>Rejected</strong>なPromiseを返す</li>
</ol>
<p>次のコードでは、Async Functionがそれぞれの返り値によってどのような<code>Promise</code>インスタンスを返すかを確認できます。
この1から3の挙動は、Promiseの<code>then</code>メソッドの返り値とそのコールバック関数の関係とほぼ同じです。</p>
<!-- 字の文で書く場合

値を単純に`return`した場合は、その値でresolveされるPromiseが返されていることがわかります。
Promiseを返した場合は、その返したPromiseの状態とAsync Functionの返すPromiseとなります。
最後にAsync Function内で例外が発生した場合は、その場で関数の処理は終了し**Rejected**なPromiseを返します。

-->
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">// 1. resolveFnは値を返している</span>
<span class="hljs-comment">// 何もreturnしていない場合はundefinedを返したのと同じ扱いとなる</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveFn</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;返り値&quot;</span>;
}
resolveFn().then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// =&gt; &quot;返り値&quot;</span>
});

<span class="hljs-comment">// 2. rejectFnはPromiseインスタンスを返している</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rejectFn</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;エラーメッセージ&quot;</span>));
}

<span class="hljs-comment">// rejectFnはRejectedなPromiseを返すのでcatchできる</span>
rejectFn().catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(error.message); <span class="hljs-comment">// =&gt; &quot;エラーメッセージ&quot;</span>
});

<span class="hljs-comment">// 3. exceptionFnは例外を投げている</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exceptionFn</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;例外が発生しました&quot;</span>);
    <span class="hljs-comment">// 例外が発生したため、この行は実行されません</span>
}

<span class="hljs-comment">// Async Functionで例外が発生するとRejectedなPromiseが返される</span>
exceptionFn().catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(error.message); <span class="hljs-comment">// =&gt; &quot;例外が発生しました&quot;</span>
});
</code></pre>
<p>どの場合でもAsync Functionは必ずPromiseを返すことがわかります。
このようにAsync Functionを呼び出す側から見れば、Async FunctionはPromiseを返すただの関数と何も変わりません。</p>
<h2 id="await-expression"><a name="await-expression" class="plugin-anchor" href="#await-expression"><i class="fa fa-link" aria-hidden="true"></i></a><code>await</code>式 </h2>
<p><code>await</code>式は次の箇所で利用できる式です。
次の箇所以外では<code>await</code>式は構文エラーとなるため、利用できません。</p>
<ul>
<li>Async Functionの関数の直下</li>
<li>ECMAScriptモジュールの直下</li>
</ul>
<p>まず最初に、一般的に使われるAsync Functionの関数の直下における<code>await</code>式を見ていきます。</p>
<p><code>await</code>式は右辺の<code>Promise</code>インスタンスが<strong>Fulfilled</strong>または<strong>Rejected</strong>になるまでその場で非同期処理の完了を待ちます。
そして<code>Promise</code>インスタンスの状態が変わると、次の行の処理を再開します。</p>
<!-- doctest:disable -->
<pre><code class="lang-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncMain</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// PromiseがFulfilledまたはRejectedとなるまで待つ</span>
    <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>インスタンス;
    <span class="hljs-comment">// Promiseインスタンスの状態が変わったら処理を再開する</span>
}
</code></pre>
<p>普通の処理の流れでは、非同期処理を実行した場合にその非同期処理の完了を待つことなく、次の行（次の文）を実行します。
しかし<code>await</code>式では非同期処理を実行して完了するまで、次の行（次の文）を実行しません。
そのため<code>await</code>式を使うことで非同期処理が同期処理のように上から下へと順番に実行するような処理順で書けます。</p>
<!-- doctest:disable -->
<pre><code class="lang-js"><span class="hljs-comment">// async functionは必ずPromiseを返す</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doAsync</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// 非同期処理</span>
}
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncMain</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// doAsyncの非同期処理が完了するまでまつ</span>
    <span class="hljs-keyword">await</span> doAsync();
    <span class="hljs-comment">// 次の行はdoAsyncの非同期処理が完了されるまで実行されない</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;この行は非同期処理が完了後に実行される&quot;</span>);
}
</code></pre>
<p><code>await</code>式は、<code>await</code>の右辺（<code>Promise</code>インスタンス）の評価結果を値として返します（<strong>式</strong>については「<a href="../statement-expression/">文と式</a>」の章を参照）。
この<code>await</code>式の評価方法は評価するPromiseの状態（<strong>Fulfilled</strong>または<strong>Rejected</strong>）によって異なります。</p>
<p><code>await</code>の右辺のPromiseが<strong>Fulfilled</strong>となった場合は、resolveされた値が<code>await</code>式の返り値となります。</p>
<p>次のコードでは、<code>await</code>の右辺にある<code>Promise</code>インスタンスは<code>42</code>という値でresolveされています。
そのため<code>await</code>式の返り値は<code>42</code>となり、<code>value</code>変数にもその値が入ります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncMain</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">const</span> value = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">42</span>);
    <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// =&gt; 42</span>
}
asyncMain(); <span class="hljs-comment">// Promiseインスタンスを返す</span>
</code></pre>
<p>これはPromiseを使って書くと次のコードと同様の意味となります。
<code>await</code>式を使うことでコールバック関数を使わずに非同期処理の流れを表現できていることがわかります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncMain</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">42</span>).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// =&gt; 42</span>
    });
}
asyncMain(); <span class="hljs-comment">// Promiseインスタンスを返す</span>
</code></pre>
<p><code>await</code>式の右辺のPromiseが<strong>Rejected</strong>となった場合は、その場でエラーを<code>throw</code>します。
またAsync Function内で発生した例外は自動的にキャッチされます。
そのため<code>await</code>式でPromiseが<strong>Rejected</strong>となった場合は、そのAsync Functionが<strong>Rejected</strong>なPromiseを返すことになります。</p>
<p>次のコードでは、<code>await</code>の右辺にある<code>Promise</code>インスタンスが<strong>Rejected</strong>の状態になっています。
そのため<code>await</code>式は<code>エラー</code>を<code>throw</code>します。そのエラーを自動的にキャッチするため<code>asyncMain</code>関数は<strong>Rejected</strong>なPromiseを返します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncMain</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// `await`式で評価した右辺のPromiseがRejectedとなったため、例外がthrowされる</span>
    <span class="hljs-keyword">const</span> value = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;エラーメッセージ&quot;</span>));
    <span class="hljs-comment">// await式で例外が発生したため、この行は実行されません</span>
}
<span class="hljs-comment">// Async Functionは自動的に例外をキャッチできる</span>
asyncMain().catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(error.message); <span class="hljs-comment">// =&gt; &quot;エラーメッセージ&quot;</span>
});
</code></pre>
<p><code>await</code>式がエラーを<code>throw</code>するということは、そのエラーは<code>try...catch</code>構文でキャッチできます（詳細は「<a href="../error-try-catch/">例外処理</a>」の章の「<a href="../error-try-catch/#try-catch">try...catch構文</a>」を参照）。
通常の非同期処理では完了する前に次の行が実行されてしまうため<code>try...catch</code>構文ではエラーをキャッチできませんでした。
そのためPromiseでは<code>catch</code>メソッドを使ってPromise内で発生したエラーをキャッチしていました。</p>
<p>次のコードでは、<code>await</code>式で発生した例外を<code>try...catch</code>構文でキャッチしています。
そのため、<code>asyncMain</code>関数はResolvedなPromiseを返し、<code>catch</code>メソッドのコールバック関数は呼び出されません。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncMain</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// await式のエラーはtry...catchできる</span>
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// `await`式で評価した右辺のPromiseがRejectedとなったため、例外がthrowされる</span>
        <span class="hljs-keyword">const</span> value = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;エラーメッセージ&quot;</span>));
        <span class="hljs-comment">// await式で例外が発生したため、この行は実行されません</span>
    } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-built_in">console</span>.log(error.message); <span class="hljs-comment">// =&gt; &quot;エラーメッセージ&quot;</span>
    }
}
<span class="hljs-comment">// asyncMainはResolvedなPromiseを返す</span>
asyncMain().catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-comment">// すでにtry...catchされているため、この行は実行されません</span>
});
</code></pre>
<p>このように<code>await</code>式を使うことで、<code>try...catch</code>構文のように非同期処理を同期処理と同じ構文を使って扱えます。
またコードの見た目も同期処理と同じように、その行（その文）の処理が完了するまで次の行を評価しないという分かりやすい形になるのは大きな利点です。</p>
<h3 id="promise-chain-to-async-function"><a name="promise-chain-to-async-function" class="plugin-anchor" href="#promise-chain-to-async-function"><i class="fa fa-link" aria-hidden="true"></i></a>Promiseチェーンを<code>await</code>式で表現する </h3>
<!-- Promiseと配列にしなかったのは、Promiseの逐次処理を抽象化するにはArrayのreduceメソッドがでてくるため -->
<p>Async Functionと<code>await</code>式を使うことでPromiseチェーンとして表現していた非同期処理を同期処理のような見た目で書けます。
まずは、Promiseチェーンで複数の非同期処理を逐次的に行うケースを見ていきます。
その後に、同様の処理をAsync Functionと<code>await</code>式で書き直して比較してみます。</p>
<p>次のコードの<code>fetchAB</code>関数はリソースAとリソースBを順番に取得する処理をPromiseチェーンで書いています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dummyFetch</span>(<span class="hljs-params">path</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-keyword">if</span> (path.startsWith(<span class="hljs-string">&quot;/resource&quot;</span>)) {
                resolve({ <span class="hljs-attr">body</span>: <span class="hljs-string">`Response body of <span class="hljs-subst">${path}</span>`</span> });
            } <span class="hljs-keyword">else</span> {
                reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;NOT FOUND&quot;</span>));
            }
        }, <span class="hljs-number">1000</span> * <span class="hljs-built_in">Math</span>.random());
    });
}
<span class="hljs-comment">// リソースAとリソースBを順番に取得する</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchAB</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">const</span> results = [];
    <span class="hljs-keyword">return</span> dummyFetch(<span class="hljs-string">&quot;/resource/A&quot;</span>).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
        results.push(response.body);
        <span class="hljs-keyword">return</span> dummyFetch(<span class="hljs-string">&quot;/resource/B&quot;</span>);
    }).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
        results.push(response.body);
        <span class="hljs-keyword">return</span> results;
    });
}
<span class="hljs-comment">// リソースを取得して出力する</span>
fetchAB().then(<span class="hljs-function">(<span class="hljs-params">results</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(results); <span class="hljs-comment">// =&gt; [&quot;Response body of /resource/A&quot;, &quot;Response body of /resource/B&quot;]</span>
});
</code></pre>
<p>同様の処理をAsync Functionと<code>await</code>式で書くと次のように書けます。
<code>await</code>式を使ってリソースが取得できるまで待ち、その結果を変数<code>results</code>に追加していくという形で逐次処理が実装できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dummyFetch</span>(<span class="hljs-params">path</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-keyword">if</span> (path.startsWith(<span class="hljs-string">&quot;/resource&quot;</span>)) {
                resolve({ <span class="hljs-attr">body</span>: <span class="hljs-string">`Response body of <span class="hljs-subst">${path}</span>`</span> });
            } <span class="hljs-keyword">else</span> {
                reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;NOT FOUND&quot;</span>));
            }
        }, <span class="hljs-number">1000</span> * <span class="hljs-built_in">Math</span>.random());
    });
}
<span class="hljs-comment">// リソースAとリソースBを順番に取得する</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchAB</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">const</span> results = [];
    <span class="hljs-keyword">const</span> responseA = <span class="hljs-keyword">await</span> dummyFetch(<span class="hljs-string">&quot;/resource/A&quot;</span>);
    results.push(responseA.body);
    <span class="hljs-keyword">const</span> responseB = <span class="hljs-keyword">await</span> dummyFetch(<span class="hljs-string">&quot;/resource/B&quot;</span>);
    results.push(responseB.body);
    <span class="hljs-keyword">return</span> results;
}
<span class="hljs-comment">// リソースを取得して出力する</span>
fetchAB().then(<span class="hljs-function">(<span class="hljs-params">results</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(results); <span class="hljs-comment">// =&gt; [&quot;Response body of /resource/A&quot;, &quot;Response body of /resource/B&quot;]</span>
});
</code></pre>
<p>Promiseチェーンで<code>fetchAB</code>関数を書いた場合は、コールバックの中で処理するためややこしい見た目になりがちです。
<!-- textlint-disable -->
一方、Async Functionと<code>await</code>式で書いた場合は、取得と追加を順番に行うだけとなり、ネストがなく、見た目はシンプルです。
<!-- textlint-enable --></p>
<h2 id="async-function-combination"><a name="async-function-combination" class="plugin-anchor" href="#async-function-combination"><i class="fa fa-link" aria-hidden="true"></i></a>Async Functionと組み合わせ </h2>
<p>これまでで基本的なAsync Functionの動きを見てきましたが、他の構文やPromise APIと組み合わせたAsync Functionの使い方を見ていきましょう。</p>
<h3 id="async-function-array"><a name="async-function-array" class="plugin-anchor" href="#async-function-array"><i class="fa fa-link" aria-hidden="true"></i></a>Async Functionと反復処理 </h3>
<p>複数の非同期処理を行う際に、Async Functionはforループなどの反復処理と組み合わせることが可能です。</p>
<p>次のコードでは、指定したリソースのパスの配列を渡してそれらを順番に取得する<code>fetchResources</code>関数を実装しています。
Async Function内でfor文を使った反復処理を行い、forループの中で<code>await</code>文を使ってリソースの取得を待ち、その結果を追加しています。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dummyFetch</span>(<span class="hljs-params">path</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-keyword">if</span> (path.startsWith(<span class="hljs-string">&quot;/resource&quot;</span>)) {
                resolve({ <span class="hljs-attr">body</span>: <span class="hljs-string">`Response body of <span class="hljs-subst">${path}</span>`</span> });
            } <span class="hljs-keyword">else</span> {
                reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;NOT FOUND&quot;</span>));
            }
        }, <span class="hljs-number">1000</span> * <span class="hljs-built_in">Math</span>.random());
    });
}
<span class="hljs-comment">// 複数のリソースを順番に取得する</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchResources</span>(<span class="hljs-params">resources</span>) </span>{
    <span class="hljs-keyword">const</span> results = [];
    <span class="hljs-comment">// for...of文でresourcesの配列から1つずつ要素を取り出して処理</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> resource <span class="hljs-keyword">of</span> resources) {
        <span class="hljs-comment">// ループ内で非同期処理の完了を待っている</span>
        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> dummyFetch(resource);
        results.push(response.body);
    }
    <span class="hljs-comment">// 反復処理がすべて終わったら結果を返す(返り値となるPromiseを`results`でresolveする)</span>
    <span class="hljs-keyword">return</span> results;
}
<span class="hljs-comment">// 取得したいリソースのパス配列</span>
<span class="hljs-keyword">const</span> resources = [
    <span class="hljs-string">&quot;/resource/A&quot;</span>,
    <span class="hljs-string">&quot;/resource/B&quot;</span>
];
<span class="hljs-comment">// リソースを取得して出力する</span>
fetchResources(resources).then(<span class="hljs-function">(<span class="hljs-params">results</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(results); <span class="hljs-comment">// =&gt; [&quot;Response body of /resource/A&quot;, &quot;Response body of /resource/B&quot;]</span>
});
</code></pre>
<p>Async Functionでは、非同期処理であってもforループのような既存の構文と組み合わせて利用することが簡単です。
Promiseのみの場合は、Promiseチェーンでコールバック関数を使った反復処理を実装する必要があります。</p>
<h3 id="relationship-promise-async-function"><a name="relationship-promise-async-function" class="plugin-anchor" href="#relationship-promise-async-function"><i class="fa fa-link" aria-hidden="true"></i></a>Promise APIとAsync Functionを組み合わせる </h3>
<p>Async Functionと<code>await</code>式を使うことで、非同期処理を同期処理のような見た目で書けます。
一方で同期処理のような見た目となるため、複数の非同期処理を反復処理する場合に無駄な待ち時間を作ってしまうコードを書きやすくなります。</p>
<p>先ほどの<code>fetchResources</code>関数ではリソースを順番に1つずつ取得していました。
たとえば、リソースAとBを取得しようとした場合にかかる時間は、リソースAとBの取得時間の合計となります。
このとき、リソースAに1秒、リソースBに2秒かかるとした場合、すべてのリソースを取得するのに3秒かかります。</p>
<p>取得する順番に意味がない場合は、複数のリソースを同時に取得することで余計な待ち時間を解消できます。
先ほどの例ならば、リソースAとBを同時に取得すれば、最大でもリソースBの取得にかかる2秒程度ですべてのリソースが取得できるはずです。</p>
<p>Promiseチェーンでは<code>Promise.all</code>メソッドを使って、複数の非同期処理を1つの<code>Promise</code>インスタンスにまとめることで同時に取得していました。
<code>await</code>式が評価するのは<code>Promise</code>インスタンスであるため、<code>await</code>式も<code>Promise.all</code>メソッドと組み合わせて利用できます。</p>
<p>次のコードでは、<code>Promise.all</code>メソッドとAsync Functionを組み合わせて、同時にリソースを取得する<code>fetchAllResources</code>関数を実装しています。
<code>Promise.all</code>メソッドは複数のPromiseを配列で受け取り、それを1つのPromiseとしてまとめたものを返す関数です。
<code>Promise.all</code>メソッドの返す<code>Promise</code>インスタンスを<code>await</code>することで、非同期処理の結果を配列としてまとめて取得できます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dummyFetch</span>(<span class="hljs-params">path</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-keyword">if</span> (path.startsWith(<span class="hljs-string">&quot;/resource&quot;</span>)) {
                resolve({ <span class="hljs-attr">body</span>: <span class="hljs-string">`Response body of <span class="hljs-subst">${path}</span>`</span> });
            } <span class="hljs-keyword">else</span> {
                reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;NOT FOUND&quot;</span>));
            }
        }, <span class="hljs-number">1000</span> * <span class="hljs-built_in">Math</span>.random());
    });
}
<span class="hljs-comment">// 複数のリソースをまとめて取得する</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchAllResources</span>(<span class="hljs-params">resources</span>) </span>{
    <span class="hljs-comment">// それぞれのリソースを取得する非同期処理を呼び出す</span>
    <span class="hljs-keyword">const</span> promises = resources.map(<span class="hljs-function">(<span class="hljs-params">resource</span>) =&gt;</span> {
        <span class="hljs-keyword">return</span> dummyFetch(resource);
    });
    <span class="hljs-comment">// すべてのリソースが取得できるまで待つ</span>
    <span class="hljs-comment">// Promise.allは [ResponseA, ResponseB] のように結果が配列となる</span>
    <span class="hljs-keyword">const</span> responses = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(promises);
    <span class="hljs-comment">// 取得した結果からレスポンスのボディだけを取り出す</span>
    <span class="hljs-keyword">return</span> responses.map(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
        <span class="hljs-keyword">return</span> response.body;
    });
}
<span class="hljs-keyword">const</span> resources = [
    <span class="hljs-string">&quot;/resource/A&quot;</span>,
    <span class="hljs-string">&quot;/resource/B&quot;</span>
];
<span class="hljs-comment">// リソースを取得して出力する</span>
fetchAllResources(resources).then(<span class="hljs-function">(<span class="hljs-params">results</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(results); <span class="hljs-comment">// =&gt; [&quot;Response body of /resource/A&quot;, &quot;Response body of /resource/B&quot;]</span>
});
</code></pre>
<p>このようにAsync Functionや<code>await</code>式は既存のPromise APIと組み合わせて利用できます。
Async Functionも内部的にPromiseの仕組みを利用しているため、両者は対立関係ではなく共存関係になります。</p>
<h3 id="await-in-async-function"><a name="await-in-async-function" class="plugin-anchor" href="#await-in-async-function"><i class="fa fa-link" aria-hidden="true"></i></a><code>await</code>式はAsync Functionの直下でのみ利用可能 </h3>
<p>Async Functionで<code>await</code>式を利用する際には、<code>await</code>式が関数の直下でのみ利用可能な点に注意が必要です。</p>
<p>次のコードのように、Async Functionではない通常の関数で<code>await</code>式を使うと構文エラー（<code>SyntaxError</code>）となります。
これは、間違った<code>await</code>式の使い方を防止するための仕様です。</p>
<!-- textlint-disable -->
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a>
<!-- doctest: SyntaxError --></p>
<pre><code class="lang-js"><span class="hljs-comment">// asyncではない関数では`await`式は利用できない</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-comment">// SyntaxError: await is only valid in async functions</span>
    <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.resolve();
}
</code></pre>
<!-- textlint-enable eslint -->
<p>Async Function内で<code>await</code>式を使って処理を待っている間も、関数の外側では通常どおり処理が進みます。
次のコードを実行してみると、Async Function内で<code>await</code>しても、Async Function外の処理は停止していないことがわかります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncMain</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// 中でawaitしても、Async Functionの外側の処理まで止まるわけではない</span>
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">16</span>);
    });
}
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1. asyncMain関数を呼び出します&quot;</span>);
<span class="hljs-comment">// Async Functionは外から見れば単なるPromiseを返す関数</span>
asyncMain().then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;3. asyncMain関数が完了しました&quot;</span>);
});
<span class="hljs-comment">// Async Functionの外側の処理はそのまま進む</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2. asyncMain関数外では、次の行が同期的に呼び出される&quot;</span>);
</code></pre>
<p>このように<code>await</code>式でAsync Function内の非同期処理を一時停止しても、Async Function外の処理が停止するわけではありません。
Async Function外の処理も停止できてしまうと、JavaScriptでは基本的にメインスレッドで多くの処理をするため、UIを含めた他の処理が止まってしまいます。
これが<code>await</code>式がAsync Functionの外で利用できない理由の1つです。</p>
<!-- 仕様的にはAsync Execution Contextという特殊なものだけで使えるという話になる -->
<p>この仕様は、Async Functionをコールバック関数内で利用しようとしたときに混乱を生む場合があります。
具体例として、先ほどの逐次的にリソースを取得する<code>fetchResources</code>関数を見てみます。</p>
<p>先ほどの<code>fetchResources</code>関数ではforループと<code>await</code>式を利用していました。
このときにforループの代わりにArrayの<code>forEach</code>メソッドは利用できません。</p>
<p>単純に<code>fetchResources</code>関数のforループから<code>Array</code>の<code>forEach</code>メソッドに書き換えて見ると、構文エラー（<code>SyntaxError</code>）が発生してしまいます。
これは<code>await</code>式がAsync Functionの中でのみ利用ができる構文であるためです。</p>
<!-- textlint-disable -->
<!-- doctest:disable -->
<pre><code class="lang-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchResources</span>(<span class="hljs-params">resources</span>) </span>{
    <span class="hljs-keyword">const</span> results = [];
    <span class="hljs-comment">// Syntax Errorとなる例</span>
    resources.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resource</span>) </span>{
        <span class="hljs-comment">// Async Functionではないスコープで`await`式を利用しているためSyntax Errorとなる</span>
        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> dummyFetch(resource);
        results.push(response.body);
    });
    <span class="hljs-keyword">return</span> results;
}
</code></pre>
<!-- textlint-enable -->
<p>そのため、Arrayの<code>forEach</code>メソッドのコールバック関数もAsync Functionとして定義しないと、コールバック関数では<code>await</code>式が利用できません。</p>
<p>この構文エラーはArrayの<code>forEach</code>メソッドのコールバック関数をAsync Functionにすることで解決できます。
しかし、コールバック関数をAsync Functionにしただけでは、<code>fetchResources</code>関数は常に空の配列で解決されるPromiseを返すという意図しない挙動となります。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dummyFetch</span>(<span class="hljs-params">path</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-keyword">if</span> (path.startsWith(<span class="hljs-string">&quot;/resource&quot;</span>)) {
                resolve({ <span class="hljs-attr">body</span>: <span class="hljs-string">`Response body of <span class="hljs-subst">${path}</span>`</span> });
            } <span class="hljs-keyword">else</span> {
                reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;NOT FOUND&quot;</span>));
            }
        }, <span class="hljs-number">1000</span> * <span class="hljs-built_in">Math</span>.random());
    });
}
<span class="hljs-comment">// リソースを順番に取得する</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchResources</span>(<span class="hljs-params">resources</span>) </span>{
    <span class="hljs-keyword">const</span> results = [];
    <span class="hljs-comment">// コールバック関数をAsync Functionに変更</span>
    resources.forEach(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resource</span>) </span>{
        <span class="hljs-comment">// await式を利用できるようになった</span>
        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> dummyFetch(resource);
        results.push(response.body);
    });
    <span class="hljs-keyword">return</span> results;
}
<span class="hljs-keyword">const</span> resources = [<span class="hljs-string">&quot;/resource/A&quot;</span>, <span class="hljs-string">&quot;/resource/B&quot;</span>];
<span class="hljs-comment">// リソースを取得して出力する</span>
fetchResources(resources).then(<span class="hljs-function">(<span class="hljs-params">results</span>) =&gt;</span> {
    <span class="hljs-comment">// しかし、resultsは空になってしまう</span>
    <span class="hljs-built_in">console</span>.log(results); <span class="hljs-comment">// =&gt; []</span>
});
</code></pre>
<p>なぜこのようになるかを<code>fetchResources</code>関数の動きを見てみましょう。</p>
<p><code>forEach</code>メソッドのコールバック関数としてAsync Functionを渡し、コールバック関数中で<code>await</code>式を利用して非同期処理の完了を待っています。 
しかし、この非同期処理の完了を待つのはコールバック関数Async Functionの中だけで、コールバック関数の外側では<code>fetchResources</code>関数の処理が進んでいます。</p>
<p>次のように<code>fetchResources</code>関数にコンソールログを入れてみると動作がわかりやすいでしょう。
<code>forEach</code>メソッドのコールバック関数が完了するのは、<code>fetchResources</code>関数の呼び出しがすべて終わった後になります。
そのため、<code>forEach</code>メソッドのコールバック関数でリソースの取得が完了する前に、<code>fetchResources</code>関数はその時点の<code>results</code>である空の配列で解決してしまいます。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dummyFetch</span>(<span class="hljs-params">path</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-keyword">if</span> (path.startsWith(<span class="hljs-string">&quot;/resource&quot;</span>)) {
                resolve({ <span class="hljs-attr">body</span>: <span class="hljs-string">`Response body of <span class="hljs-subst">${path}</span>`</span> });
            } <span class="hljs-keyword">else</span> {
                reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;NOT FOUND&quot;</span>));
            }
        }, <span class="hljs-number">1000</span> * <span class="hljs-built_in">Math</span>.random());
    });
}
<span class="hljs-comment">// リソースを順番に取得する</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchResources</span>(<span class="hljs-params">resources</span>) </span>{
    <span class="hljs-keyword">const</span> results = [];
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1. fetchResourcesを開始&quot;</span>);
    resources.forEach(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resource</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`2. <span class="hljs-subst">${resource}</span>の取得開始`</span>);
        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> dummyFetch(resource);
        <span class="hljs-comment">// `dummyFetch`が完了するのは、`fetchResources`関数が返したPromiseが解決された後</span>
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`5. <span class="hljs-subst">${resource}</span>の取得完了`</span>);
        results.push(response.body);
    });
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;3. fetchResourcesを終了&quot;</span>);
    <span class="hljs-keyword">return</span> results;
}
<span class="hljs-keyword">const</span> resources = [<span class="hljs-string">&quot;/resource/A&quot;</span>, <span class="hljs-string">&quot;/resource/B&quot;</span>];
<span class="hljs-comment">// リソースを取得して出力する</span>
fetchResources(resources).then(<span class="hljs-function">(<span class="hljs-params">results</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;4. fetchResourcesの結果を取得&quot;</span>);
    <span class="hljs-built_in">console</span>.log(results); <span class="hljs-comment">// =&gt; []</span>
});
</code></pre>
<p>このように、Async Functionとコールバック関数を組み合わせた場合には気をつける必要があります。</p>
<p>この問題を解決する方法として、最初の<code>fetchResources</code>関数のように、コールバック関数を使わずにすむforループと<code>await</code>式を組み合わせる方法があります。
また、<code>fetchAllResources</code>関数のように、複数の非同期処理を1つのPromiseにまとめることでループ中に<code>await</code>式を使わないようにする方法があります。</p>
<h3 id="top-level-await-in-module"><a name="top-level-await-in-module" class="plugin-anchor" href="#top-level-await-in-module"><i class="fa fa-link" aria-hidden="true"></i></a>[ES2022] Module直下での<code>await</code>式 </h3>
<p>ES2021までは、<code>await</code>式はAsync Functionの直下でのみ利用可能なことを紹介しました。
ES2022には、これに加えてModuleの直下ではAsync Functionで囲まなくても<code>await</code>式が利用できます。</p>
<p>最初に「<a href="../introduction/">JavaScriptとは</a>」の章において、JavaScriptには実行コンテキストとして&quot;Script&quot;と&quot;Module&quot;があるという話をしました。
たとえば、ブラウザでは<code>&lt;script&gt;</code>と書けば&quot;Script&quot;として実行され、<code>&lt;script type=&quot;module&quot;&gt;</code>と書けば&quot;Module&quot;として実行されます。</p>
<p>&quot;Module&quot;としてJavaScriptを実行した時のみ、トップレベル（もっとも外側のスコープ）においてはAsync Functionなしで<code>await</code>式が利用できます。</p>
<p>たとえば、次のコードを&quot;Module&quot;として実行した場合は、Async Functionなしで<code>await</code>式が利用できていることがわかります。
これは、&quot;Module&quot;ではトップレベルでの<code>await</code>が許可されているためです。</p>
<!-- Top-Level awaitをVM2がサポートしていないため -->
<!-- js-console:{ "type": "module" } -->
<!-- doctest:disable -->
<pre><code class="lang-js"><span class="hljs-comment">// このコードはModuleのトップレベルでのみ動作する</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;実行開始&quot;</span>);
<span class="hljs-keyword">const</span> startTime = <span class="hljs-built_in">Date</span>.now();
<span class="hljs-comment">// awaitを使って1秒待つ</span>
<span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`実行終了: <span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now() - startTime}</span>ms 経過しました`</span>);
</code></pre>
<p>このようにModuleではトップレベルにおいて<code>await</code>式が利用できることは、Top-Level <code>await</code>と呼ばれます。</p>
<p>ES2021まではAsync Functionの直下のみでしか<code>await</code>式が利用できませんでした。
そのため、メイン処理のように他の処理を呼び出すスクリプトの開始地点で<code>await</code>を使いたい場合は、Async Functionを使った即時実行関数で<code>await</code>を囲むケースがありました。</p>
<pre><code class="lang-js"><span class="hljs-comment">// awaitを使うためだけに、Async Functionの即時実行関数を実行している</span>
(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// awaitを使う処理</span>
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> doAsyncTask();
    <span class="hljs-comment">// ...</span>
})();
</code></pre>
<p>しかし、ES2022ではTop-Level <code>await</code>が利用できるようになったため、&quot;Module&quot;においてはこのような即時実行関数は不要となります。</p>
<h2 id="error-first-callback"><a name="error-first-callback" class="plugin-anchor" href="#error-first-callback"><i class="fa fa-link" aria-hidden="true"></i></a>[コラム] エラーファーストコールバック </h2>
<p>ECMAScript 2015（ES2015）でPromiseが仕様に入るまで、非同期処理中に発生した例外を扱う仕様はありませんでした。
このため、ES2015より前までは、<strong>エラーファーストコールバック</strong>という非同期処理中に発生した例外を扱う方法をコミュニティで決めたルールが広く使われていました。</p>
<p>エラーファーストコールバックとは、非同期処理におけるコールバック関数の呼び出し方を決めた次のようなルールです。</p>
<ul>
<li>処理が失敗した場合は、コールバック関数の1番目の引数にエラーオブジェクトを渡して呼び出す</li>
<li>処理が成功した場合は、コールバック関数の1番目の引数には<code>null</code>を渡し、2番目以降の引数に成功時の結果を渡して呼び出す</li>
</ul>
<p>つまり、ひとつのコールバック関数で失敗した場合と成功した場合の両方を扱うルールとなります。</p>
<p>たとえば、Node.jsでは<code>fs.readFile</code>関数というファイルシステムからファイルをロードする非同期処理の関数があります。
指定したパスのファイルを読むため、ファイルが存在しない場合やアクセス権限の問題から読み取りに失敗することがあります。
そのため、<code>fs.readFile</code>関数の第2引数に渡すコールバック関数にはエラーファーストコールバックスタイルの関数を渡します。</p>
<p>ファイルを読み込むことに失敗した場合は、コールバック関数の1番目の引数に<code>Error</code>オブジェクトが渡されます。
ファイルを読み込むことに成功した場合は、コールバック関数の1番目の引数に<code>null</code>、2番目の引数に読み込んだデータを渡します。</p>
<!-- doctest:disable -->
<pre><code class="lang-js">fs.readFile(<span class="hljs-string">&quot;./example.txt&quot;</span>, <span class="hljs-function">(<span class="hljs-params">error, data</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (error) {
        <span class="hljs-comment">// 読み込み中にエラーが発生しました</span>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// データを読み込むことができました</span>
    }
});
</code></pre>
<p>このエラーファーストコールバックはNode.jsでは広く使われ、Node.jsの標準APIでも利用されています。
詳しい扱い方については、「<a href="../../use-case/nodecli/">ユースケース: Node.jsでCLIアプリケーション</a>」の章にて紹介します。</p>
<p>実際にエラーファーストコールバックで非同期な例外処理を扱うコードを書いてみましょう。</p>
<p>次のコードの<code>dummyFetch</code>関数は、疑似的なリソースの取得をする非同期な処理です。
第1引数に任意のパスを受け取り、第2引数にエラーファーストコールバックスタイルの関数を受け取ります。</p>
<p>この<code>dummyFetch</code>関数は、任意のパスにマッチするリソースがある場合には、第2引数のコールバック関数に<code>null</code>とレスポンスオブジェクトを渡して呼び出します。
一方、任意のパスにマッチするリソースがない場合には、第2引数のコールバック関数にエラーオブジェクトを渡して呼び出します。</p>
<p><a class="gitbook-plugin-js-console" aria-hidden="true"></a></p>
<pre><code class="lang-js"><span class="hljs-comment">/**
 * 1000ミリ秒未満のランダムなタイミングでレスポンスを疑似的にデータ取得する関数
 * 指定した`path`にデータがある場合は`callback(null, レスポンス)`を呼ぶ
 * 指定した`path`にデータがない場合は`callback(エラー)`を呼ぶ
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dummyFetch</span>(<span class="hljs-params">path, callback</span>) </span>{
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-comment">// /success からはじまるパスにはリソースがあるという設定</span>
        <span class="hljs-keyword">if</span> (path.startsWith(<span class="hljs-string">&quot;/success&quot;</span>)) {
            callback(<span class="hljs-literal">null</span>, { <span class="hljs-attr">body</span>: <span class="hljs-string">`Response body of <span class="hljs-subst">${path}</span>`</span> });
        } <span class="hljs-keyword">else</span> {
            callback(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;NOT FOUND&quot;</span>));
        }
    }, <span class="hljs-number">1000</span> * <span class="hljs-built_in">Math</span>.random());
}
<span class="hljs-comment">// /success/data にリソースが存在するので、`response`にはデータが入る</span>
dummyFetch(<span class="hljs-string">&quot;/success/data&quot;</span>, <span class="hljs-function">(<span class="hljs-params">error, response</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (error) {
        <span class="hljs-comment">// この行は実行されません</span>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">console</span>.log(response); <span class="hljs-comment">// =&gt; { body: &quot;Response body of /success/data&quot; }</span>
    }
});
<span class="hljs-comment">// /failure/data にリソースは存在しないので、`error`にはエラーオブジェクトが入る</span>
dummyFetch(<span class="hljs-string">&quot;/failure/data&quot;</span>, <span class="hljs-function">(<span class="hljs-params">error, response</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (error) {
        <span class="hljs-built_in">console</span>.log(error.message); <span class="hljs-comment">// =&gt; &quot;NOT FOUND&quot;</span>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// この行は実行されません</span>
    }
});
</code></pre>
<p>このように、コールバック関数の1番目の引数にはエラーオブジェクトまたは<code>null</code>を入れ、それ以降の引数にデータを渡すというルールを<strong>エラーファーストコールバック</strong>と呼びます。</p>
<p>エラーファーストコールバックは言語の仕様ではなく、非同期処理を扱う関数の呼び出し方をコミュニティで決めたルールです。
そのため、エラーファーストコールバックというルールを破ってもコードが動かなくなるわけではありません。
また、エラーファーストコールバックはPromiseとは異なり、コールバック内で例外が発生した場合に自動的にエラーをキャッチできる仕組みはありません。</p>
<p>Promiseが標準化されて以降は、多くの非同期APIはPromiseベースのAPIとして提供されています。
これはNode.jsのコアモジュールも同様で、現在（Node.js v18.14.0）ではPromiseベースのAPIが提供されています。
そのため、エラーファーストコールバックを新しいコードで利用することはかなり限定的となっています。</p>
<h2 id="conclusion"><a name="conclusion" class="plugin-anchor" href="#conclusion"><i class="fa fa-link" aria-hidden="true"></i></a>まとめ </h2>
<p>この章では、非同期処理に関するPromise、Async Functionについて学びました。</p>
<ul>
<li>非同期処理はその処理が終わるのを待つ前に次の処理を評価すること</li>
<li>非同期処理であってもメインスレッドで実行されることがある</li>
<li>Promiseは、ES2015で導入された非同期処理を扱うビルトインオブジェクト</li>
<li>Async Functionは、ES2017で導入された非同期処理を扱う構文</li>
<li>Async FunctionはPromiseの上に作られた構文であるため、Promiseと組み合わせて利用する</li>
<li>エラーファーストコールバックは、非同期処理での例外を扱うルールの1つで、Node.jsで広く使われていた</li>
</ul>
<p>PromiseやAsync Functionの応用パターンについては「<a href="https://azu.github.io/promises-book/" target="_blank">JavaScript Promiseの本</a>」も参照してください。</p>
</body></html>
                                
                                </section>
                            
                        </div>
                    </div>
                
<footer class="book_footer">
    <p>Copyright (c) 2016-present <a href="https://github.com/asciidwango/js-primer">jsprimer project</a></p>
</footer>

            </div>

            
                
                <a href="../error-try-catch/" class="navigation navigation-prev " aria-label="Previous page: 例外処理">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="../map-and-set/" class="navigation navigation-next " aria-label="Next page: Map/Set">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"author":"azu","description":"JavaScriptにおける非同期処理についてを紹介します。同期処理と非同期処理の違いやなぜ非同期処理が重要になるかを紹介します。非同期処理を扱うPromise、Async Functionについて紹介します。","title":"非同期処理:Promise/Async Function","level":"1.3.22","depth":2,"next":{"title":"Map/Set","level":"1.3.23","depth":2,"path":"basic/map-and-set/README.md","ref":"./basic/map-and-set/README.md","articles":[]},"previous":{"title":"例外処理","level":"1.3.21","depth":2,"path":"basic/error-try-catch/README.md","ref":"./basic/error-try-catch/README.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-lunr","page-toc-button","include-codeblock","anchors","canonical-link","js-console","github-issue-feedback","sandpack"],"root":"./source/","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"docSearch":{"index":"83I8JIFICQ","apiKey":"9169ce4cd84fcf2376f29d9585c89254"},"github-issue-feedback":{"repo":"asciidwango/js-primer","label":"問題を報告する"},"fontsettings":{"theme":"white","family":"sans","size":2},"js-console":{},"canonical-link":{"baseURL":"https://jsprimer.net"},"highlight":{},"page-toc-button":{"maxTocDepth":2,"minTocSize":2},"include-codeblock":{"check":false,"edit":false,"lang":"","fixlang":false,"template":"./resources/gitbook-plugin-include-codeblock.hbs","theme":"chrome","unindent":false},"sandpack":{},"edit-link":{"base":"https://github.com/asciidwango/js-primer/edit/master/source/","label":"Edit"},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"anchors":{}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"IPAexMincho","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"index.md","glossary":"GLOSSARY.md","summary":"README.md"},"variables":{"esversion":"2022","nodeversion":"18.14.0","npmversion":"9.3.1","triplebackticks":"```","console":"<a class=\"gitbook-plugin-js-console\" aria-hidden=\"true\"></a>"},"title":"JavaScript Primer #jsprimer","gitbook":">=3.0.0","description":"JavaScriptの基本的な書き方からアプリケーションの作成などのユースケースを学ぶための入門書です"},"file":{"path":"basic/async/README.md","mtime":"2023-02-18T09:37:29.323Z","type":"markdown"},"gitbook":{"version":"4.0.4","time":"2023-02-18T09:37:51.417Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-page-toc-button/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-js-console/console-ui.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-github-issue-feedback/plugin.js"></script>
        
    
        
        <script src="../../gitbook/honkit-plugin-sandpack/honkit-plugin-sandpack.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

