\hypertarget{module}{%
\chapter[ECMAScriptモジュール]{ECMAScriptモジュール\,\protect\icon{fig/es2015.eps}}\label{module}}\index{ECMAScriptもじゅーる@ECMAScriptモジュール}
\thispagestyle{frontheadings}

モジュールとは、変数や関数などをまとめたものです。
JavaScriptにおいては、1つのモジュールは1つのJavaScriptファイルに対応します。

モジュールについては「\hyperlink{node-cli}{Node.jsでCLIアプリのユースケース}」や「\hyperlink{todo-app}{Todoアプリのユースケース}」で実際に動かしながら学ぶため、ここでは構文の説明とモジュールのイメージをつかむのが目的です。
この章のサンプルコードを実際に動かすためにはローカルサーバーなどの準備が必要です。
そのため、ユースケースの章を先に読んでから戻ってきてもかまいません。

モジュールは、保守性・名前空間・再利用性のために使われます。

\begin{itemize}
\item
  \textgt{保守性}:
  依存性の高いコードの集合を一箇所にまとめ、それ以外のモジュールへの依存性を減らせます
\item
  \textgt{名前空間}:
  モジュールごとに分かれたスコープがあり、グローバルの名前空間を汚染しません
\item
  \textgt{再利用性}:
  便利な変数や関数を複数の場所にコピーアンドペーストせず、モジュールとして再利用できます
\end{itemize}

モジュールは変数や関数などをモジュール外部にエクスポートできます。また、モジュールからエクスポートされた変数や関数などをインポートして利用できます。
モジュールに処理を分けることで、コードの見通しが良くなったり、特定のことに関する処理をモジュールにまとめたり、処理を再利用できるようになります。
それによって、コードの行数が増えてきた場合にも、一度にみるコードの量をモジュールで分割できるようになり、メンテナンス性がよくなります。

この章では、\textbf{\textgt{ECMAScriptモジュール（ESモジュール\index{ESもじゅーる@ESモジュール}、JavaScriptモジュール\index{JavaScriptもじゅーる@JavaScriptモジュール}とも呼ばれる）}}について見ていきます。
ECMAScriptモジュールは、ES2015で導入されたJavaScriptファイルをモジュール化する言語標準の機能です。

\hypertarget{es-module-syntax}{%
\section{ECMAScriptモジュールの構文}\label{es-module-syntax}}

ECMAScriptモジュールは、\href{https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Statements/export}{export文}\index{export@\texttt{export}}によって変数や関数などをエクスポート\index{えくすぽーと@エクスポート}できます。
また、\href{https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Statements/import}{import文}\index{import@\texttt{import}}を使って別のモジュールからエクスポートされたものをインポート\index{いんぽーと@インポート}できます。
インポートとエクスポートはそれぞれに \textbf{\textgt{名前つき}}と
\textbf{\textgt{デフォルト}}という2種類の方法があります。

まずは名前つきエクスポート／インポート文について見ていきましょう。

\hypertarget{named-export-import}{%
\subsection{名前つきエクスポート／インポート}\label{named-export-import}}\index{なまえつきえくすぽーと@名前つきエクスポート}\index{えくすぽーと@エクスポート!なまえつき@名前つき}\index{なまえつきいんぽーと@名前つきインポート}\index{いんぽーと@インポート!なまえつき@名前つき}

\textbf{\textgt{名前つきエクスポート}}は、モジュールごとに複数の変数や関数などをエクスポートできます。
次の例では、\texttt{foo}変数と\texttt{bar}関数をそれぞれ名前つきエクスポートしています。
\texttt{export}文のあとに続けて\texttt{\{\}}を書き、その中にエクスポートする変数を入れることで、宣言済みの変数を名前つきエクスポートできます。

\begin{listtitle}
named-export.js
\end{listtitle}
\begin{lstlisting}
const foo = "foo";
// 宣言済みのオブジェクトを名前つきエクスポートする
export { foo };
\end{lstlisting}
\listend

また、名前つきエクスポートでは\texttt{export}文を宣言の前につけると、宣言と同時に名前つきエクスポートできます。

\begin{listtitle}
named-export-declare.js
\end{listtitle}
\begin{lstlisting}
// 宣言と同時に名前つきエクスポートする
export function bar() { };
\end{lstlisting}
\listend

\textbf{\textgt{名前つきインポート}}は、指定したモジュールから名前を指定して選択的にインポートできます。
次の例では
\texttt{my-module.js}から名前つきエクスポートされたオブジェクトの名前を指定して名前つきインポートしています。
\texttt{import}文のあとに続けて\texttt{\{\}}を書き、その中にインポートしたい名前つきエクスポートの名前を入れます。
複数の値をインポートしたい場合は、それぞれの名前をカンマで区切ります。

\begin{listtitle}
my-module.js
\end{listtitle}
\begin{lstlisting}
export const foo = "foo";
export function bar() { }
\end{lstlisting}
\listend

\begin{listtitle}
named-import.js
\end{listtitle}
\enlargethispage{\baselineskip}\begin{lstlisting}
// 名前つきエクスポートされたfooとbarをインポートする
import { foo, bar } from "./my-module.js";
console.log(foo); // => "foo"
console.log(bar); // => function bar()
\end{lstlisting}
\listend

\hypertarget{named-export-import-alias}{%
\subsubsection{名前つきエクスポート／インポートのエイリアス}\label{named-export-import-alias}}\index{なまえつきえくすぽーと@名前つきエクスポート!えいりあす@エイリアス}\index{なまえつきいんぽーと@名前つきインポート!えいりあす@エイリアス}\index{えいりあす@エイリアス}

名前つきエクスポート／インポートには\textbf{\textgt{エイリアス}}の仕組みがあります。
エイリアスを使うと、宣言済みの変数を違う名前で名前つきエクスポートできます。
エイリアスをつけるには、次のように\texttt{as}\index{as@\texttt{as}}のあとにエクスポートしたい名前を記述します。

\begin{listtitle}
named-export-alias.js
\end{listtitle}
\begin{lstlisting}
const internalFoo = "foo";
// internalFoo変数をfooとして名前つきエクスポートする
export { internalFoo as foo };
\end{lstlisting}
\listend

また、名前つきインポートしたオブジェクトにも別名をつけることができます。
インポートでも同様に、\texttt{as}のあとに別名を記述します。

\begin{listtitle}
named-import-alias.js
\end{listtitle}
\begin{lstlisting}
// fooとして名前つきエクスポートされた変数をmyFooとしてインポートする
import { foo as myFoo } from "./named-export-alias.js";
console.log(myFoo); // => "foo"
\end{lstlisting}
\listend

\hypertarget{default-export-import}{%
\subsection{デフォルトエクスポート／インポート}\label{default-export-import}}\index{でふぉるとえくすぽーと@デフォルトエクスポート}\index{えくすぽーと@エクスポート!でふぉると@デフォルト}\index{でふぉるといんぽーと@デフォルトインポート}\index{いんぽーと@インポート!でふぉると@デフォルト}

次に、デフォルトエクスポート／インポートについて見ていきましょう。
\textbf{\textgt{デフォルトエクスポート}}は、モジュールごとに1つしかエクスポートできない特殊なエクスポートです。
次の例は、すでに宣言されている変数をデフォルトエクスポートしています。
\texttt{export default}\index{export default@\texttt{export default}}文で、後に続く式の評価結果をデフォルトエクスポートします。

\begin{listtitle}
default-export.js
\end{listtitle}
\begin{lstlisting}
const foo = "foo";
// foo変数の値をデフォルトエクスポートする
export default foo;
\end{lstlisting}
\listend

また、\texttt{export}文を宣言の前につけると、宣言と同時にデフォルトエクスポートできます。
このとき関数やクラスの名前を省略できます。

\begin{lstlisting}
// 宣言と同時に関数をデフォルトエクスポートする
export default function() {}
\end{lstlisting}
\newpage
ただし、変数宣言は宣言とデフォルトエクスポートを同時に行うことはできません。
なぜなら、変数宣言はカンマ区切りで複数の変数を定義できてしまうためです。
次の例は実行できない不正なコードです。\enlargethispage{\baselineskip}

\begin{lstlisting}
// 変数宣言と同時にデフォルトエクスポートはできない
export default const foo = "foo", bar = "bar";
\end{lstlisting}

\textbf{\textgt{デフォルトインポート}}は、指定したモジュールのデフォルトエクスポートに名前をつけてインポートします。
次の例では
\texttt{my-module.js}のデフォルトエクスポートに\texttt{myModule}という名前をつけてインポートしています。
\texttt{import}\index{import@\texttt{import}}文のあとに任意の名前をつけることで、デフォルトエクスポートをインポートできます。

\begin{listtitle}
my-module.js
\end{listtitle}
\begin{lstlisting}
export default {
    baz: "baz"
};
\end{lstlisting}
\listend

\begin{listtitle}
default-import.js
\end{listtitle}
\begin{lstlisting}
// デフォルトエクスポートをmyModuleとしてインポートする
import myModule from "./my-module.js";
console.log(myModule); // => { baz: "baz" }
\end{lstlisting}
\listend

実はデフォルトエクスポートは、\texttt{default}\index{default@\texttt{default}}という固有の名前による名前つきエクスポートと同じものです。
そのため、名前つきエクスポートで\texttt{as default}とエイリアス\index{えいりあす@エイリアス}をつけることでデフォルトエクスポートすることもできます。

\begin{listtitle}
default-export-alias.js
\end{listtitle}
\begin{lstlisting}
const foo = "foo";
// foo変数の値をデフォルトエクスポートする
export { foo as default };
\end{lstlisting}
\listend

同様に、名前つきインポートにおいても\texttt{default}という名前がデフォルトインポートに対応しています。
次のように、名前つきインポートで\texttt{default}を指定するとデフォルトインポートできます。
ただし、\texttt{default}は予約語なので、この方法では必ず\texttt{as}構文を使ってエイリアスをつける必要があります。

\begin{listtitle}
default-import-alias.js
\end{listtitle}
\begin{lstlisting}
// デフォルトエクスポートをmyModuleとしてインポートする
import { default as myModule } from "./my-module.js";
console.log(myModule); // => { baz: "baz" }
\end{lstlisting}
\listend

また、名前つきインポートとデフォルトインポートの構文は同時に記述できます。
次のように2つの構文をカンマでつなげます。

\begin{listtitle}
default-import-with-named.js
\end{listtitle}
\begin{lstlisting}
// myModuleとしてデフォルトインポートし、
// fooを名前つきインポートする
import myModule, { foo } from "./my-module.js";
console.log(foo); // => "foo"
console.log(myModule); // => { baz: "baz" }
\end{lstlisting}
\listend

ECMAScriptモジュールでは、エクスポートされていないものはインポートできません。
なぜならECMAScriptモジュールはJavaScriptのパース段階で依存関係が解決され、インポートする対象が存在しない場合はパースエラーとなるためです。
デフォルトインポートは、インポート先のモジュールがデフォルトエクスポートをしている必要があります。
同様に名前つきインポートは、インポート先のモジュールが指定した名前つきエクスポートをしている必要があります。

\hypertarget{other-syntax}{%
\subsection{その他の構文}\label{other-syntax}}

ECMAScriptモジュールには名前つきとデフォルト以外にもいくつかの構文があります。

\hypertarget{re-export}{%
\subsubsection{再エクスポート}\label{re-export}}\index{さいえくすぽーと@再エクスポート}

再エクスポートとは、別のモジュールからインポートしたものを、改めて自分自身からエクスポートし直すことです。
複数のモジュールからエクスポートされたものをまとめたモジュールを作るときなどに使われます。

再エクスポートは次のように\texttt{export}文のあとに\texttt{from}\index{from@\texttt{from}}を続けて、別のモジュール名を指定します。

\input{./src/module/re-export-invalid.js.tex}

\hypertarget{namespace-import}{%
\subsubsection{すべてをインポート}\label{namespace-import}}\index{いんぽーと@インポート!すべて}

\texttt{import * as}構文は、すべての名前つきエクスポートをまとめてインポートします。
この方法では、モジュールごとの \textbf{\textgt{名前空間}}
となるオブジェクトを宣言します。
エクスポートされた変数や関数などにアクセスするには、その名前空間オブジェクトのプロパティを使います。
また、先ほどのとおり、\texttt{default}
という固有名を使うとデフォルトエクスポートにもアクセスできます。

\begin{listtitle}
my-module.js
\end{listtitle}
\begin{lstlisting}
export const foo = "foo";
export function bar() { }
export default {
    baz: "baz"
};
\end{lstlisting}
\listend

\begin{listtitle}
namespace-import.js
\end{listtitle}
\begin{lstlisting}
// すべての名前つきエクスポートをmyModuleオブジェクトとしてまとめてインポートする
import * as myModule from "./my-module.js";
// fooとして名前つきエクスポートされた値にアクセスする
console.log(myModule.foo); // => "foo"
// defaultとしてデフォルトエクスポートされた値にアクセスする
console.log(myModule.default); // => { baz: "baz" }
\end{lstlisting}
\listend

\hypertarget{import-for-side-effect}{%
\subsubsection{副作用のためのインポート}\label{import-for-side-effect}}

モジュールの中には、グローバルのコードを実行するだけで何もエクスポートしないものがあります。
たとえば次のような、グローバル変数を操作するためのモジュールなどです。

\begin{listtitle}
side-effects.js
\end{listtitle}
\begin{lstlisting}
// グローバル変数を操作する(副作用)
window.foo = "foo";
\end{lstlisting}
\listend

このようなモジュールをインポートするには、副作用のためのインポート構文を使います。
この構文では、指定したモジュールを読み込んで実行するだけで、何もインポートしません。\enlargethispage{\baselineskip}

\begin{lstlisting}
// ./side-effects.jsのグローバルコードが実行される
import "./side-effects.js";
\end{lstlisting}

\hypertarget{run-es-modules}{%
\section{ECMAScriptモジュールを実行する}\label{run-es-modules}}

作成したECMAScriptモジュールを実行するためには、起点となるJavaScriptファイルをECMAScriptモジュールとしてウェブブラウザに読み込ませる必要があります。
ウェブブラウザは\texttt{script}要素によってJavaScriptファイルを読み込み、実行します。
次のように\texttt{script}要素に\texttt{type="module"}属性を付与すると、ウェブブラウザはJavaScriptファイルをECMAScriptモジュールとして読み込みます。

\begin{lstlisting}[language=HTML]
<!-- my-module.jsをECMAScriptモジュールとして読み込む -->
<script type="module" src="./my-module.js"></script>
<!-- インラインでも同じ -->
<script type="module">
import { foo } from "./my-module.js";
</script>
\end{lstlisting}

\texttt{type="module"}属性が付与されない場合は通常のスクリプトとして扱われ、ECMAScriptモジュールの機能は使えません。
スクリプトとして読み込まれたJavaScriptで\texttt{import}文や\texttt{export}文を使用すると、構文エラーが発生します。

ウェブブラウザの環境では、インポートされるモジュールの取得はネットワーク経由で解決されます。
そのため、モジュール名はJavaScriptファイルの絶対URLあるいは相対URLを指定します。
詳しくは「\hyperlink{todo-app}{ユースケース: Todoアプリケーション}」を参照してください。
