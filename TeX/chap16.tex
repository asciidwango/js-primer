\hypertarget{string-unicode}{%
\chapter{文字列とUnicode}\label{string-unicode}}\index{もじれつ@文字列}\index{Unicode}
\thispagestyle{frontheadings}

「\hyperlink{string}{文字列}」の章で紹介したように、JavaScriptは文字コードとしてUnicodeを採用し、エンコード方式としてUTF-16\index{UTF-16}を採用しています。
このUTF-16を採用しているのは、あくまでJavaScriptの内部で文字列を扱う際の文字コード（内部コード\index{ないぶこーど@内部コード}）です。
そのため、コードを書いたファイル自体の文字コード（外部コード\index{がいぶこーど@外部コード}）は、UTF-8\index{UTF-8}のようにUTF-16以外の文字コードであっても問題ありません。

「\hyperlink{string}{文字列}」の章では、これらの文字コードは意識していなかったように、内部的にどのような文字コードで扱っているかは意識せずに文字列処理ができます。
しかし、JavaScriptのStringオブジェクトにはこの文字コード（Unicode）に特化したAPIもあります。
また、絵文字を含む特定の文字を扱う際や「文字数」を数えるという場合には、内部コードであるUTF-16を意識しないといけない場面があります。

この章では、文字列におけるUnicodeを意識しないといけない場面について見ていきます。
また、Unicode自体もECMAScriptと同じように歴史がある仕様であり、Unicodeのすべてを紹介するには膨大な文章が必要になります。
そのため、この章はJavaScriptにおけるUnicodeとUTF-16に話を限定しています。

Unicodeの歴史を含めた文字コード自体について詳しく知りたい方は「\href{https://gihyo.jp/book/2019/978-4-297-10291-3}{プログラマのための文字コード技術入門}」\footnote{『［改訂新版］プログラマのための文字コード技術入門』矢野啓介 著、技術評論社}や「\href{https://www.rutles.net/products/detail.php?product_id=298}{文字コード「超」研究}」\footnote{『文字コード「超」研究 改訂第2版』深沢千尋 著、ラトルズ}等を参照してください。

\hypertarget{code-point}{%
\section{Code Point}\label{code-point}}\index{Code Point}

Unicodeはすべての文字（制御文字などの画面に表示されない文字も含む）に対してIDを定義する目的で策定されている仕様です。
この「文字」に対する「一意のID」のことを\textbf{Code
Point}（符号位置\index{ふごういち@符号位置}）と呼びます。

Code Pointを扱うメソッドの多くは、ECMAScript 2015で追加されています。
ES2015で追加されたStringの\texttt{codePointAt}メソッドや\texttt{String.fromCodePoint}静的メソッドを使うことで、文字列とCode
Pointを相互変換できます。

Stringの\texttt{codePointAt}\index{codePointAt@\texttt{codePointAt}}メソッド\,\protect\iconl{fig/es2015.eps}\,は、文字列の指定インデックスにある文字のCode
Pointの値を返します。

\begin{lstlisting}
// 文字列"あ"のCode Pointを取得
console.log("あ".codePointAt(0)); // => 12354
\end{lstlisting}

一方の\texttt{String.fromCodePoint}\index{String.fromCodePoint@\texttt{String.fromCodePoint}}メソッド\,\protect\iconl{fig/es2015.eps}\,は、指定したCode
Pointに対応する文字を返します。

\begin{lstlisting}
// Code Pointが12354の文字を取得する
console.log(String.fromCodePoint(12354)); // => "あ"
// 12354を16進数リテラルで表記しても同じ結果
console.log(String.fromCodePoint(0x3042)); // => "あ"
\end{lstlisting}

また、文字列リテラル中にはUnicodeエスケープシーケンス\index{Unicode!えすけーぷしーけんす@エスケープシーケンス}で、直接Code
Pointを書くこともできます。 Code
Pointは\texttt{\textbackslash u\{Code Pointの16進数の値\}}\index{\\u@\texttt{\textbackslash u}}のようにエスケープシーケンスとして記述できます。
Unicodeエスケープシーケンスでは、Code
Pointの16進数の値が必要となります。
Numberの\texttt{toString}メソッドの引数に基数となる\texttt{16}を渡すことで、16進数の文字列を取得できます。

\begin{lstlisting}[escapechar=\%]
// "あ"のCode Pointは12354
const codePointOf%\hbox{}%あ = "あ".codePointAt(0);
// 12354の16進数表現は"3042"
const hexOf%\hbox{}%あ = codePointOf%\hbox{}%あ.toString(16);
console.log(hexOf%\hbox{}%あ);// => "3042"
// Unicodeエスケープで"あ"を表現できる
console.log("\u{3042}"); // => "あ"
\end{lstlisting}

\hypertarget{code-point-is-not-code-unit}{%
\section{Code PointとCode
Unitの違い}\label{code-point-is-not-code-unit}}\index{Code Point}\index{Code Unit}

Code
Point（符号位置\index{ふごういち@符号位置}）について紹介しましたが、JavaScriptの文字列の構成要素はUTF-16で変換されたCode
Unit（符号単位\index{ふごうたんい@符号単位}）です（詳細は「\hyperlink{string}{文字列}」の章を参照）。
ある範囲の文字列については、Code Point（符号位置）とCode
Unit（符号単位）は結果として同じ値となります。

次のコードでは、\texttt{アオイ}という文字列の各要素をCode
PointとCode Unitとして表示しています。
\texttt{convertCodeUnits}関数は文字列をCode
Unitの配列にし、\texttt{convertCodePoints}関数は文字列をCode
Pointの配列にしています。それぞれの関数の実装はまだ理解しなくても問題ありません。

\begin{lstlisting}
// 文字列をCode Unit(16進数)の配列にして返す
function convertCodeUnits(str) {
    const codeUnits = [];
    for (let i = 0; i < str.length; i++) {
        codeUnits.push(str.charCodeAt(i).toString(16));
    }
    return codeUnits;
}
// 文字列をCode Point(16進数)の配列にして返す
function convertCodePoints(str) {
    return Array.from(str).map(char => {
        return char.codePointAt(0).toString(16);
    });
}

const str = "アオイ";
const codeUnits = convertCodeUnits(str);
console.log(codeUnits); // => ["30a2", "30aa", "30a4"]
const codePoints = convertCodePoints(str);
console.log(codePoints); // => ["30a2", "30aa", "30a4"]
\end{lstlisting}

実行した結果をまとめてみると、この文字列においてはCode PointとCode
Unitが同じ値になっていることがわかります。

\begin{small}
\begin{longtable}[l]{p{73mm}|p{20mm}|p{20mm}|p{20mm}}
\caption{文字列におけるCode UnitとCode Pointの表}\\
\hline\rowcolor[gray]{0.85}\rule[0mm]{0mm}{4mm}\textgt{インデックス} & \textgt{0} & \textgt{1} & \textgt{2}\tabularnewline
\hline
\endhead
文字列 & ア & オ & イ\tabularnewline
UnicodeのCode Point（16進数）& 0x30A2 & 0x30AA & 0x30A4\tabularnewline
UTF-16のCode Unit（16進数） & 0x30A2 & 0x30AA & 0x30A4\tabularnewline
\hline
\end{longtable}
\end{small}

しかし、文字列によってはCode PointとCode
Unitが異なる値となる場合があります。

先ほどと同じ関数を使い、リンゴ\includegraphics[clip,height=4mm]{fig/apple.eps}（リンゴの絵文字\index{えもじ@絵文字}）という文字列を構成するCode
UnitとCode Pointを見比べてみます。

\begin{lstlisting}[escapechar=@]
// 文字列をCode Unit(16進数)の配列にして返す
function convertCodeUnits(str) {
    const codeUnits = [];
    for (let i = 0; i < str.length; i++) {
        codeUnits.push(str.charCodeAt(i).toString(16));
    }
    return codeUnits;
}
// 文字列をCode Point(16進数)の配列にして返す
function convertCodePoints(str) {
    return Array.from(str).map(char => {
        return char.codePointAt(0).toString(16);
    });
}

const str = "リンゴ@\includegraphics[clip,height=4mm]{fig/apple.eps}@";
const codeUnits = convertCodeUnits(str);
console.log(codeUnits); // => ["30ea", "30f3", "30b4", "d83c", "df4e"]
const codePoints = convertCodePoints(str);
console.log(codePoints); // => ["30ea", "30f3", "30b4", "1f34e"]
\end{lstlisting}

実行した結果をまとめてみると、この絵文字を含む文字列においてはCode
PointとCode Unitが異なる値となることがわかります。

\begin{small}
\begin{longtable}[l]{p{50mm}|p{15mm}|p{15mm}|p{15mm}|p{15mm}|p{15mm}}
\caption{絵文字を含んだ文字列におけるCode UnitとCode Pointの表}\\
\hline\rowcolor[gray]{0.85}\rule[0mm]{0mm}{4mm}\textgt{インデックス} & \textgt{0} & \textgt{1} & \textgt{2} & \textgt{3} & \textgt{4}\tabularnewline
\hline
\endhead
文字列 & リ & ン & ゴ & \includegraphics[clip,height=4mm]{fig/apple.eps} & \tabularnewline
UnicodeのCode Point（16進数）& 0x30ea & 0x30f3 & 0x30b4 & 0x1f34e & \tabularnewline
UTF-16のCode Unit（16進数） & 0x30ea & 0x30f3 & 0x30b4 & 0xd83c & 0xdf4e\tabularnewline
\hline
\end{longtable}
\end{small}

具体的には、Code Pointの要素数が4つなのに対して、Code
Unitの要素数が5つになっています。 また、Code Pointでは1つのCode
Pointが\includegraphics[clip,height=4mm]{fig/apple.eps}に対応していますが、Code
Unitでは2つのCode
Unitで\includegraphics[clip,height=4mm]{fig/apple.eps}に対応しています。JavaScriptでは「文字列はCode
Unitが順番に並んだもの」として扱われるためこの文字列の要素数（長さ）はCode
Unitの個数である5つとなっています。

ある1つの文字に対応するIDであるCode Pointを、16ビット（2バイト）のCode
Unitで表現するのがUTF-16というエンコード方式です。しかし、16ビット（2バイト）で表現できる範囲は、65536種類（2の16乗）です。
現在、Unicodeに登録されているCode
Pointは10万種類を超えているため、すべての文字とCode
Unitを1対1の関係で表すことができません。

このような場合に、UTF-16では2つCode
Unitの組み合わせ（合計4バイト）で1つの文字（1つのCode
Point）を表現します。この仕組みを\textbf{\textgt{サロゲートペア}}と呼びます。

\hypertarget{surrogate-pair}{%
\section{サロゲートペア}\label{surrogate-pair}}\index{さろげーとぺあ@サロゲートペア}

サロゲートペアでは、2つのCode
Unitの組み合わせ（合計4バイト）で1つの文字（1つのCode
Point）を表現します。UTF-16では、次の範囲をサロゲートペアに利用する領域としています。

\begin{itemize}
\item
  \texttt{\textbackslash uD800}～\texttt{\textbackslash uDBFF}：上位サロゲートの範囲
\item
  \texttt{\textbackslash uDC00}～\texttt{\textbackslash uDFFF}：下位サロゲートの範囲
\end{itemize}

文字列中に上位サロゲート\index{じょういさろげーと@上位サロゲート}と下位サロゲート\index{かいさろげーと@下位サロゲート}のCode
Unitが並んだ場合に、2つのCode Unitを組み合わせて1文字（Code
Point）として扱います。

次のコードでは、サロゲートペアの文字である「𩸽（ほっけ）」を次の2つのCode
Unitで表現しています。 Code
Unitのエスケープシーケンス（\texttt{\textbackslash uXXXX}）を2つ並べることで𩸽という文字を表現できます。
一方で、ES2015からはCode
Pointのエスケープシーケンス（\texttt{\textbackslash u\{XXXX\}}）も書けるため、1つのCode
Pointで𩸽という文字を表現できることもわかります。しかし、Code
Pointのエスケープシーケンスで書いた場合でも、内部的にCode
Unitに変換された値で保持されることは変わりません。

\begin{lstlisting}
// 上位サロゲート + 下位サロゲートの組み合わせ
console.log("\uD867\uDE3D"); // => "𩸽"
// Code Pointでの表現
console.log("\u{29e3d}"); // => "𩸽"
\end{lstlisting}

先ほどの例で登場した\includegraphics[clip,height=4mm]{fig/apple.eps}（リンゴの絵文字）もサロゲートペアで表現される文字です。

\begin{lstlisting}[escapechar=@]
// Code Unit（上位サロゲート + 下位サロゲート）
console.log("\uD83C\uDF4E"); // => "@\includegraphics[clip,height=4mm]{fig/apple.eps}@"
// Code Point
console.log("\u{1F34E}"); // => "@\includegraphics[clip,height=4mm]{fig/apple.eps}@"
\end{lstlisting}

このようにサロゲートペアでは、2つのCode Unitで1つのCode
Pointを表現します。

基本的には、文字列はCode
Unitが順番に並んでいるものとして扱われるため、多くの\texttt{String}のメソッドはCode
Unitごとに作用します。 また、インデックスアクセスもCode
Unitごととなります。そのため、サロゲートペアで表現されている文字列では、上位サロゲート（0番目）と下位サロゲート（1番目）へのインデックスアクセスになります。

\begin{lstlisting}
// 内部的にはCode Unitが並んでいるものとして扱われている
console.log("\uD867\uDE3D"); // => "𩸽"
// インデックスアクセスもCode Unitごととなる
console.log("𩸽"[0]); // => "\uD867"
console.log("𩸽"[1]); // => "\uDE3D"
\end{lstlisting}

絵文字や「𩸽（ほっけ）」などのサロゲートペアで表現される文字が文字列中に含まれると、Code
Unitごとに扱う文字列処理は複雑になります。

たとえば、Stringの\texttt{length}\index{length@\texttt{length}}プロパティは文字列におけるCode
Unitの要素数を数えるため、\texttt{"}\includegraphics[clip,height=4mm]{fig/apple.eps}\texttt{".length}の結果は\texttt{2}となります。

\begin{lstlisting}[escapechar=@]
console.log("@\includegraphics[clip,height=4mm]{fig/apple.eps}@".length); // => 2
\end{lstlisting}

このような場合には、文字列をCode
Pointごとに処理することを考える必要があります。

\hypertarget{handle-code-point}{%
\section{Code Pointを扱う}\label{handle-code-point}}\index{Code Point}

文字列をCode Pointが順番に並んだものとして扱うには、Code
Pointに対応したメソッドなどを利用する必要があります。

ES2015から文字列をCode Pointごとに扱うメソッドや構文が追加されています。
次に紹介するものは、文字列をCode Pointごとに扱います。

\begin{itemize}
\item
  \texttt{CodePoint}を名前に含むメソッド
\item
  \texttt{u}（Unicode）フラグが有効化されている正規表現
\item
  文字列のIteratorを扱うもの（Destructuring、\texttt{for...of}、\texttt{Array.from}メソッドなど）
\end{itemize}

これらのCode Pointを扱う処理と具体的な使い方を見ていきます。

\hypertarget{regexp-unicode}{%
\subsection{\texorpdfstring{正規表現の\texttt{.}とUnicode}{正規表現の.とUnicode}}\label{regexp-unicode}}\index{せいきひょうげん@正規表現}\index{Unicode}

ES2015では、正規表現に\texttt{u}（Unicode）フラグが追加されました。
この\texttt{u}フラグ\index{uふらぐ@\texttt{u}フラグ}をつけた正規表現は、文字列をCode
Pointが順番に並んだものとして扱います。

具体的に\texttt{u}フラグの有無による\texttt{.}（改行文字以外のどの1文字にもマッチする特殊文字）の動作の違いを見ていきます。

\texttt{/(.)のひらき/}というパターンで\texttt{.}にマッチする部分を取り出すことを例に見ていきます。

まずは、\texttt{u}フラグをつけていない正規表現とStringの\texttt{match}メソッドでマッチした範囲を取り出してみます。\texttt{match}メソッドの返す値は\texttt{[マッチした全体の文字列, キャプチャされた文字列]}です（詳細は「\hyperlink{string}{文字列}」の章を参照）。

実際にマッチした結果を見てみると、\texttt{.}は𩸽の下位サロゲートである\texttt{\textbackslash ude3d}にマッチしていることがわかります（\texttt{\textbackslash ude3d}は単独では表示できないため、文字化けのように表示されます）。

\begin{lstlisting}
const [all, fish] = "𩸽のひらき".match(/(.)のひらき/);
console.log(all); // => "\ude3dのひらき"
console.log(fish); // => "\ude3d"
\end{lstlisting}

つまり、\texttt{u}フラグをつけていない正規表現は、文字列をCode
Unitが順番に並んだものとして扱っています。

このような意図しない結果を避けるには、正規表現に\texttt{u}フラグをつけます。
\texttt{u}フラグがついた正規表現は、文字列をCode
Pointごとに扱います。
そのため、任意の1文字にマッチする\texttt{.}が𩸽という文字（Code
Point）にマッチします。

\begin{lstlisting}
const [all, fish] = "𩸽のひらき".match(/(.)のひらき/u);
console.log(all); // => "𩸽のひらき"
console.log(fish); // => "𩸽"
\end{lstlisting}

基本的には正規表現に\texttt{u}フラグをつけて問題となるケースは少ないはずです。
なぜなら、サロゲートペアの片方だけにマッチしたい正規表現を書くケースはまれであるためです。

\hypertarget{count-of-code-points}{%
\subsection{Code Pointの数を数える}\label{count-of-code-points}}\index{Code Point!かぞえる@数える}

Stringの\texttt{length}プロパティは、文字列を構成するCode
Unitの個数を表すプロパティです。
そのためサロゲートペアを含む文字列では、\texttt{length}の結果が見た目より大きな値となる場合があります。

\begin{lstlisting}[escapechar=@]
// Code Unitの個数を返す
console.log("@\includegraphics[clip,height=4mm]{fig/apple.eps}@".length); // => 2
console.log("\uD83C\uDF4E"); // => "@\includegraphics[clip,height=4mm]{fig/apple.eps}@"
console.log("\uD83C\uDF4E".length); // => 2
\end{lstlisting}

JavaScriptには、文字列におけるCode
Pointの個数を数えるメソッドは用意されていません。
これを行うには、文字列をCode
Pointごとに区切った配列へ変換して、配列の長さを数えるのが簡潔なやり方です。

\texttt{Array.from}\index{Array.from@\texttt{Array.from}}メソッド\,\protect\iconl{fig/es2015.eps}\,は、引数にiterable\index{iterable}なオブジェクトを受け取り、それを元にした新しい配列を返します。
iterableオブジェクトとは\texttt{Symbol.iterator}\index{Symbol.iterator@\texttt{Symbol.iterator}}という特別な名前のメソッドを実装したオブジェクトの総称で、\texttt{for...of}文などで反復処理が可能なオブジェクトです（詳細は「\hyperlink{loop-and-iteration}{ループと反復処理}」の章の「\hyperlink{for-of-statement}{for\ldots{}of文}」を参照）。

文字列もiterableオブジェクトであるため、\texttt{Array.from}メソッドによって1文字（厳密にはCode
Point）ごとに区切った配列へと変換できます。先ほども紹介したように、文字列をiterableとして扱う場合はCode
Pointごとに処理を行います。

\begin{lstlisting}[escapechar=@]
// Code Pointごとの配列にする
// Array.fromメソッドはIteratorを配列にする
const codePoints = Array.from("リンゴ@\includegraphics[clip,height=4mm]{fig/apple.eps}@");
console.log(codePoints); // => ["リ", "ン", "ゴ", "@\includegraphics[clip,height=4mm]{fig/apple.eps}@"]
// Code Pointの個数を数える
console.log(codePoints.length); // => 4
\end{lstlisting}

しかし、Code
Pointの数を数えた場合でも、直感的な結果にならない場合もあります。
なぜなら、Code
Pointには制御文字などの視覚的に見えないものも定義されているためです。
そのため、文字として数えたくないものは無視するなど、視覚的な\textbf{\textgt{文字列の長さ}}を数えるにはさらなる工夫が必要になります。

\hypertarget{loop-each-code-point}{%
\subsection{Code Pointごとに反復処理をする}\label{loop-each-code-point}}\index{Code Point!はんぷくしょり@反復処理}\index{はんぷくしょり@反復処理}

先ほど紹介した\texttt{Array.from}メソッドを使えば、文字列をCode
Pointで区切った文字の配列へと変換できます。
配列にすれば、あとは「\hyperlink{loop-and-iteration}{ループと反復処理}」の章で学んだ方法を使って、Code
Pointごとに反復処理ができます。

次のコードでは、文字列中に登場する\includegraphics[clip,height=4mm]{fig/apple.eps}の個数を数えています。
\texttt{countOfCodePoints}関数は、\texttt{Array.from}でCode
Pointごとの配列にし、配列を\texttt{codePoint}でフィルターした結果できた配列の要素数を返します。

\begin{lstlisting}[escapechar=@]
// 指定したcodePointの個数を数える
function countOfCodePoints(str, codePoint) {
    return Array.from(str).filter(item => {
        return item === codePoint;
    }).length;
}
console.log(countOfCodePoints("@\includegraphics[clip,height=3.3mm]{fig/fruits.eps}@", "@\includegraphics[clip,height=4mm]{fig/apple.eps}@")); // => 2
\end{lstlisting}

\texttt{for...of}による反復処理も文字列をCode
Pointごとに扱えます。
これは、\texttt{for...of}文が対象をIteratorとして列挙するためです。

先ほどのコードと同じ\texttt{countOfCodePoints}関数を\texttt{for...of}を使って実装してみます。

\begin{lstlisting}[escapechar=@]
// 指定したcodePointの個数を数える
function countOfCodePoints(str, codePoint) {
    let count = 0;
    for (const item of str) {
        if (item === codePoint) {
            count++;
        }
    }
    return count;
}
console.log(countOfCodePoints("@\includegraphics[clip,height=3.3mm]{fig/fruits.eps}@", "@\includegraphics[clip,height=4mm]{fig/apple.eps}@")); // => 2
\end{lstlisting}

\hypertarget{conclusion}{%
\section{まとめ}\label{conclusion}}

この章では、文字列とUnicodeの関係について簡潔に紹介しました。
Unicodeにはこの章で紹介しきれなかった表現もあります。
また、JavaScriptにはUnicodeをキレイに扱うAPIが用意されているとは言い切れない部分もあります。

一方で「\hyperlink{string}{文字列}」の章で紹介したように、Code
UnitやCode Pointを意識しなくても柔軟で強力な文字列処理ができます。
しかし、近年は絵文字を利用するケースが多くなったため、Code
Pointを意識したプログラミングが必要となるケースも増えています。

UnicodeはECMAScriptとは独立した仕様であるため、文字列を扱う悩みはプログラミング言語を問わずに出てくる共通の課題です。
特にJavaはJavaScriptと同じくUTF-16をエンコード方式として採用しているため、類似する問題が見られます。
そのため、JavaScriptで文字列処理の問題にぶつかった際には、他の言語ではどうしているかを調べることも重要です。
