\hypertarget{array}{%
\chapter{配列}\label{array}}\index{はいれつ@配列}
\thispagestyle{frontheadings}

配列はJavaScriptの中でもよく使われるオブジェクトです。

配列とは値に順序をつけて格納できるオブジェクトです。
配列に格納したそれぞれの値のことを\textbf{\textgt{要素}}\index{ようそ@要素}\index{はいれつ@配列!ようそ@要素}、それぞれの要素の位置のことを\textbf{\textgt{インデックス}}\index{いんでっくす@インデックス}\index{はいれつ@配列!いんでっくす@インデックス}（\texttt{index}\index{index}）と呼びます。
インデックスは先頭の要素から\texttt{0}、\texttt{1}、\texttt{2}のように\texttt{0}からはじまる連番となります。

またJavaScriptにおける配列は可変長です。
そのため配列を作成後に配列へ要素を追加したり、配列から要素を削除できます。

この章では、配列の基本的な操作と配列を扱う場合においてのパターンについて学びます。

\hypertarget{create-and-access}{%
\section{配列の作成とアクセス}\label{create-and-access}}

配列の作成と要素へのアクセス方法は「\hyperlink{data-type-and-literal}{データ型とリテラル}」の章の「\hyperlink{array-literal}{配列リテラル}」ですでに紹介していますが、
もう一度振り返ってみましょう。

配列の作成には配列リテラルを使います。
配列リテラル\index{はいれつりてらる@配列リテラル}（\texttt{[}と\texttt{]}\index{[]@\texttt{[]}}）の中に要素をカンマ（\texttt{,}）区切りで記述するだけです。

\begin{lstlisting}
const emptyArray = [];
const numbers = [1, 2, 3];
// 2次元配列（配列の配列）
const matrix = [
    ["a", "b"],
    ["c", "d"]
];
\end{lstlisting}

作成した配列の要素のインデックスとなる数値を、\texttt{配列[インデックス]}と記述することで、
そのインデックスの要素を配列から読み取れます。
配列の先頭要素のインデックスは\texttt{0}となります。配列のインデックスは、\texttt{0}以上\texttt{$2^{32} - 1$}未満の整数となります。

\begin{lstlisting}
const array = ["one", "two", "three"];
console.log(array[0]); // => "one"
\end{lstlisting}

2次元配列（配列の配列）からの値の読み取りも同様に\texttt{配列[インデックス]}でアクセスできます。
\texttt{配列[0][0]}は、配列の\texttt{0}番目の要素である配列（\texttt{["a", "b"]}）の\texttt{0}番目の要素を読み取ります。

\begin{lstlisting}
// 2次元配列（配列の配列）
const matrix = [
    ["a", "b"],
    ["c", "d"]
];
console.log(matrix[0][0]); // => "a"
\end{lstlisting}

配列の\texttt{length}\index{はいれつ@配列!length@\texttt{length}}\index{length@\texttt{length}}プロパティは配列の要素の数を返します。
そのため、配列の最後の要素へアクセスするには
\texttt{array.length - 1}
をインデックスとして利用できます。

\begin{lstlisting}
const array = ["one", "two", "three"];
console.log(array.length); // => 3
// 配列の要素数 - 1 が 最後の要素のインデックスとなる
console.log(array[array.length - 1]); // => "three"
\end{lstlisting}

一方、存在しないインデックスにアクセスした場合はどうなるでしょうか？　JavaScriptでは、存在しないインデックスに対してアクセスした場合に、例外ではなく\texttt{undefined}\index{undefined@\texttt{undefined}}を返します。

\begin{lstlisting}
const array = ["one", "two", "three"];
// arrayにはインデックスが100の要素は定義されていない
console.log(array[100]); // => undefined
\end{lstlisting}

これは、配列がオブジェクトであることを考えると、次のように存在しないプロパティへアクセスしているのと原理は同じです。
オブジェクトでも、存在しないプロパティへアクセスした場合には\texttt{undefined}が返ってきます。

\begin{lstlisting}
const obj = {
    "0": "one",
    "1": "two",
    "2": "three",
    "length": 3
};
// obj["100"]は定義されていないためundefinedが返る
console.log(obj[100]); // => undefined
\end{lstlisting}

また、配列は常に\texttt{length}の数だけ要素を持っているとは限りません。
次のように、配列リテラルでは値を省略することで、未定義の要素を含めることができます。
このような、配列の中に隙間があるものを\textbf{\textgt{疎な配列}}\index{そなはいれつ@疎な配列}\index{はいれつ@配列!そ@疎}と呼びます。
一方、隙間がなくすべてのインデックスに要素がある配列を\textbf{\textgt{密な配列}}\index{みつなはいれつ@密な配列}\index{はいれつ@配列!みつ@密}と呼びます。

\begin{lstlisting}
// 未定義の箇所が1つ含まれる疎な配列
// インデックスが1の値を省略しているので、カンマが2つ続いていることに注意
const sparseArray = [1, , 3];
console.log(sparseArray.length); // => 3
// 1番目の要素は存在しないため undefined が返る
console.log(sparseArray[1]); // => undefined
\end{lstlisting}

\hypertarget{array-at}{%
\subsection[\texttt{Array.prototype.at}]{\texttt{Array.prototype.at}\,\protect\icon{fig/es2022.eps}}\label{array-at}}\index{Array.prototype.at@\texttt{Array.prototype.at}}

配列の要素にアクセスするには\texttt{配列[インデックス]}という構文を使うことを紹介しました。
その際に、配列の末尾の要素へアクセスするには、\texttt{array[array.length - 1]}という\texttt{length}プロパティを使う必要があります。
\texttt{array}を2回書く必要があるなど、末尾の要素へのアクセスは少し手間が必要になっていました。

この問題を解決するためES2022では、相対的なインデックスの値を指定して配列の要素へアクセスできる\texttt{Array.prototype.at}メソッドが追加されました。
Arrayの\texttt{at}\index{at@\texttt{at}}メソッドは、\texttt{配列[インデックス]}とよく似ていますが、相対的なインデックスの値を引数として渡せます。
\texttt{.at(0)}や\texttt{.at(1)}などのように0以上のインデックスを渡した場合は、\texttt{配列[インデックス]}と同じく指定した位置の要素へアクセスできます。
一方で、\texttt{.at(-1)}のようにマイナスのインデックスを渡した場合は、末尾から数えた位置の要素へアクセスできます。
\begin{lstlisting}
const array = ["a", "b", "c"];
//
console.log(array.at(0)); // => "a"
console.log(array.at(1)); // => "b"
// 後ろから1つ目の要素にアクセス
console.log(array.at(-1)); // => "c"
// -1は、次のように書いた場合と同じ結果
console.log(array[array.length - 1]); // => "c"
\end{lstlisting}

\texttt{配列[インデックス]}のインデックスに\texttt{-1}を指定すると、配列オブジェクトの\texttt{"-1"}というプロパティ名へのアクセスとなります。
そのため\texttt{配列[-1]}と書くと、大抵の場合は\texttt{undefined}が返されます。

\begin{lstlisting}
const array = ["a", "b", "c"];
console.log(array[-1]); // => undefined
\end{lstlisting}

\hypertarget{detect-array}{%
\section{オブジェクトが配列かどうかを判定する}\label{detect-array}}

あるオブジェクトが配列かどうかを判定するには\texttt{Array.isArray}\index{Array.isArray@\texttt{Array.isArray}}メソッドを利用します。
\texttt{Array.isArray}メソッドは引数が配列ならば\texttt{true}を返します。
\newpage
\begin{lstlisting}
const obj = {};
const array = [];
console.log(Array.isArray(obj)); // => false
console.log(Array.isArray(array)); // => true
\end{lstlisting}

また、\texttt{typeof}演算子では配列かどうかを判定することはできません。
配列もオブジェクトの一種であるため、\texttt{typeof}演算子の結果が\texttt{"object"}となるためです。

\begin{lstlisting}
const array = [];
console.log(typeof array); // => "object"
\end{lstlisting}

\begin{tcolorbox}[title=TypedArray\,\protect\icon{fig/es2015.eps}]\label{typed-array}\index{TypedArray@\texttt{TypedArray}}

JavaScriptの配列は可変長のみですが、\texttt{TypedArray}という固定長でかつ型つきの配列を扱う別のオブジェクトが存在します。
\texttt{TypedArray}はバイナリデータのバッファを示すために使われるデータ型で、WebGLやバイナリを扱う場面で利用されます。
文字列や数値などのプリミティブ型の値を直接は利用できないため、通常の配列とは用途や使い勝手が異なります。

また、TypedArrayは\texttt{Array.isArray}のメソッドの結果が\texttt{false}となることからも別物と考えてよいでしょう。

\begin{lstlisting}
// TypedArrayを作成
const typedArray = new Int8Array(8);
console.log(Array.isArray(typedArray)); // => false
\end{lstlisting}

そのため、JavaScriptで配列といった場合には\texttt{Array}を示します。
\end{tcolorbox}

\hypertarget{array-destructuring}{%
\section[配列と分割代入]{配列と分割代入\,\protect\icon{fig/es2015.eps}}\label{array-destructuring}}\index{ぶんかつだいにゅう@分割代入}\index{はいれつ@配列!ぶんかつだいにゅう@分割代入}

配列の指定したインデックスの値を変数として定義し直す場合には、分割代入（Destructuring
assignment\index{Destructuring assignment}）が利用できます。

配列の分割代入では、左辺に配列リテラルのような構文で定義したい変数名を書きます。
右辺の配列から対応するインデックスの要素が、左辺で定義した変数に代入されます。

次のコードでは、左辺に定義した変数に対して、右辺の配列から対応するインデックスの要素が代入されます。
\texttt{first}にはインデックスが\texttt{0}の要素、\texttt{second}にはインデックスが\texttt{1}の要素、\texttt{third}にはインデックスが\texttt{2}の要素が代入されます。

\begin{lstlisting}
const array = ["one", "two", "three"];
const [first, second, third] = array;
console.log(first);  // => "one"
console.log(second); // => "two"
console.log(third);  // => "three"
\end{lstlisting}

\begin{tcolorbox}[enhanced jigsaw,breakable,title=undefinedの要素と未定義の要素の違い]\label{diff-undefined-and-no-element}\index{undefined@\texttt{undefined}}

疎な配列で該当するインデックスに要素がない場合は\texttt{undefined}を返します。
しかし、\texttt{undefined}という値も存在するため、配列に\texttt{undefined}という値がある場合に区別できません。

次のコードでは、\texttt{undefined}という値を要素として定義した密な配列と、要素そのものがない疎な配列を定義しています。
どちらも要素にアクセスした結果は\texttt{undefined}となり、区別できていないことがわかります。

\begin{lstlisting}
// 要素としてundefinedを持つ密な配列
const denseArray = [1, undefined, 3];
// 要素そのものがない疎な配列
const sparseArray = [1, , 3];
console.log(denseArray[1]); // => undefined
console.log(sparseArray[1]); // => undefined
\end{lstlisting}

この違いを見つける方法として利用できるのが\texttt{Object.hasOwn}\index{Object.hasOwn@\texttt{Object.hasOwn}}静的メソッドです。
\texttt{Object.hasOwn}\index{Object.hasOwn@\texttt{Object.hasOwn}}静的メソッドを使うことで、配列の指定したインデックスに要素自体が存在するかを判定できます。

\begin{lstlisting}
const denseArray = [1, undefined, 3];
const sparseArray = [1, , 3];
// 要素自体は存在し、その値がundefined
console.log(Object.hasOwn(denseArray, 1)); // => true
// 要素自体が存在しない
console.log(Object.hasOwn(sparseArray, 1)); // => false
\end{lstlisting}
\end{tcolorbox}

\hypertarget{search-element}{%
\section{配列から要素を検索}\label{search-element}}\index{はいれつ@配列!けんさく@検索}

配列から指定した要素を検索する目的には、 主に次の3つがあります。

\begin{itemize}
\item
  その要素のインデックスが欲しい場合
\item
  その要素自体が欲しい場合
\item
  その要素が含まれているかという真偽値が欲しい場合
\end{itemize}

配列にはそれぞれに対応したメソッドが用意されているため、目的別に見ていきます。

\hypertarget{indexof}{%
\subsection{インデックスを取得}\label{indexof}}\index{いんでっくす@インデックス!しゅとく@取得}

\enlargethispage{\baselineskip}指定した要素が配列のどの位置にあるかを知りたい場合、Arrayの\texttt{indexOf}\index{indexOf@\texttt{indexOf}}メソッドや\texttt{findIndex}\index{findIndex@\texttt{findIndex}}メソッド\,\protect\iconl{fig/es2015.eps}\,を利用します。
要素の位置のことを\textbf{\textgt{インデックス}}（\texttt{index}）と呼ぶため、メソッド名にも\texttt{index}という名前が入っています。

次のコードでは、Arrayの\texttt{indexOf}メソッドを利用して、配列の中から\texttt{"JavaScript"}という文字列のインデックスを取得しています。
\texttt{indexOf}メソッドは引数と厳密等価演算子（\texttt{===}）で一致する要素があるなら、その要素のインデックスを返し、該当する要素がない場合は\texttt{-1}を返します。
\texttt{indexOf}\index{indexOf@\texttt{indexOf}}メソッドは先頭から検索して見つかった要素のインデックスを返します。
\texttt{indexOf}メソッドには対となるArrayの\texttt{lastIndexOf}\index{lastIndexOf@\texttt{lastIndexOf}}メソッドがあり、\texttt{lastIndexOf}\index{lastIndexOf@\texttt{lastIndexOf}}メソッドでは末尾から検索した結果が得られます。

\begin{lstlisting}
const array = ["Java", "JavaScript", "Ruby"];
const indexOfJS = array.indexOf("JavaScript");
console.log(indexOfJS); // => 1
console.log(array[indexOfJS]); // => "JavaScript"
// "JS" という要素はないため -1 が返される
console.log(array.indexOf("JS")); // => -1
\end{lstlisting}

\texttt{indexOf}メソッドは配列からプリミティブな要素を発見できますが、オブジェクトは持っているプロパティが同じでも別オブジェクトだと異なるものとして扱われます。
次のコードを見ると、同じプロパティを持つ異なるオブジェクトは、\texttt{indexOf}メソッドでは見つけることができません。
これは、異なる参照を持つオブジェクト同士は\texttt{===}で比較しても一致しないためです。

\begin{lstlisting}
const obj = { key: "value" };
const array = ["A", "B", obj];
console.log(array.indexOf({ key: "value" })); // => -1
// リテラルは新しいオブジェクトを作るため、異なるオブジェクトだと判定される
console.log(obj === { key: "value" }); // => false
// 等価のオブジェクトを検索してインデックスを返す
console.log(array.indexOf(obj)); // => 2
\end{lstlisting}

このように、異なるオブジェクトだが値は同じものを見つけたい場合には、Arrayの\texttt{findIndex}\index{findIndex@\texttt{findIndex}}メソッドが利用できます。
\texttt{findIndex}\index{findIndex@\texttt{findIndex}}メソッドの引数には配列の各要素をテストする関数をコールバック関数として渡します。
\texttt{indexOf}メソッドとは異なり、テストする処理を自由に書けます。
これにより、プロパティの値が同じ要素を配列から見つけて、その要素のインデックスが得られます。

\enlargethispage{\baselineskip}\begin{lstlisting}
// colorプロパティを持つオブジェクトの配列
const colors = [
    { "color": "red" },
    { "color": "green" },
    { "color": "blue" }
];
// colorプロパティが"blue"のオブジェクトのインデックスを取得
const indexOfBlue = colors.findIndex((obj) => {
    return obj.color === "blue";
});
console.log(indexOfBlue); // => 2
console.log(colors[indexOfBlue]); // => { "color": "blue" }
\end{lstlisting}

\hypertarget{find}{%
\subsection{条件に一致する要素を取得}\label{find}}

配列から要素を取得する方法としてインデックスを使うこともできます。
先ほどのように\texttt{findIndex}メソッドでインデックスを取得し、そのインデックスで配列へアクセスすればよいだけです。

しかし、\texttt{findIndex}メソッドを使って要素を取得するケースでは、
そのインデックスが欲しいのか、またはその要素自体が欲しいのかがコードとして明確ではありません。

より明確に要素自体が欲しいということを表現するには、Arrayの\texttt{find}\index{find@\texttt{find}}メソッド\,\protect\iconl{fig/es2015.eps}\,が使えます。
\texttt{find}\index{find@\texttt{find}}メソッドには、\texttt{findIndex}メソッドと同様にテストする関数をコールバック関数として渡します。
\texttt{find}メソッドの返り値は、要素そのものとなり、要素が存在しない場合は\texttt{undefined}を返します。

\begin{lstlisting}
// colorプロパティを持つオブジェクトの配列
const colors = [
    { "color": "red" },
    { "color": "green" },
    { "color": "blue" }
];
// colorプロパティが"blue"のオブジェクトを取得
const blueColor = colors.find((obj) => {
    return obj.color === "blue";
});
console.log(blueColor); // => { "color": "blue" }
// 該当する要素がない場合はundefinedを返す
const whiteColor = colors.find((obj) => {
    return obj.color === "white";
});
console.log(whiteColor); // => undefined
\end{lstlisting}

\hypertarget{slice}{%
\subsection{指定範囲の要素を取得}\label{slice}}

配列から指定範囲の要素を取り出す方法としてArrayの\texttt{slice}\index{slice@\texttt{slice}}メソッドが利用できます。
\texttt{slice}\index{slice@\texttt{slice}}メソッドは、第一引数の開始位置から第二引数の終了位置（終了位置の要素は含まない）までの範囲を取り出した新しい配列を返します。
第二引数は省略でき、省略した場合は配列の末尾の要素まで含んだ新しい配列を返します。

\enlargethispage{\baselineskip}\begin{lstlisting}
const array = ["A", "B", "C", "D", "E"];
// インデックス1から4まで（4の要素は含まない）の範囲を取り出す
console.log(array.slice(1, 4)); // => ["B", "C", "D"]
// 第二引数を省略した場合は、第一引数から末尾の要素までを取り出す
console.log(array.slice(1)); // => ["B", "C", "D", "E"]
// マイナスを指定すると後ろから数えた位置となる
console.log(array.slice(-1)); // => ["E"]
// 第一引数と第二引数が同じ場合は、空の配列を返す
console.log(array.slice(1, 1)); // => []
// 第一引数 > 第二引数の場合、常に空配列を返す
console.log(array.slice(4, 1)); // => []
\end{lstlisting}

\texttt{slice}メソッドと引数の関係を図にすると次のようになります。

\begin{lstlisting}
 +-----+-----+-----+-----+-----+
 | "A" | "B" | "C" | "D" | "E" |
 +-----+-----+-----+-----+-----+
 0     1     2     3     4     5
-5    -4    -3    -2    -1
\end{lstlisting}

\hypertarget{get-boolean}{%
\subsection{真偽値を取得}\label{get-boolean}}\index{しんぎち@真偽値}

最後に、指定した要素が配列に含まれているかを知る方法について見ていきます。
インデックスや要素が取得できれば、その要素は配列に含まれているということはわかります。

しかし、指定した要素が含まれているか\textbf{\textgt{だけ}}を知りたい場合に、
Arrayの\texttt{findIndex}メソッドや\texttt{find}メソッドは過剰な機能を持っています。
そのコードを読んだ人には、取得したインデックスや要素を何に使うのかが明確ではありません。

次のコードは、Arrayの\texttt{indexOf}メソッドを利用し、該当する要素が含まれているかを判定しています。
\texttt{indexOf}メソッドの結果を\texttt{indexOfJS}に代入していますが、含まれているかを判定する以外には利用していません。
コードを隅々まで読まないといけないため、意図が明確ではなくコードの読みづらさにつながります。

\begin{lstlisting}
const array = ["Java", "JavaScript", "Ruby"];
// indexOfメソッドは含まれていないときのみ-1を返すことを利用
const indexOfJS = array.indexOf("JavaScript");
if (indexOfJS !== -1) {
    console.log("配列にJavaScriptが含まれている");
    // ... いろいろな処理 ...
    // indexOfJSは、含まれているのかの判定以外には利用していない
}
\end{lstlisting}

\enlargethispage{\baselineskip}そこで、ES2016で導入されたArrayの\texttt{includes}\index{includes@\texttt{includes}}メソッド\,\protect\iconl{fig/es2016.eps}\,を利用します。
Arrayの\texttt{includes}メソッドは配列に指定要素が含まれているかを判定します。
\texttt{includes}\index{includes@\texttt{includes}}メソッドは真偽値を返すので、\texttt{indexOf}メソッドを使った場合に比べて意図が明確になります。
前述のコードでは次のように\texttt{includes}メソッドを使うべきでしょう。

\begin{lstlisting}
const array = ["Java", "JavaScript", "Ruby"];
// includesは含まれているならtrueを返す
if (array.includes("JavaScript")) {
    console.log("配列にJavaScriptが含まれている");
}
\end{lstlisting}

\texttt{includes}メソッドは、\texttt{indexOf}メソッドと同様、異なるオブジェクトだが値が同じものを見つけたい場合には利用できません。
Arrayの\texttt{find}メソッドのようにテストするコールバック関数を利用して真偽値を得るには、Arrayの\texttt{some}\index{some@\texttt{some}}メソッドを利用できます。

Arrayの\texttt{some}メソッドはテストするコールバック関数にマッチする要素があるなら\texttt{true}を返し、存在しない場合は\texttt{false}を返します
（「\hyperlink{loop-and-iteration}{ループと反復処理}」の章の「\hyperlink{array-some}{配列の\texttt{some}メソッド}」を参照）。

\begin{lstlisting}
// colorプロパティを持つオブジェクトの配列
const colors = [
    { "color": "red" },
    { "color": "green" },
    { "color": "blue" }
];
// colorプロパティが"blue"のオブジェクトがあるかどうか
const isIncludedBlueColor = colors.some((obj) => {
    return obj.color === "blue";
});
console.log(isIncludedBlueColor); // => true
\end{lstlisting}

\hypertarget{add-and-delete}{%
\section{追加と削除}\label{add-and-delete}}

配列は可変長であるため、作成後の配列に対して要素を追加、削除できます。

要素を配列の末尾へ追加するにはArrayの\texttt{push}\index{push@\texttt{push}}が利用できます。
一方、末尾から要素を削除するにはArrayの\texttt{pop}\index{pop@\texttt{pop}}が利用できます。

\begin{lstlisting}
const array = ["A", "B", "C"];
array.push("D"); // "D"を末尾に追加
console.log(array); // => ["A", "B", "C", "D"]
const poppedItem = array.pop(); // 最末尾の要素を削除し、その要素を返す
console.log(poppedItem); // => "D"
console.log(array); // => ["A", "B", "C"]
\end{lstlisting}

要素を配列の先頭へ追加するにはArrayの\texttt{unshift}\index{unshift@\texttt{unshift}}が利用できます。
一方、配列の先頭から要素を削除するにはArrayの\texttt{shift}\index{shift@\texttt{shift}}が利用できます。
\newpage
\begin{lstlisting}
const array = ["A", "B", "C"];
array.unshift("S"); // "S"を先頭に追加
console.log(array); // => ["S", "A", "B", "C"]
const shiftedItem = array.shift(); // 先頭の要素を削除
console.log(shiftedItem); // => "S"
console.log(array); // => ["A", "B", "C"]
\end{lstlisting}

\hypertarget{concat}{%
\section{配列同士を結合}\label{concat}}\index{はいれつ@配列!けつごう@結合}

Arrayの\texttt{concat}\index{concat@\texttt{concat}}メソッドを使うことで配列と配列を結合した新しい配列を作成できます。

\begin{lstlisting}
const array = ["A", "B", "C"];
const newArray = array.concat(["D", "E"]);
console.log(newArray); // => ["A", "B", "C", "D", "E"]
\end{lstlisting}

また、\texttt{concat}\index{concat@\texttt{concat}}メソッドは配列だけではなく任意の値を要素として結合できます。

\begin{lstlisting}
const array = ["A", "B", "C"];
const newArray = array.concat("新しい要素");
console.log(newArray); // => ["A", "B", "C", "新しい要素"]
\end{lstlisting}

\hypertarget{spread}{%
\section[配列の展開]{配列の展開\,\protect\icon{fig/es2015.eps}}\label{spread}}\index{はいれつ@配列!てんかい@展開}

\texttt{...}（Spread構文）を使うことで、配列リテラル中に既存の配列を展開できます。

次のコードでは、配列リテラルの末尾に配列を展開しています。
これは、Arrayの\texttt{concat}メソッドで配列同士を結合するのと同じ結果になります。

\begin{lstlisting}
const array = ["A", "B", "C"];
// Spread構文を使った場合
const newArray = ["X", "Y", "Z", ...array];
// concatメソッドの場合
const newArrayConcat = ["X", "Y", "Z"].concat(array);
console.log(newArray); // => ["X", "Y", "Z", "A", "B", "C"]
console.log(newArrayConcat); // => ["X", "Y", "Z", "A", "B", "C"]
\end{lstlisting}

Spread構文は、\texttt{concat}メソッドとは異なり、配列リテラル中の任意の位置に配列を展開できます。
そのため、次のように要素の途中に配列を展開できます。

\begin{lstlisting}
const array = ["A", "B", "C"];
const newArray = ["X", ...array, "Z"];
console.log(newArray); // => ["X", "A", "B", "C", "Z"]
\end{lstlisting}

\hypertarget{flat}{%
\section[配列をフラット化]{配列をフラット化\,\protect\icon{fig/es2019.eps}}\label{flat}}\index{はいれつ@配列!ふらっとか@フラット化}\index{ふらっとか@フラット化}

Arrayの\texttt{flat}\index{flat@\texttt{flat}}メソッド\,\protect\iconl{fig/es2019.eps}\,を使うことで、多次元配列をフラットな配列に変換できます。
引数を指定しなかった場合は1段階のみのフラット化ですが、引数に渡す数値でフラット化する深さを指定できます。
配列をすべてフラット化する場合には、無限を意味する\texttt{Infinity}\index{Infinity@\texttt{Infinity}}を値として渡すことで実現できます。

\begin{lstlisting}
const array = [[["A"], "B"], "C"];
// 引数なしは1を指定した場合と同じ
console.log(array.flat()); // => [["A"], "B", "C"]
console.log(array.flat(1)); // => [["A"], "B", "C"]
console.log(array.flat(2)); // => ["A", "B", "C"]
// すべてをフラット化するにはInfinityを渡す
console.log(array.flat(Infinity)); // => ["A", "B", "C"]
\end{lstlisting}

また、Arrayの\texttt{flat}メソッドは必ず新しい配列を作成して返すメソッドです。
そのため、これ以上フラット化できない配列をフラット化しても、同じ要素を持つ新しい配列を返します。

\begin{lstlisting}
const array = ["A", "B", "C"];
console.log(array.flat()); // => ["A", "B", "C"]
\end{lstlisting}

\hypertarget{delete-element}{%
\section{配列から要素を削除}\label{delete-element}}\index{はいれつ@配列!さくじょ@削除}

\hypertarget{splice}{%
\subsection{\texorpdfstring{\texttt{Array.prototype.splice}}{Array.prototype.splice}}\label{splice}}\index{Array.prototype.splice@\texttt{Array.prototype.splice}}

配列の先頭や末尾の要素を削除する場合はArrayの\texttt{shift}メソッドや\texttt{pop}メソッドで行えます。
しかし、配列の任意のインデックスの要素を削除できません。
配列の任意のインデックスの要素を削除するにはArrayの\texttt{splice}メソッドを利用できます。

\texttt{splice}メソッドを利用すると、削除した要素を自動で詰めることができます。
\texttt{splice}メソッドは指定したインデックスから、指定した数だけ要素を取り除き、必要ならば要素を同時に追加できます。

\begin{lstlisting}
const array = [];
array.splice(インデックス, 削除する要素数);
// 削除と同時に要素の追加もできる
array.splice(インデックス, 削除する要素数, ...追加する要素);
\end{lstlisting}

たとえば、配列のインデックスが\texttt{1}の要素を削除するには、インデックス\texttt{1}から\texttt{1}つの要素を削除するという指定をする必要があります。
このとき、削除した要素は自動で詰められるため、疎な配列にはなりません。
\newpage
\begin{lstlisting}
const array = ["a", "b", "c"];
// 1番目から1つの要素("b")を削除
array.splice(1, 1);
console.log(array); // => ["a", "c"]
console.log(array.length); // => 2
console.log(array[1]); // => "c"
// すべて削除
array.splice(0, array.length);
console.log(array.length); // => 0
\end{lstlisting}

\hypertarget{assign-to-length}{%
\subsection{\texorpdfstring{\texttt{length}プロパティへの代入}{lengthプロパティへの代入}}\label{assign-to-length}}\index{length@\texttt{length}}\index{はいれつ@配列!length@\texttt{length}}

配列のすべての要素を削除することはArrayの\texttt{splice}で行えますが、
配列の\texttt{length}プロパティへの代入を利用した方法もあります。

\begin{lstlisting}
const array = [1, 2, 3];
array.length = 0; // 配列を空にする
console.log(array); // => []
\end{lstlisting}

配列の\texttt{length}プロパティへ\texttt{要素数}を代入すると、その要素数に配列が切り詰められます。
つまり、\texttt{length}プロパティへ\texttt{0}を代入すると、インデックスが\texttt{0}以降の要素がすべて削除されます。

\hypertarget{assign-empty-array}{%
\subsection{空の配列を代入}\label{assign-empty-array}}

最後に、その配列の要素を削除するのではなく、新しい空の配列を変数へ代入する方法です。
次のコードでは、\texttt{array}変数に空の配列を代入することで、\texttt{array}に空の配列を参照させています。

\begin{lstlisting}
let array = [1, 2, 3];
console.log(array.length); // => 3
// 新しい配列で変数を上書き
array = [];
console.log(array.length); // => 0
\end{lstlisting}

元々、\texttt{array}変数が参照していた\texttt{[1, 2, 3]}はどこからも参照されなくなり、ガベージコレクションによりメモリから解放されます。

また、\texttt{const}で宣言した配列の場合は変数に対して再代入できないため、この手法は使えません。
そのため、再代入をしたい場合は\texttt{let}または\texttt{var}で変数宣言をする必要があります。

\begin{lstlisting}
const array = [1, 2, 3];
console.log(array.length); // => 3
// constで宣言された変数には再代入できない
array = []; // TypeError: invalid assignment to const `array' が発生
\end{lstlisting}

\hypertarget{mutable-immutable}{%
\section{破壊的なメソッドと非破壊的なメソッド}\label{mutable-immutable}}\index{はかいてきなめそっど@破壊的なメソッド}\index{ひはかいてきなめそっど@非破壊的なメソッド}

これまで紹介してきた配列を変更するメソッドには、破壊的なメソッドと非破壊的メソッドがあります。この破壊的なメソッドと非破壊的メソッドの違いを知ることは、意図しない結果を避けるために重要です。
破壊的なメソッドとは、配列オブジェクトそのものを変更し、変更した配列または変更箇所を返すメソッドです。
非破壊的メソッドとは、配列オブジェクトのコピーを作成してから変更し、そのコピーした配列を返すメソッドです。

破壊的なメソッドの例として、配列に要素を追加するArrayの\texttt{push}\index{push@\texttt{push}}メソッドがあります。
\texttt{push}\index{push@\texttt{push}}メソッドは、\texttt{myArray}の配列そのものへ要素を追加しています。
その結果\texttt{myArray}変数の参照する配列が変更されるため破壊的なメソッドです。

\begin{lstlisting}
const myArray = ["A", "B", "C"];
const result = myArray.push("D"); 
// pushの返り値は配列ではなく、追加後の配列のlength
console.log(result); // => 4
// myArrayが参照する配列そのものが変更されている
console.log(myArray); // => ["A", "B", "C", "D"]
\end{lstlisting}

非破壊的なメソッドの例として、配列に要素を結合するArrayの\texttt{concat}\index{concat@\texttt{concat}}メソッドがあります。
\texttt{concat}\index{concat@\texttt{concat}}メソッドは、\texttt{myArray}をコピーした配列に対して要素を結合し、その配列を返します。
\texttt{myArray}変数の参照する配列は変更されないため非破壊的なメソッドです。

\begin{lstlisting}
const myArray = ["A", "B", "C"];
// concatの返り値は結合済みの新しい配列
const newArray = myArray.concat("D");
console.log(newArray); // => ["A", "B", "C", "D"]
// myArrayは変更されていない
console.log(myArray); // => ["A", "B", "C"]
// newArrayとmyArrayは異なる配列オブジェクト
console.log(myArray === newArray); // => false
\end{lstlisting}

JavaScriptにおいて破壊的なメソッドと非破壊的メソッドを名前から見分ける方法はありません。
また、配列を返す破壊的なメソッドもあるため、返り値からも判別できません。
たとえば、Arrayの\texttt{sort}\index{sort@\texttt{sort}}メソッドは返り値がソート済みの配列ですが破壊的メソッドです。

次の表で紹介するメソッド\footnote{\url{https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/}}は破壊的なメソッドです。
\newpage
\begin{small}
\begin{longtable}[l]{p{73mm}|p{67mm}}
\hline\rowcolor[gray]{0.85}\rule[0mm]{0mm}{4mm}\textgt{メソッド名} & \textgt{返り値}\tabularnewline
\hline
\endhead
\href{https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/pop}{\texttt{Array.prototype.pop}}
& 配列の末尾の値\tabularnewline
\href{https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/push}{\texttt{Array.prototype.push}}
& 変更後の配列のlength\tabularnewline
\href{https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/splice}{\texttt{Array.prototype.splice}}
& 取り除かれた要素を含む配列\tabularnewline
\href{https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse}{\texttt{Array.prototype.reverse}}
& 反転した配列\tabularnewline
\href{https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/shift}{\texttt{Array.prototype.shift}}
& 配列の先頭の値\tabularnewline
\href{https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/sort}{\texttt{Array.prototype.sort}}
& ソートした配列\tabularnewline
\href{https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift}{\texttt{Array.prototype.unshift}}
& 変更後の配列のlength\tabularnewline
\href{https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}{\texttt{Array.prototype.copyWithin}}\,\protect\iconl{fig/es2015.eps}
& 変更後の配列\tabularnewline
\href{https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/fill}{\texttt{Array.prototype.fill}}\,\protect\iconl{fig/es2015.eps}
& 変更後の配列\tabularnewline
\hline
\end{longtable}
\end{small}

破壊的メソッドは意図せぬ副作用を与えてしまうことがあるため、そのことを意識して利用する必要があります。
たとえば、配列から特定のインデックスの要素を削除する\texttt{removeAtIndex}という関数を提供したいとします。

\begin{lstlisting}
// arrayのindex番目の要素を削除した配列を返す関数
function removeAtIndex(array, index) { /* 実装 */ }
\end{lstlisting}

次のように、破壊的なメソッドであるArrayの\texttt{splice}\index{splice@\texttt{splice}}メソッドで要素を削除すると、引数として受け取った配列にも影響を与えます。
この場合\texttt{removeAtIndex}関数には副作用があるため、破壊的であることについてのコメントがあると親切です。

\begin{lstlisting}
// arrayのindex番目の要素を削除した配列を返す関数
// 引数のarrayは破壊的に変更される
function removeAtIndex(array, index) {
    array.splice(index, 1);
    return array;
}
const array = ["A", "B", "C"];
// arrayから1番目の要素を削除した配列を取得
const newArray = removeAtIndex(array, 1);
console.log(newArray); // => ["A", "C"]
// array自体にも影響を与える
console.log(array); // => ["A", "C"]
\end{lstlisting}

一方、非破壊的メソッドは配列のコピーを作成するため、元々の配列に対して影響はありません。
この\texttt{removeAtIndex}関数を非破壊的なものにするには、受け取った配列をコピーしてから変更を加える必要があります。

JavaScriptには\texttt{copy}メソッドそのものは存在しませんが、配列をコピー\index{はいれつ@配列!こぴー@コピー}する方法としてArrayの\texttt{slice}メソッドと\texttt{concat}メソッドが利用されています。\texttt{slice}メソッドと\texttt{concat}メソッドは引数なしで呼び出すと、その配列のコピーを返します。
\newpage
\begin{lstlisting}
const myArray = ["A", "B", "C"];
// sliceはmyArrayのコピーを返す - myArray.concat()でも同じ
const copiedArray = myArray.slice();
myArray.push("D");
console.log(myArray); // => ["A", "B", "C", "D"]
// arrayのコピーであるcopiedArrayには影響がない
console.log(copiedArray); // => ["A", "B", "C"]
// コピーであるため参照は異なる
console.log(copiedArray === myArray); // => false
\end{lstlisting}

コピーした配列に変更を加えることで、\texttt{removeAtIndex}関数を非破壊的な関数として実装できます。
非破壊的であれば引数の配列への副作用がないので、注意させるようなコメントは不要です。

\begin{lstlisting}
// arrayのindex番目の要素を削除した配列を返す関数
function removeAtIndex(array, index) {
    // コピーを作成してから変更する
    const copiedArray = array.slice();
    copiedArray.splice(index, 1);
    return copiedArray;
}
const array = ["A", "B", "C"];
// arrayから1番目の要素を削除した配列を取得
const newArray = removeAtIndex(array, 1);
console.log(newArray); // => ["A", "C"]
// 元のarrayには影響がない
console.log(array); // => ["A", "B", "C"]
\end{lstlisting}

このようにJavaScriptの配列には破壊的なメソッドと非破壊的メソッドが混在しています。そのため、統一的なインターフェースで扱えないのが現状です。
このような背景もあるため、JavaScriptには配列を扱うためのさまざまライブラリが存在します。
非破壊的な配列を扱うライブラリの例として\href{https://github.com/azu/immutable-array-prototype}{immutable-array-prototype}\index{immutable-array-prototype}\footnote{\url{https://github.com/azu/immutable-array-prototype}}や\href{https://immutable-js.com/}{Immutable.js}\index{Immutable.js}\footnote{\url{https://immutable-js.com/}}などがあります。

\hypertarget{array-iterate}{%
\section{配列を反復処理するメソッド}\label{array-iterate}}\index{はいれつ@配列!はんぷくしょり@反復処理}\index{はんぷくしょり@反復処理}

「\hyperlink{loop-and-iteration}{ループと反復処理}」の章において配列を反復処理する方法を一部解説しましたが、改めて関連するArrayメソッドを見ていきます。
反復処理の中でもよく利用されるのがArrayの\texttt{forEach}、\texttt{map}、\texttt{filter}、\texttt{reduce}メソッドです。
どのメソッドも共通して引数にコールバック関数を受け取るため高階関数と呼ばれます。

\hypertarget{array-foreach}{%
\subsection{\texorpdfstring{\texttt{Array.prototype.forEach}}{Array.prototype.forEach}}\label{array-foreach}}\index{Array.prototype.forEach@\texttt{Array.prototype.forEach}}

Arrayの\texttt{forEach}メソッドは配列の要素を先頭から順番にコールバック関数へ渡し、反復処理を行うメソッドです。

次のようにコールバック関数には\texttt{要素, インデックス, 配列}が引数として渡され、配列要素の先頭から順番に反復処理します。

\begin{lstlisting}
const array = [1, 2, 3];
array.forEach((currentValue, index, array) => {
    console.log(currentValue, index, array);
});
// コンソールの出力
// 1, 0, [1, 2, 3]
// 2, 1, [1, 2, 3]
// 3, 2, [1, 2, 3]
\end{lstlisting}

\hypertarget{array-map}{%
\subsection{\texorpdfstring{\texttt{Array.prototype.map}}{Array.prototype.map}}\label{array-map}}\index{Array.prototype.map@\texttt{Array.prototype.map}}

Arrayの\texttt{map}メソッドは配列の要素を順番にコールバック関数へ渡し、コールバック関数が返した値から新しい配列を返す非破壊的なメソッドです。
配列の各要素を加工したい場合に利用します。

次のようにコールバック関数には\texttt{要素, インデックス, 配列}が引数として渡され、配列要素の先頭から順番に反復処理します。
\texttt{map}\index{map@\texttt{map}}メソッドの返り値は、それぞれのコールバック関数が返した値を集めた新しい配列です。

\begin{lstlisting}
const array = [1, 2, 3];
// 各要素に10を乗算した新しい配列を作成する
const newArray = array.map((currentValue, index, array) => {
    return currentValue * 10;
});
console.log(newArray); // => [10, 20, 30]
// 元の配列とは異なるインスタンス
console.log(array === newArray); // => false
\end{lstlisting}

\hypertarget{array-filter}{%
\subsection{\texorpdfstring{\texttt{Array.prototype.filter}}{Array.prototype.filter}}\label{array-filter}}\index{Array.prototype.filter@\texttt{Array.prototype.filter}}

Arrayの\texttt{filter}メソッドは配列の要素を順番にコールバック関数へ渡し、コールバック関数が\texttt{true}を返した要素だけを集めた新しい配列を返す非破壊的なメソッドです。
配列から不要な要素を取り除いた配列を作成したい場合に利用します。

次のようにコールバック関数には\texttt{要素, インデックス, 配列}が引数として渡され、配列要素の先頭から順番に反復処理します。
\texttt{filter}\index{filter@\texttt{filter}}メソッドの返り値は、コールバック関数が\texttt{true}を返した要素だけを集めた新しい配列です。

\begin{lstlisting}
const array = [1, 2, 3];
// 奇数の値を持つ要素だけを集めた配列を返す
const newArray = array.filter((currentValue, index, array) => {
    return currentValue % 2 === 1;
});
console.log(newArray); // => [1, 3]
// 元の配列とは異なるインスタンス
console.log(array === newArray); // => false
\end{lstlisting}
\vspace{-3mm}
\hypertarget{array-reduce}{%
\subsection{\texorpdfstring{\texttt{Array.prototype.reduce}}{Array.prototype.reduce}}\label{array-reduce}}\index{Array.prototype.reduce@\texttt{Array.prototype.reduce}}

Arrayの\texttt{reduce}メソッドは累積値\index{るいせきち@累積値}（アキュムレータ\index{あきゅむれーた@アキュムレータ}）と配列の要素を順番にコールバック関数へ渡し、1つの累積値を返します。
配列から配列以外を含む任意の値を作成したい場合に利用します。

ここまでで紹介した反復処理のメソッドとは異なり、コールバック関数には\texttt{累積値, 要素, インデックス, 配列}を引数として渡します。
\texttt{reduce}\index{reduce@\texttt{reduce}}メソッドの第二引数には\texttt{累積値}の初期値となる値を渡せます。

次のコードでは、\texttt{reduce}メソッドは初期値を0として配列の各要素を加算した1つの数値を返します。
つまり配列から配列要素の合計値というNumber型の値を返しています。

\begin{lstlisting}
const array = [1, 2, 3];
// すべての要素を加算した値を返す
// accumulatorの初期値は0
const totalValue = array.reduce((accumulator, currentValue, index, array) => {
    return accumulator + currentValue;
}, 0);
// 0 + 1 + 2 + 3という式の結果が返り値になる
console.log(totalValue); // => 6
\end{lstlisting}

\texttt{reduce}メソッドに渡したコールバック関数は配列の要素数である3回呼び出され、それぞれ次のような結果になります。

\begin{small}
\begin{longtable}[l]{p{73mm}|p{20mm}lp{20mm}lp{27mm}}
\hline\rowcolor[gray]{0.85}\rule[0mm]{0mm}{4mm}\textgt{　} & \textgt{accumulator} & \textgt{currentValue} & \textgt{returnした値}\tabularnewline
\hline
\endhead
1回目の呼び出し & \texttt{0} & \texttt{1} & \texttt{0 + 1}\tabularnewline
2回目の呼び出し & \texttt{1} & \texttt{2} & \texttt{1 + 2}\tabularnewline
3回目の呼び出し & \texttt{3} & \texttt{3} & \texttt{3 + 3}\tabularnewline
\hline
\end{longtable}
\end{small}

Arrayの\texttt{reduce}メソッドはやや複雜ですが、配列から配列以外のデータ型の値を作成できる特徴があります。
また、\texttt{reduce}メソッドでは、配列から直接Number型の値を返せるため、\texttt{totalValue}という変数を再代入できない\texttt{const}で宣言していました。

配列の数値の合計を\texttt{forEach}メソッドなど反復処理で計算すると、次のコードのように\texttt{totalValue}という変数は再代入ができる\texttt{let}で宣言する必要があります。

\begin{lstlisting}
const array = [1, 2, 3];
// 初期値は0
let totalValue = 0;
array.forEach((currentValue) => {
    totalValue += currentValue;
});
console.log(totalValue); // => 6
\end{lstlisting}

\texttt{let}で宣言した変数は再代入が可能なため、意図しない箇所で変数の値が変更され、バグの原因となることがあります。
そのため、できる限り変数を\texttt{const}で宣言したい場合には\texttt{reduce}メソッドは有用です。
一方で、\texttt{reduce}メソッドは可読性があまりよくないため、コードの意図が伝わりにくいというデメリットもあります。

\texttt{reduce}メソッドには利点と可読性のトレードオフがありますが、利用する場合は\texttt{reduce}メソッドを扱う処理を関数で囲むなど処理の意図がわかるように工夫をする必要があります。

\begin{lstlisting}
const array = [1, 2, 3];
function sum(array) {
    return array.reduce((accumulator, currentValue) => {
        return accumulator + currentValue;
    }, 0);
}
console.log(sum(array)); // => 6
\end{lstlisting}

\begin{tcolorbox}[enhanced jigsaw,breakable,title=Array-likeオブジェクト]\label{array-like}\index{Array-like}
配列のように扱えるが配列ではないオブジェクトのことを、\textbf{\textgt{Array-likeオブジェクト}}と呼びます。
Array-likeオブジェクトとは配列のようにインデックスにアクセスでき、配列のように\texttt{length}プロパティも持っています。しかし、配列のインスタンスではないため、Arrayのプロトタイプメソッドを持っていないオブジェクトのことです。

\begin{small}
\begin{longtable}[l]{p{60mm}|p{40mm}|p{25mm}}
\hline\rowcolor[gray]{0.85}\rule[0mm]{0mm}{4mm}\textgt{機能} & \textgt{Array-likeオブジェクト} & \textgt{配列}\tabularnewline
\hline
\endhead
インデックスアクセス（\texttt{array[0]}） & できる &
できる\tabularnewline
長さ（\texttt{array.length}） & 持っている &
持っている\tabularnewline
Arrayのプロトタイプメソッド(\texttt{forEach}メソッドなど) &
持っていない場合もある & 持っている\tabularnewline
\hline
\end{longtable}
\end{small}

Array-likeオブジェクトの例として\texttt{arguments}\index{arguments@\texttt{arguments}}があります。
\texttt{arguments}オブジェクトは、\texttt{function}で宣言した関数の中から参照できる変数です。
\texttt{arguments}オブジェクトには関数の引数に渡された値が順番に格納されていて、配列のように引数へアクセスできます。

\begin{lstlisting}
function myFunc() {
    console.log(arguments[0]); // => "a"
    console.log(arguments[1]); // => "b"
    console.log(arguments[2]); // => "c"
    // 配列ではないため、配列のメソッドは持っていない
    console.log(typeof arguments.forEach); // => "undefined"
}
myFunc("a", "b", "c");
\end{lstlisting}

Array-likeオブジェクトか配列なのかを判別するには\texttt{Array.isArray}\index{Array.isArray@\texttt{Array.isArray}}メソッドを利用できます。
\texttt{Array-like}オブジェクトは配列ではないので結果は常に\texttt{false}となります。

\begin{lstlisting}
function myFunc() {
    console.log(Array.isArray([1, 2, 3])); // => true
    console.log(Array.isArray(arguments)); // => false
}
myFunc("a", "b", "c");
\end{lstlisting}

Array-likeオブジェクトは配列のようで配列ではないというもどかしさを持つオブジェクトです。\texttt{Array.from}\index{Array.from@\texttt{Array.from}}メソッド\,\protect\iconl{fig/es2015.eps}\,を使うことでArray-likeオブジェクトを配列に変換して扱うことができます。一度配列に変換してしまえばArrayメソッドも利用できます。

\begin{lstlisting}
function myFunc() {
    // Array-likeオブジェクトを配列へ変換
    const argumentsArray = Array.from(arguments);
    console.log(Array.isArray(argumentsArray)); // => true
    // 配列のメソッドを利用できる
    argumentsArray.forEach(arg => {
        console.log(arg);
    });
}
myFunc("a", "b", "c");
\end{lstlisting}
\end{tcolorbox}

\hypertarget{method-chain-and-high-order-function}{%
\section{メソッドチェーンと高階関数}\label{method-chain-and-high-order-function}}\index{めそっどちぇーん@メソッドチェーン}\index{こうかいかんすう@高階関数}

配列で頻出するパターンとしてメソッドチェーンがあります。
メソッドチェーンとは、メソッドを呼び出した返り値に対してさらにメソッド呼び出しをするパターンのことを言います。

次のコードでは、Arrayの\texttt{concat}メソッドの返り値、つまり配列に対してさらに\texttt{concat}メソッドを呼び出すというメソッドチェーンが行われています。

\begin{lstlisting}
const array = ["a"].concat("b").concat("c");
console.log(array); // => ["a", "b", "c"]
\end{lstlisting}

このコードの\texttt{concat}メソッドの呼び出しを分解してみると何が行われているのかわかりやすいです。
\texttt{concat}メソッドの返り値は結合した新しい配列です。先ほどのメソッドチェーンでは、その新しい配列に対してさらに\texttt{concat}メソッドで値を結合しているということがわかります。

\begin{lstlisting}
// メソッドチェーンを分解した例
// 一時的なabArrayという変数が増えている
const abArray = ["a"].concat("b");
console.log(abArray); // => ["a", "b"]
const abcArray = abArray.concat("c");
console.log(abcArray); // => ["a", "b", "c"]
\end{lstlisting}

メソッドチェーンを利用することで処理の見た目を簡潔にできます。メソッドチェーンを利用した場合も最終的な処理結果は同じですが、途中の一時的な変数を省略できます。先ほどの例では\texttt{abArray}という一時的な変数をメソッドチェーンでは省略できています。

メソッドチェーンは配列に限ったものではありませんが、配列では頻出するパターンです。なぜなら、配列に含まれるデータを表示する際には、最終的に文字列や数値など別のデータへ加工することがほとんどであるためです。配列には配列を返す高階関数が多く実装されているため、配列を柔軟に加工できます。

次のコードでは、ECMAScriptのバージョン名と発行年数が定義された\texttt{ECMAScriptVersions}という配列が定義されています。この配列から\texttt{2000}年以前に発行されたECMAScriptのバージョン名の一覧を取り出すことを考えてみます。目的の一覧を取り出すには「2000年以前のデータに絞り込む」と「データから\texttt{name}を取り出す」という2つの加工処理を組み合わせる必要があります。

この2つの加工処理はArrayの\texttt{filter}メソッドと\texttt{map}メソッドで実現できます。\texttt{filter}メソッドで配列から\texttt{2000}年以前というルールで絞り込み、\texttt{map}メソッドでそれぞれの要素から\texttt{name}プロパティを取り出せます。どちらのメソッドも配列を返すのでメソッドチェーンで処理をつなげられます。

\begin{lstlisting}
// ECMAScriptのバージョン名と発行年
const ECMAScriptVersions = [
    { name: "ECMAScript 1", year: 1997 },
    { name: "ECMAScript 2", year: 1998 },
    { name: "ECMAScript 3", year: 1999 },
    { name: "ECMAScript 5", year: 2009 },
    { name: "ECMAScript 5.1", year: 2011 },
    { name: "ECMAScript 2015", year: 2015 },
    { name: "ECMAScript 2016", year: 2016 },
    { name: "ECMAScript 2017", year: 2017 },
];
// メソッドチェーンで必要な加工処理を並べている
const versionNames = ECMAScriptVersions
    // 2000年以下のデータに絞り込み
    .filter(ECMAScript => ECMAScript.year <= 2000)
    // それぞれの要素からnameプロパティを取り出す
    .map(ECMAScript => ECMAScript.name);
console.log(versionNames); 
// => ["ECMAScript 1", "ECMAScript 2", "ECMAScript 3"]
\end{lstlisting}

メソッドチェーンを使うことで複数の処理からなるものをひとつのまとまった処理のように見せることができます。長すぎるメソッドチェーンは長すぎる関数と同じように読みにくくなりますが、適度な単位のメソッドチェーンは処理をスッキリ見せるパターンとして利用されています。

\hypertarget{conclusion}{%
\section{まとめ}\label{conclusion}}

この章では配列について学びました。

\begin{itemize}
\item
  配列は順序を持った要素を格納できるオブジェクトの一種
\item
  配列には破壊的なメソッドと非破壊的なメソッドがある
\item
  配列には反復処理を行う高階関数となるメソッドがある
\item
  メソッドチェーンは配列のメソッドが配列を返すことを利用している
\end{itemize}

\enlargethispage{\baselineskip}配列はJavaScriptの中でもよく使われるオブジェクトで、メソッドの種類も多いです。
この書籍でもすべてのメソッドは紹介していないため、詳しくは\href{https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array}{Arrayについてのドキュメント}\footnote{\url{https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array}}も参照してみてください。
